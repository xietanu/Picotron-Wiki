--[[pod,ts="1769527240897"]]
{[1]={name="readme.md",path="/picotron_api/gui/event_callbacks/readme.md",data={[1]={level=1,text="Picotron API > GUI > Event Callbacks",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on the event callbacks in Picotron's GUIs.",[3]="",[4]="Events are called with the arguments `self,msg`",[5]=""},children={}},[2]={level=2,text="Global `msg` properties",content={[1]="",[2]="All event callbacks will contain these properties in `msg`, alongside their element-specific properties.",[3]=""},children={[1]={level=3,text="dx",content={[1]="",[2]="Distance in pixels the mouse moved on the x axis this frame",[3]=""},children={}},[2]={level=3,text="dy",content={[1]="",[2]="Distance in pixels the mouse moved on the y axis this frame",[3]=""},children={}},[3]={level=3,text="mb",content={[1]="",[2]="Mouse buttons currently held down, as a bitfield. See [`mouse()`](/picotron_api/functions/mouse/main.md) for more info.",[3]=""},children={}},[4]={level=3,text="mx",content={[1]="",[2]="Position of mouse on x axis relative to this element",[3]=""},children={}},[5]={level=3,text="my",content={[1]="",[2]="Position of mouse on y axis relative to this element",[3]=""},children={}},[6]={level=3,text="has_pointer",content={[1]="",[2]="True if the mouse is currently hovering this element. Useful for mouseover effects.",[3]=""},children={}}}},[3]={level=2,text="Event Callbacks",content={[1]="",[2]="[update](update/main.md)",[3]="",[4]="[draw](draw/main.md)",[5]="",[6]="[click](click/main.md)",[7]="",[8]="[doubleclick](doubleclick/main.md)",[9]="",[10]="[tap](tap/main.md)",[11]="",[12]="[doubletap](doubletap/main.md)",[13]="",[14]="[release](release/main.md)",[15]="",[16]="[mousewheel](mousewheel/main.md)",[17]="",[18]="[drag](drag/main.md)",[19]="",[20]="[hover](hover/main.md)",[21]=""},children={}}}}}},[2]={name="main.md",path="/picotron_api/gui/event_callbacks/update/main.md",data={[1]={level=1,text="update",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered every gui:update_all()."},children={}}}}}},[3]={name="main.md",path="/picotron_api/program_structure/main.md",data={[1]={level=1,text="Program Structure",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This information is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html)",[3]="",[4]="This goes over the structure of Picotron Cartridges.",[5]=""},children={}},[2]={level=2,text="Optional functions for the cart-loop",content={[1]="",[2]="A Picotron program can optionally provide 3 functions:",[3]="",[4]="```lua",[5]="function _init()",[6]="-- called once just before the main loop",[7]="end",[8]="",[9]="function _update()",[10]="-- called 60 times per second",[11]="end",[12]="",[13]="function _draw()",[14]="-- called each time the window manager asks for a frame",[15]="-- (normally 60, 30 or 20 times per second)",[16]="end",[17]="```",[18]=""},children={}},[3]={level=2,text="Running Programs in the background",content={[1]="",[2]="A program that only contains `_update` (but no `_draw`) will continue to run in the background by default, but with a lower cpu priority.",[3]="",[4]="When `_draw` is also defined (and the program has a window or fullscreen display), the `_draw` and `_update` functions are only called when the program is at least partially visible. This allows Picotron to keep many tabs and workspaces open without impacting performance. In this case, the `_update` and/or `_draw` functions can be manually set to run in the background with:",[5]="",[6]="```lua",[7]="window{background_updates = true}",[8]="```",[9]="",[10]="or:",[11]="```lua",[12]="window{background_draws=true}",[13]="```",[14]="",[15]="respectively."},children={}}}}}},[4]={name="main.md",path="/picotron_api/gui/event_callbacks/tap/main.md",data={[1]={level=1,text="tap",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered if a mouse button is released within 0.3 seconds of being pressed and the mouse hasn’t moved.",[3]="",[4]="Use `msg.last_mb` if you want to check that a specific mouse button was released.",[5]="",[6]="The time duration is hard coded",[7]=""},children={}},[2]={level=2,text="msg values:",content={[1]=""},children={[1]={level=3,text="last_mb",content={[1]="    `msg.mb` from previous frame"},children={}}}}}}}},[5]={name="main.md",path="/picotron_api/gui/event_callbacks/release/main.md",data={[1]={level=1,text="release",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered on the first frame that a mouse button is released. Use `msg.last_mb` if you want to check that a specific mouse button was released.",[3]=""},children={}},[2]={level=2,text="msg values",content={[1]=""},children={[1]={level=3,text="last_mb",content={[1]="",[2]="msg.mb from previous frame",[3]=""},children={}},[2]={level=3,text="mx0",content={[1]="",[2]="X position where mouse was first clicked",[3]=""},children={}},[3]={level=3,text="my0",content={[1]="",[2]="Y position where mouse was first clicked"},children={}}}}}}}},[6]={name="main.md",path="/picotron_api/gui/event_callbacks/mousewheel/main.md",data={[1]={level=1,text="mousewheel",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered when mouse wheel scrolls over this element.",[3]=""},children={}},[2]={level=2,text="msg values",content={[1]=""},children={[1]={level=3,text="wheel_x",content={[1]="",[2]="Amount the wheel was scrolled horizontally this frame.",[3]=""},children={}},[2]={level=3,text="wheel_y",content={[1]="",[2]="Amount the wheel was scrolled vertically this frame"},children={}}}}}}}},[7]={name="main.md",path="/picotron_api/gui/event_callbacks/draw/main.md",data={[1]={level=1,text="draw",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered every gui:draw_all()."},children={}}}}}},[8]={name="main.md",path="/picotron_api/gui/event_callbacks/doubletap/main.md",data={[1]={level=1,text="doubleclick",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered if a mouse button is tapped twice within 0.4 seconds.",[3]="",[4]="The time duration is hard coded"},children={}}}}}},[9]={name="main.md",path="/picotron_api/gui/event_callbacks/hover/main.md",data={[1]={level=1,text="hover",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered every frame if the mouse is hovering over this element *if* the mouse is not clicked.",[3]="",[4]="Note: You may not need this callback if you just want a custom element to change color on mouseover. For that, see [msg.has_pointer](../../event_callbacks/readme.md).",[5]=""},children={}}}}}},[10]={name="main.md",path="/picotron_api/gui/event_callbacks/drag/main.md",data={[1]={level=1,text="drag",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered every frame that mouse button is held down, if the initial click was on this element.",[3]=""},children={}},[2]={level=2,text="msg values",content={[1]=""},children={[1]={level=3,text="has_pointer",content={[1]="",[2]="True if mouse pointer is directly over this element, false otherwise.",[3]=""},children={}},[2]={level=3,text="mx0",content={[1]="",[2]="X position where drag began - i.e. where mouse was first clicked",[3]=""},children={}},[3]={level=3,text="my0",content={[1]="",[2]="Y position where drag began - i.e. where mouse was first clicked",[3]="",[4]=""},children={}}}}}}}},[11]={name="main.md",path="/picotron_api/gui/event_callbacks/click/main.md",data={[1]={level=1,text="click",content={[1]="",[2]="Triggered on the first frame that a mouse button is pressed."},children={}}}},[12]={name="main.md",path="/picotron_api/gui/attributes/x/main.md",data={[1]={level=1,text="x",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Element position along the x axis",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: 0",[3]="",[4]="Valid values: Any number"},children={}}}}}},[13]={name="main.md",path="/picotron_api/gui/attributes/width_rel/main.md",data={[1]={level=1,text="width_rel",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Overwrites [`Element.width`](/picotron_api/gui/attributes/width/main.md) - if you want finer control over the final width, use [`Element.width_add`](/picotron_api/gui/attributes/width_add/main.md) or [`Element.min_width`](/picotron_api/gui/attributes/min_width/main.md).",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: nil",[3]="",[4]="Valid values: nil, number between 0 and 1",[5]="",[6]="If not nil, automatically adjusts element width based on [`parent.width`](/picotron_api/gui/attributes/width/main.md) as a decimal (the percentage / 100)",[7]="",[8]="e.g:",[9]="* 1 = 100% of the parent width",[10]="* 0.5 means 50%"},children={}}}}}},[14]={name="main.md",path="/picotron_api/gui/attributes/y/main.md",data={[1]={level=1,text="y",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Element position along the y axis",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: 0",[3]="",[4]="Valid values: Any number"},children={}}}}}},[15]={name="main.md",path="/picotron_api/gui/attributes/z/main.md",data={[1]={level=1,text="z",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Element position along the z axis.",[3]="",[4]="Elements with a higher z value will appear on top of elements with a lower z value.",[5]="",[6]="Elements with the same z value will be drawn in order based on which one was added first - newer elements are drawn on top of older elements.",[7]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: 0",[3]="",[4]="Valid values: Any number"},children={}}}}}},[16]={name="main.md",path="/picotron_api/gui/attributes/width_add/main.md",data={[1]={level=1,text="width_add",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="If [`Element.width_rel`](/picotron_api/gui/attributes/width_rel/main.md) is not nil, this value is added to the final width. ",[3]="",[4]="Otherwise, does nothing. ",[5]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: 0",[3]="",[4]="Valid values: any number"},children={}}}}}},[17]={name="main.md",path="/picotron_api/gui/attributes/squash_to_parent/main.md",data={[1]={level=1,text="squash_to_parent",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Unknown"},children={}}}}}},[18]={name="main.md",path="/picotron_api/gui/attributes/squash_to_clip/main.md",data={[1]={level=1,text="squash_to_clip",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Unknown"},children={}}}}}},[19]={name="main.md",path="/picotron_api/gui/attributes/vjustify/main.md",data={[1]={level=1,text="vjustify",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Automatically adjusts element y position based on element and parent vertical ",[3]="size. ",[4]="",[5]="[`Element.y`](/picotron_api/gui/attributes/y/main.md) is then added to the calculated value, functioning as an offset.",[6]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: \"top\"",[3]="",[4]="Valid values: \"top\", \"center\", \"bottom\""},children={}}}}}},[20]={name="main.md",path="/picotron_api/gui/attributes/min_height/main.md",data={[1]={level=1,text="min_height",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="If calculated height is less than this value, then this value is used as the [height](/picotron_api/gui/attributes/height/main.md) attribute instead.",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: nil",[3]="",[4]="Valid values: any number"},children={}}}}}},[21]={name="main.md",path="/picotron_api/gui/attributes/min_width/main.md",data={[1]={level=1,text="min_width",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="If calculated width is less than this value, then this value is used as the [width](/picotron_api/gui/attributes/width/main.md) attribute instead. ",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: nil",[3]="",[4]="Valid values: any number"},children={}}}}}},[22]={name="main.md",path="/picotron_api/gui/attributes/justify/main.md",data={[1]={level=1,text="justify",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Automatically adjusts element x position based on element and parent horizontal size.",[3]="",[4]="[`Element.x`](/picotron_api/gui/attributes/x/main.md) is then added to the calculated value, functioning as an offset.",[5]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: \"left\"",[3]="",[4]="Valid values: \"left\", \"center\", \"right\""},children={}}}}}},[23]={name="main.md",path="/picotron_api/gui/attributes/height_add/main.md",data={[1]={level=1,text="height_add",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="If [`Element.height_rel`](/picotron_api/gui/attributes/height_add/main.md) is not nil, this value is added to the final height. ",[3]="",[4]="Otherwise, does nothing.",[5]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: nil",[3]="",[4]="Valid values: any number"},children={}}}}}},[24]={name="main.md",path="/picotron_api/gui/attributes/height/main.md",data={[1]={level=1,text="height",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Height of the element",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Must be set to a number if [`height_rel`](/picotron_api/gui/attributes/height_rel/main.md) is not used.",[3]="",[4]="Default value: nil",[5]="",[6]="Valid values: any number"},children={}}}}}},[25]={name="main.md",path="/picotron_api/gui/attributes/cursor/main.md",data={[1]={level=1,text="cursor",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Sets the mouse cursor when this element is hovered over.",[3]=""},children={[1]={level=3,text="Values:",content={[1]="",[2]="Default value: nil",[3]="",[4]="See [`window()`][/picotron_api/functions/window/main.md]",[5]="",[6]="0: no cursor",[7]="1: default cursor",[8]="userdata u8: a custom cursor sprite.",[9]="",[10]="System cursors are named, and can be requested using a string: “pointer”, “grab”, “dial”, “crosshair”"},children={}}}}}}}},[26]={name="main.md",path="/picotron_api/gui/attributes/confine_to_clip/main.md",data={[1]={level=1,text="confine_to_clip",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Unknown"},children={}}}}}},[27]={name="main.md",path="/picotron_api/gui/attributes/confine_to_parent/main.md",data={[1]={level=1,text="confine_to_parent",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Reposition so that element remains inside parent -  when oversized, set x / y to 0",[3]="",[4]="This can be used with [`squash_to_parent`](/picotron_api/gui/attributes/squash_to__parent/main.md)",[5]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: false",[3]="",[4]="Valid values: true, false"},children={}}}}}},[28]={name="main.md",path="/picotron_api/gui/attributes/height_rel/main.md",data={[1]={level=1,text="height_rel",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Overwrites [`Element.height`](/picotron_api/gui/attributes/height/main.md) - if you want finer control over the final height, use [`Element.height_add`](/picotron_api/gui/attributes/height_add/main.md) or [`Element.min_height`](/picotron_api/gui/attributes/min_height/main.md).",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: nil",[3]="",[4]="Valid values: nil, number between 0 and 1",[5]="",[6]="If not nil, automatically adjusts element height based on [`parent.height`](/picotron_api/gui/attributes/height/main.md) as a decimal (the percentage / 100)",[7]="",[8]="e.g:",[9]="* 1 = 100% of the parent height",[10]="* 0.5 means 50%"},children={}}}}}},[29]={name="main.md",path="/picotron_api/gui/attributes/clip_to_parent/main.md",data={[1]={level=1,text="clip_to_parent",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Clips an element to the parent",[3]="",[4]="Events are also not clipped.",[5]="",[6]="Useful for UI elements that need to 'overhang' a parent window, for example.",[7]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Default value: true",[3]="",[4]="Valid values: true, false",[5]=""},children={[1]={level=3,text="If true",content={[1]="",[2]="the element will be clipped to the size of the parent.",[3]="",[4]="This also prevents events from triggering on the parts of the element outside the parent bounds.",[5]=""},children={}},[2]={level=3,text="If false",content={[1]="",[2]="the element will not be clipped to the size of the parent and can be positioned outside the parent."},children={}}}}}}}},[30]={name="main.md",path="/picotron_api/gui/attachments/attach_text_editor/main.md",data={[1]={level=1,text="attach_text_editor",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Attaches a text editor",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Required properties",content={[1]=""},children={[1]={level=3,text="x",content={[1]="",[2]="x-position of the element",[3]=""},children={}},[2]={level=3,text="y",content={[1]="",[2]="y-position of the element",[3]=""},children={}},[3]={level=3,text="width",content={[1]="",[2]="width of the element",[3]=""},children={}},[4]={level=3,text="height",content={[1]="",[2]="height of the element"},children={}}}}}}}},[31]={name="main.md",path="/picotron_api/gui/attachments/attach_scrollbars/main.md",data={[1]={level=1,text="el:attach_scrollbars()",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Attaches a scrollbar to the element",[3]="",[4]="assumes that self is a container element, where:",[5]="* child[1] is the element to be scrolled",[6]="* child[2] is the scrollbar",[7]="",[8]="Source: [source.lua](source.lua)",[9]=""},children={}},[2]={level=2,text="Example",content={[1]="",[2]="```lua",[3]="g = create_gui()",[4]="my_container = g:attach(my_container_attribs)",[5]="my_container:attach(my_contents)",[6]="my_container:attach_scrollbars()",[7]="```",[8]="",[9]="To allow mousewheel scrolling, you still need to process messages from contents as such:",[10]="",[11]="```lua",[12]="function contents:mousewheel(msg)",[13]="    self.y += msg.wheel_y * 32 -- scroll speed is arbitrary",[14]="end",[15]="```",[16]=""},children={}},[3]={level=2,text="Future",content={[1]="",[2]="mousewheel event should propagate up to parent though (if not defined)",[3]="",[4]="horizontal bar (or generalise to 2d)"},children={}}}}}},[32]={name="readme.md",path="/picotron_api/gui/attachments/readme.md",data={[1]={level=1,text="Picotron API > GUI > Attachments",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on the attachments in Picotron's GUIs.",[3]="",[4]="[Generic UI element](attach/main.md)",[5]="",[6]="[Button](attach_button/main.md)",[7]="",[8]="[Field](attach_field/main.md)",[9]="",[10]="[Pulldown](attach_pulldown/main.md)",[11]="",[12]="[Scrollbars](attach_scrollbars/main.md)",[13]="",[14]="[Text Editor](attach_text_editor/main.md)"},children={}}}}}},[33]={name="main.md",path="/picotron_api/gui/attributes/width/main.md",data={[1]={level=1,text="width",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Width of the element",[3]=""},children={}},[2]={level=2,text="Values",content={[1]="",[2]="Must be set to a number if [`width_rel`](/picotron_api/gui/attributes/width_rel/main.md) is not used.",[3]="",[4]="Default value: nil",[5]="",[6]="Valid values: any number"},children={}}}}}},[34]={name="main.md",path="/picotron_api/gui/attachments/attach_field/main.md",data={[1]={level=1,text="attach_field(el)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Attaches a text field to the element.",[3]="",[4]="Used for editing small amounts of text.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Expected attributes",content={[1]=""},children={[1]={level=3,text="x",content={[1]="",[2]="x-position of the element",[3]=""},children={}},[2]={level=3,text="y",content={[1]="",[2]="y-position of the element",[3]=""},children={}},[3]={level=3,text="width",content={[1]="",[2]="width of the element",[3]=""},children={}},[4]={level=3,text="height",content={[1]="",[2]="height of the element",[3]=""},children={}}}},[3]={level=2,text="Expected event callbacks",content={[1]=""},children={[1]={level=3,text="get() event callback",content={[1]="",[2]="A function to handle getting the field's intial text",[3]=""},children={}},[2]={level=3,text="set() event callback",content={[1]="",[2]="A function to handle setting the field's text to the user input"},children={}}}}}}}},[35]={name="main.md",path="/picotron_api/gui/attachments/attach_pulldown/main.md",data={[1]={level=1,text="el:attach_pulldown()",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Attaches a pulldown to the element",[3]="",[4]="Source: [source.lua](source.lua)",[5]="",[6]="Details unknown."},children={}}}}}},[36]={name="main.md",path="/picotron_api/gui/event_callbacks/doubleclick/main.md",data={[1]={level=1,text="doubleclick",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Triggered if a mouse button is clicked twice within 0.4 seconds.",[3]="",[4]="The time duration is hard coded"},children={}}}}}},[37]={name="readme.md",path="/picotron_api/gui/attributes/readme.md",data={[1]={level=1,text="Picotron API > GUI > Attributes",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on the general attributes for Picotron's GUIs",[3]=""},children={}},[2]={level=2,text="Attributes",content={[1]="",[2]="",[3]="[x](x/main.md)",[4]="",[5]="[y](y/main.md)",[6]="",[7]="[z](z/main.md)",[8]="",[9]="[width](width/main.md)",[10]="",[11]="[height](height/main.md)",[12]="",[13]="[clip_to_parent](clip_to_parent/main.md)",[14]="",[15]="[cursor](cursor/main.md)",[16]="",[17]="[squash_to_parent](squash_to_parent/main.md)",[18]="",[19]="[confine_to_clip](confine_to_clip/main.md)",[20]="",[21]="[squash_to_clip](squash_to_clip/main.md)",[22]="",[23]="[justify](justify/main.md)",[24]="",[25]="[vjustify](vjustify/main.md)",[26]="",[27]="[min_width](min_width/main.md)",[28]="",[29]="[min_height](min_height/main.md)",[30]="",[31]="[width_add](width_add/main.md)",[32]="",[33]="[height_add](height_add/main.md)",[34]="",[35]="[width_rel](width_rel/main.md)",[36]="",[37]="[height_rel](height_rel/main.md)"},children={}}}}}},[38]={name="cart.md",path="/cart.md",data={[1]={level=1,text="Picotron Wiki Cartridge",content={[1]=""},children={[1]={level=2,text="Information",content={[1]="",[2]="This is a cartridge making use of the pod form of the wiki's database.",[3]="",[4]="There are some known issues as listed below",[5]=""},children={}},[2]={level=2,text="Download",content={[1]="",[2]="This can be found on the [Lexaloffle BBS](https://www.lexaloffle.com/bbs/?tid=154532)",[3]="or downloaded with:",[4]="```",[5]="load #wiki -u",[6]="save /where/to/store/the/wiki/cart.p64",[7]="```",[8]=""},children={}},[3]={level=2,text="Credits",content={[1]="",[2]="Development - Astralsparv",[3]="Lilwide font - thelxinoe5",[4]="Word Wrapping algorithm - abledbody",[5]="Bug Testing - lumpycamel123",[6]=""},children={}},[4]={level=2,text="Features!",content={[1]="",[2]="Go through the *entire* wiki through the database.",[3]="",[4]="Includes basic markdown support",[5]="",[6]="Allows you to copy paste code snippets from codeblocks",[7]="",[8]="Codeblocks are auto-syntaxed",[9]="",[10]="Clickable hyperlinks",[11]="",[12]="Ability to open hyperlinks & pages in the host os by middle clicking (or CTRL clicking) them!",[13]="",[14]=""},children={}},[5]={level=2,text="To Do / Issues",content={[1]="",[2]="Some markdown formatting isn't correct (I think this comes from the pod db treating the md codeblock headers as real headers, seen in `documenting.md`)",[3]="",[4]="Custom themes:",[5]="",[6]="* Colors",[7]="* Fonts",[8]="",[9]="There's no variation between headers, they are all lilwide.",[10]="",[11]="No scrollbar & no max scroll"},children={}}}}}},[39]={name="main_to_do.md",path="/main_to_do.md",data={[1]={level=1,text="to do",content={[1]="",[2]="this is features that are more important/requested to be documented",[3]="",[4]="* userdata",[5]="* gui"},children={}}}},[40]={name="readme.md",path="/system/readme.md",data={[1]={level=1,text="system",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on things related to `/system/`",[3]="",[4]="[System Persistence](persistence/main.md)",[5]="",[6]="[Details of /system (the per file nitty gritty information)](details/readme.md)"},children={}}}}}},[41]={name="readme.md",path="/system/details/readme.md",data={[1]={level=1,text="system > details",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on all raw files of `/system/`",[3]="",[4]="[`/system/util`](util/)"},children={}}}}}},[42]={name="main.md",path="/system/details/util/shutdown/main.md",data={[1]={level=1,text="shutdown",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Shuts down Picotron",[3]="",[4]="Source: [source.lua](source.lua)"},children={}}}}}},[43]={name="main.md",path="/system/details/util/run/main.md",data={[1]={level=1,text="run",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Runs the current loaded cartridge (`/ram/cart/`)",[3]="",[4]="Source: [source.lua](source.lua)"},children={}}}}}},[44]={name="readme.md",path="/system/details/util/readme.md",data={[1]={level=1,text="util",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Documentation on all the default utilities seen in `/system/util`.",[2]="",[3]="Fully documented as of `0.2.1e`",[4]=""},children={}},[2]={level=2,text="Commands",content={[1]="",[2]="[config](config/)",[3]="",[4]="[cp](cp/)",[5]="",[6]="[default_app](default_app/)",[7]="",[8]="[dir](dir/)",[9]="",[10]="[edit](edit/)",[11]="",[12]="[export](export/)",[13]="",[14]="[folder](folder/)",[15]="",[16]="[help](help/)",[17]="",[18]="[info](info/)",[19]="",[20]="[kill](kill/)",[21]="",[22]="[load](load/)",[23]="",[24]="[ls](ls/)",[25]="",[26]="[mkdir](mkdir/)",[27]="",[28]="[mount](mount/)",[29]="",[30]="[mv](mv/)",[31]="",[32]="[open](open/)",[33]="",[34]="[ps](ps/)",[35]="",[36]="[pwc](pwc/)",[37]="",[38]="[pwd](pwd/)",[39]="",[40]="[reboot](reboot/)",[41]="",[42]="[rm](rm/)",[43]="",[44]="[run](run/)",[45]="",[46]="[save](save/)",[47]="",[48]="[shutdown](shutdown/)"},children={}}}}}},[45]={name="main.md",path="/system/details/util/pwd/main.md",data={[1]={level=1,text="pwc",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Returns the current working path",[3]="",[4]="Source: [source.lua](source.lua)"},children={}}}}}},[46]={name="main.md",path="/system/details/util/reboot/main.md",data={[1]={level=1,text="reboot",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Reboots Picotron",[3]="",[4]="Source: [source.lua](source.lua)"},children={}}}}}},[47]={name="main.md",path="/system/details/util/ps/main.md",data={[1]={level=1,text="ps",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Lists all active processes and details",[3]="",[4]="Identical to the about.p64 view of processes but a snapshot, rather than actively updating",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={[1]={level=3,text="Details shown",content={[1]=""},children={[1]={level=4,text="pid",content={[1]="",[2]="PID of the process",[3]=""},children={}},[2]={level=4,text="name",content={[1]="",[2]="Name of the process",[3]=""},children={}},[3]={level=4,text="cpu",content={[1]="",[2]="CPU usage of the process (in decimal, rather than percentage)",[3]=""},children={}},[4]={level=4,text="pri",content={[1]="",[2]="Priority of the process",[3]=""},children={}},[5]={level=4,text="mem",content={[1]="",[2]="Memory usage of the process in Kilobytes",[3]=""},children={}}}}}}}}}},[48]={name="main.md",path="/system/details/util/open/main.md",data={[1]={level=1,text="open path",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Identical to `edit`",[3]="",[4]="Open the file specified",[5]="",[6]="Fails if there is no default program to open it",[7]="",[8]="Source: [source.lua](source.lua)",[9]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="path",content={[1]="",[2]="Path to the file you want to open"},children={}}}}}}}},[49]={name="main.md",path="/system/details/util/mkdir/main.md",data={[1]={level=1,text="mkdir path",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Creates a folder in `path`",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="path",content={[1]="",[2]="Relative location you want to create a path in",[3]="",[4]="Relative to the current working directory",[5]=""},children={}}}}}}}},[50]={name="main.md",path="/system/details/util/mount/main.md",data={[1]={level=1,text="mount target origin",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Mounts folder at `origin` to `target`",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="target",content={[1]="",[2]="Mounting point of `origin`",[3]=""},children={}},[2]={level=3,text="origin",content={[1]="",[2]="Folder to mount at `target`"},children={}}}}}}}},[51]={name="main.md",path="/system/details/util/pwc/main.md",data={[1]={level=1,text="pwc",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Returns the current loaded cartridge",[3]="",[4]="Source: [source.lua](source.lua)"},children={}}}}}},[52]={name="main.md",path="/system/details/util/ls/main.md",data={[1]={level=1,text="ls [path]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Identical to `dir`",[3]="List all files in the directory",[4]="",[5]="Defaults to your current working path",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[path]",content={[1]="",[2]="Optional argument for the path you want to list files of, instead of your current working path"},children={}}}}}}}},[53]={name="main.md",path="/system/details/util/load/main.md",data={[1]={level=1,text="load [options] path",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Loads `path` as a cartridge",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[options]",content={[1]=""},children={[1]={level=4,text="`-b`",content={[1]="",[2]="Open files from the workspace in the background, rather than stealing the focus of the current window",[3]=""},children={}}}},[2]={level=3,text="path",content={[1]="",[2]="The path, folder or file, to a cartridge",[3]="",[4]="Append with `bbs://` protocol or `#` to load a cartridge from the bbs"},children={}}}}}}}},[54]={name="main.md",path="/system/details/util/mv/main.md",data={[1]={level=1,text="mv [options] src dest",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Moves `src` to `dest`",[3]="",[4]="Use `mv --help` for the built in instructions",[5]="",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[options]",content={[1]="",[2]="Optional arguments for the command",[3]=""},children={}},[2]={level=3,text="`-f`",content={[1]="",[2]="overwrite `dest` instead of placing it inside of `dest`",[3]=""},children={}},[3]={level=3,text="`-n`",content={[1]="no clobber, skips copying files if a file with the same name already exists in `dest`",[2]=""},children={}},[4]={level=3,text="src",content={[1]="",[2]="A folder or file to be moved",[3]=""},children={}},[5]={level=3,text="dest",content={[1]="",[2]="Location of the file to be moved to"},children={}}}}}}}},[55]={name="main.md",path="/system/details/util/kill/main.md",data={[1]={level=1,text="kill pid",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Kills (shuts down) the process with the pid `pid`",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="pid",content={[1]="",[2]="The process id of the process you want to kill"},children={}}}}}}}},[56]={name="main.md",path="/system/details/util/info/main.md",data={[1]={level=1,text="info",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Displays information about the current loaded cartridge",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={[1]={level=3,text="Information displayed",content={[1]="",[2]="Path to the cartridge on disk",[3]="",[4]="Compressed ROM size & compression percentage",[5]="",[6]="Whether there are unsaved changes",[7]="",[8]="Shows if there are external changes"},children={}}}}}}}},[57]={name="main.md",path="/system/details/util/folder/main.md",data={[1]={level=1,text="folder [path]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Opens the current working folder or `[path]` in the host OS.",[3]="",[4]="You cannot open the `/ram/` folder or any `/ram/` subfolders.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[path]",content={[1]="",[2]="Lets you define the folder to open"},children={}}}}}}}},[58]={name="main.md",path="/system/details/util/edit/main.md",data={[1]={level=1,text="edit path",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Edit the file specified",[3]="",[4]="Fails if there is no default program to edit it",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="path",content={[1]="",[2]="Path to the file you want to edit"},children={}}}}}}}},[59]={name="main.md",path="/system/details/util/dir/main.md",data={[1]={level=1,text="dir [path]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Identical to `ls`",[3]="List all files in the directory",[4]="",[5]="Defaults to your current working path",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[path]",content={[1]="",[2]="Optional argument for the path you want to list files of, instead of your current working path"},children={}}}}}}}},[60]={name="main.md",path="/system/details/util/default_app/main.md",data={[1]={level=1,text="default_app",content={[1]=""},children={[1]={level=2,text="Setting extensions `default_app ext [path_to_program]`",content={[1]="",[2]="Sets the default programs for extensions, edits `\"/appdata/system/default_apps.pod\"`",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={[1]={level=3,text="Arguments",content={[1]=""},children={[1]={level=4,text="ext",content={[1]="",[2]="The extension you would like to set the default app for, e.g: `lua`",[3]=""},children={}},[2]={level=4,text="[path_to_program]",content={[1]="",[2]="The path to the program that should handle your file.",[3]="",[4]="Leave blank to remove the default app for the extension",[5]=""},children={}}}}}},[2]={level=2,text="List current extensions `default_app -l`",content={[1]="",[2]="Lists all current default extensions you have set"},children={}}}}}},[61]={name="main.md",path="/system/details/util/config/main.md",data={[1]={level=1,text="config [key] [value]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`config` allows you to edit picotrons system settings (`/appdata/system/settings.pod`)",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]="",[2]="See [/environment/settings/readme.md] for arguments, these both are equal, simply being a [key]=[value] for `/appdata/system/settings.pod`"},children={}}}}}},[62]={name="main.md",path="/picotron_api/userdata/methods/width/main.md",data={[1]={level=1,text="userdata:width(): width",content={},children={[1]={level=2,text="Overview",content={[1]="Gets the width of the userdata.",[2]=""},children={}},[2]={level=2,text="Returns",content={},children={[1]={level=3,text="`width`: integer",content={[1]="The number of columns in the userdata.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="-- Be careful when reading the height of a userdata. It can be nil.",[3]="local h = ud:height()",[4]="",[5]="if h then",[6]="	for y = 0, h - 1 do",[7]="		for x = 0, ud:width() - 1 do",[8]="			?ud:get(x, y)",[9]="		end",[10]="	end",[11]="else",[12]="	for x = 0, ud:width() - 1 do",[13]="		?ud:get(x)",[14]="	end",[15]="end",[16]="```"},children={}}}}}},[63]={name="main.md",path="/picotron_api/userdata/methods/height/main.md",data={[1]={level=1,text="userdata:height(): height",content={},children={[1]={level=2,text="Overview",content={[1]="Gets the height of the userdata.",[2]=""},children={}},[2]={level=2,text="Returns",content={},children={[1]={level=3,text="`height`: integer|nil",content={[1]="The number of rows in the userdata if the userdata is 2D, or nil if the userdata is 1D.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="-- Be careful when reading the height of a userdata. It can be nil.",[3]="local h = ud:height()",[4]="",[5]="if h then",[6]="	for y = 0, h - 1 do",[7]="		for x = 0, ud:width() - 1 do",[8]="			?ud:get(x, y)",[9]="		end",[10]="	end",[11]="else",[12]="	for x = 0, ud:width() - 1 do",[13]="		?ud:get(x)",[14]="	end",[15]="end",[16]="```"},children={}}}}}},[64]={name="main.md",path="/system/details/util/export/main.md",data={[1]={level=1,text="export [outfile]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Exports the loaded cartridge (`/ram/cart`)",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="outfile",content={[1]="",[2]="File location to export",[3]="",[4]="Supported filetypes to export to:",[5]=""},children={[1]={level=4,text="`.p64.png`",content={[1]="",[2]="BBS Format for cartridges",[3]=""},children={}},[2]={level=4,text="`.html`",content={[1]="",[2]="One-file web export",[3]=""},children={}},[3]={level=4,text="`.bin`",content={[1]="",[2]="Binary exports for windows, linux and mac",[3]=""},children={}}}}}},[3]={level=2,text="Future",content={[1]="",[2]="Ability to export from any path, rather than `/ram/cart`"},children={}}}}}},[65]={name="main.md",path="/system/details/util/cp/main.md",data={[1]={level=1,text="cp [options] src dest",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`cp` lets you copy a file (`src`) to a folder (`dest`)",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[options]",content={[1]="",[2]="Optional arguments for the command",[3]=""},children={}},[2]={level=3,text="`-f`",content={[1]="",[2]="overwrite `dest` instead of placing it inside of `dest`",[3]=""},children={}},[3]={level=3,text="`-n`",content={[1]="no clobber, skips copying files if a file with the same name already exists in `dest`",[2]=""},children={}}}},[3]={level=2,text="src",content={[1]="",[2]="The path to the source file/folder",[3]=""},children={}},[4]={level=2,text="dest",content={[1]="",[2]="Path to a folder/file to replace",[3]="",[4]="Overwrites the folder with option `-f`",[5]=""},children={}},[5]={level=2,text="Future",content={[1]="Taken from comments in zep's code",[2]=""},children={}},[6]={level=2,text="[options]",content={[1]=""},children={[1]={level=3,text="`-r`",content={[1]="",[2]="Recursive copy",[3]="",[4]="Unsure of how to handle overwriting files."},children={}}}}}}}},[66]={name="readme.md",path="/picotron_api/readme.md",data={[1]={level=1,text="Picotron API",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on all of the Picotron API",[3]="",[4]="[Functions](functions/readme.md)",[5]="[GUI](gui/readme.md)",[6]="[Userdata](userdata/readme.md)",[7]="[Program Structure](program_structure/main.md)",[8]="[Picotron Lua](picotron_lua/main.md)",[9]="[Map](map/main.md)"},children={}}}}}},[67]={name="main.md",path="/picotron_api/userdata/methods/row/main.md",data={[1]={level=1,text="userdata:row(row_i): row_ud",content={},children={[1]={level=2,text="Overview",content={[1]="Creates a new 2D userdata containing a single row from the given userdata.",[2]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`row_i`: integer",content={[1]="The index of the row to fetch.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`row_ud`: userdata",content={[1]="A 2D userdata with a height of 1 and the width and type of the original userdata.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="-- 01 02",[3]="-- 03 04",[4]="-- 05 06",[5]="local ud = userdata(\"u8\", 2, 3, \"010203040506\")",[6]="local ud_w, ud_h, ud_t = ud:attribs()",[7]="",[8]="local row = ud:row(1)",[9]="local row_w, row_h, row_t = row:attribs()",[10]="",[11]="assert(row_h == 1)",[12]="assert(row_w == ud_w)",[13]="assert(row_t == ud_t)",[14]="",[15]="assert(row[0] == 3)",[16]="assert(row[1] == 4)",[17]="```"},children={}}}}}},[68]={name="main.md",path="/picotron_api/userdata/methods/attribs/main.md",data={[1]={level=1,text="userdata:attribs(): width, height, type",content={},children={[1]={level=2,text="Overview",content={[1]="Gets the width, height, and type of the userdata.",[2]=""},children={}},[2]={level=2,text="Returns",content={},children={[1]={level=3,text="`width`: integer",content={[1]="The number of columns in the userdata.",[2]=""},children={}},[2]={level=3,text="`height`: integer",content={[1]="The number of rows in the userdata. Unlike the [`height`](/picotron_api/userdata/methods/height/main.md) method, 1D userdatas will return 1 for this value.",[2]=""},children={}},[3]={level=3,text="`type`: \"u8\"|\"i16\"|\"i32\"|\"i64\"|\"f64\"",content={[1]="The type that the userdata contains as its string name.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="local function clone_empty(ud)",[3]="	local width, height, ud_type = ud:attribs()",[4]="	return userdata(ud_type, width, height)",[5]="end",[6]="```"},children={}}}}}},[69]={name="documenting.md",path="/documenting.md",data={[1]={level=1,text="Documenting the Picotron Wiki",content={[1]=""},children={[1]={level=2,text="Current Process",content={[1]="",[2]="If you would like to add documentation to the Picotron Wiki, please:",[3]="* create a pull request",[4]="* contact me through `@astralsparv` on discord.",[5]="* make a post on the [lexaloffle BBS post](https://www.lexaloffle.com/bbs/?pid=143916)",[6]=""},children={}},[2]={level=2,text="How to format pages",content={[1]="",[2]="main.md pages (e.g: functions, methods) are formatted as such:",[3]="",[4]="For each overload of a function or method, a heading describes the signature.",[5]="",[6]="```md"},children={}}}},[2]={level=1,text="function:(args, [optional_args]): returned_a, returned_b",content={[1]="```",[2]="",[3]="For methods, the type they belong to should be included on the left as though that method were being invoked, separated from the function name with a colon.",[4]="```md"},children={}},[3]={level=1,text="class:method(args, [optional_args]): returned_a, returned_b",content={[1]="```",[2]="",[3]="Arguments and return values in the signature are just descriptive labels without specified types. For arguments which are optional, they must surrounded with [brackets].",[4]="",[5]="Below the signature, a general description of what the function does and what it's used for appears under a subheading labeled \"Overview\".",[6]="",[7]="```md"},children={[1]={level=2,text="Overview",content={[1]="Does x for y. Useful for cases of z. Only works when w.",[2]="```",[3]="",[4]="After the overview, if the function has arguments, each will be listed in the order they appear in the signature under a subheading labeled \"Arguments\".",[5]="",[6]="Each argument's label should be wrapped in as code using back ticks. The types should link to the relevant document page if it's part of Picotron's API.",[7]="",[8]="If an argument can take different types, each possible type should be listed in that argument definition, with pipes (|) separating them. Below the argument should be a description of what it's used for and how it works.",[9]="",[10]="",[11]="```md"},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`argument1`: [userdata](picotron_api/userdata/readme.md)|integer",content={[1]="Used to determine x. If the type is an integer, y will happen.",[2]=""},children={}},[2]={level=3,text="`argument2`: string",content={[1]="The string used to do z.",[2]="```",[3]="",[4]="After the arguments, if the function has return values, each will be listed in the order they appear in the signature under a subheading labeled \"Returns\", using the same structuring rules as the arguments.",[5]="",[6]="```md"},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`return_value`: thread|nil",content={[1]="The thread created by x. Will return nil if y condition is not met.",[2]="```",[3]="",[4]="At the end of the definition of the function, one or more examples may be added to demonstrate how the function is used.",[5]="",[6]="````md"},children={}}}},[4]={level=2,text="Examples",content={[1]="Prints the string \"apple sauce\"",[2]="```",[3]="print(\"apple sauce\")",[4]="```",[5]="````",[6]="",[7]="If there's another overload for the function or method, it can go after each of these subheading as another heading.",[8]=""},children={}},[5]={level=2,text="Updating the search engine DB",content={[1]="",[2]="Open the [ripper](https://astralsparv.github.io/Picotron-Wiki/ripper/) page & simply drag and drop the Picotron-Wiki folder.",[3]="",[4]="Select `rip` to rip the docs in the JSON format.",[5]="",[6]="Select `pod` to rip the docs in the POD format.",[7]="",[8]="Replace the old db files with these files in `/docs/db/`.",[9]="",[10]="This should be in the structure of`/docs/db/..`:",[11]="* `..db.json`",[12]="* `..db.pod`",[13]="* `..minidb.pod`"},children={}}}}}},[70]={name="main.md",path="/system/persistence/main.md",data={[1]={level=1,text="Persistence",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="How System persistence works.",[3]="",[4]="System persistence allows or you to customise the `/system` folder in Picotron (the system files of it)",[5]=""},children={}},[2]={level=2,text="Persisting Picotron",content={[1]="You can do this easily by opening the Picotron Terminal and typing",[2]="```lua",[3]="cp(\"/system\",\"/system.\")",[4]="```",[5]="",[6]="This creates a clone of your picotron system that is editable by the Host Operating System - this causes all changes to `/system` to be **permenant** from both edits within and outside of Picotron.",[7]=""},children={}},[3]={level=2,text="Use cases",content={[1]="",[2]="You could use this for editing system files such as the default software used, e.g: using a different filenav or code editor by default.",[3]="",[4]="This is used within the [Picotron Distribution System](https://github.com/Astralsparv/Distribution_Manager.p64/blob/main/distribution_manager.p64) to allow custom operating systems.",[5]=""},children={}},[4]={level=2,text="v0.2.2 (unreleased)",content={[1]="",[2]="Going by communications with Zep, `/system` persistence is going to be supported more, allowing for you to have passthrough files rather than cloning the entire `/system` drive to change something.",[3]="",[4]="This allows for stuff like distributions to not affect the licensing of `/system`.",[5]="",[6]="This works by:",[7]="",[8]="Picotron's `/system` being defaulted to the system rom (stored within the Picotron runtime).",[9]="",[10]="*If* the folder `/picotron/drive/system` exists, it will overwrite any files that exist in `/picotron/drive/system` into Picotron's loaded `/system`.",[11]="",[12]="This adds better support for updating Picotron with a persistent system as you can safely edit stuff like system apps without losing any updates to other things like libraries or the wm & pm.",[13]=""},children={[1]={level=3,text="Example",content={[1]="",[2]="Within `/picotron/drive/system`, you have the folder `/apps/` which contains `filenav.p64`, this is a custom filenav for Picotron - rather than the built in filenav.",[3]="",[4]="When opening Picotron, everything will be loaded as if that doesn't exist and the `filenav.p64` will then overwrite `/system/apps/filenav.p64` in Picotron.",[5]="",[6]="This happens *before* the boot sequence (running `boot.lua`) so that your system can be fully edited."},children={}}}}}}}},[71]={name="README.md",path="/README.md",data={[1]={level=1,text="Picotron Wiki",content={[1]=""},children={[1]={level=2,text="Wiki Information",content={[1]="",[2]="Documentation of [Picotron](https://www.lexaloffle.com/picotron.php).",[3]="",[4]="The official Picotron Wiki cart has been released on the [bbs](https://www.lexaloffle.com/bbs/?tid=154532) under the bbs id `#wiki`, more info can be found [here](cart.md)",[5]="Information on contribution to documentation is [here](documenting.md)",[6]=""},children={}},[2]={level=2,text="Search Engine",content={[1]="",[2]="There is a search engine for the Picotron Wiki.",[3]="It can be found [here](https://astralsparv.github.io/Picotron-Wiki/)",[4]=""},children={}},[3]={level=2,text="Picotron Information",content={[1]="",[2]="Information on Picotron can be found [here](information/whatis.md)",[3]=""},children={}},[4]={level=2,text="System documentation",content={[1]="",[2]="System documentation can be found [here](system/readme.md)",[3]="",[4]="Documenting every section of `/system`",[5]=""},children={}},[5]={level=2,text="Picotron API",content={[1]="",[2]="Documentation on the Picotron API can be found [here](picotron_api/readme.md)",[3]=""},children={}},[6]={level=2,text="Environment",content={[1]="",[2]="Documentation on the ecosystem/environment of Picotron can be found [here](environment/readme.md)",[3]=""},children={}},[7]={level=2,text="Guides",content={[1]="",[2]="Guides for Picotron can be found [here](guides/readme.md)",[3]=""},children={}},[8]={level=2,text="Contributors",content={[1]="",[2]="@Podepi - GUIs",[3]="",[4]="[@KeyboardDanni](https://github.com/KeyboardDanni) - GUI overview",[5]="",[6]="[@abledbody](https://github.com/abledbody) - Userdata",[7]="",[8]="[@akd-io](https://github.com/akd-io) - stat documentation support",[9]="",[10]="[@Maxine](https://github.com/MaxTheMooshroom) - stat documentation support",[11]="",[12]="@bloodninja - 720p upscaler documentation",[13]="",[14]="@Astralsparv - creator/writing up of lots of general things"},children={}}}}}},[72]={name="main.md",path="/system/details/util/rm/main.md",data={[1]={level=1,text="rm filename",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`rm` deletes a file or directory (including all of the directory's contents).",[3]="",[4]="Attempting to delete `/desktop/host` just causes the Host OS to unmount, rather than deleting the folder and contents.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="filename",content={[1]="",[2]="The file or folder to delete",[3]=""},children={}},[3]={level=2,text="Possible Future",content={[1]="",[2]="Taken from comments in zep's code",[3]="Could be incorrect as zep copy pasted from `cp` command, but didn't rectify the name",[4]="",[5]="```",[6]="--[[",[7]="	cp src dest",[8]="",[9]="	resulting file should be idential to src (can't just fetch and then store)",[10]="",[11]="	to do:",[12]="		-r recursive // rm() is currently recursive by default though",[13]="		how to do interactive copying? (prompt for overwrite)",[14]="]]",[15]="```",[16]=""},children={}},[4]={level=2,text="[options]",content={[1]=""},children={[1]={level=3,text="`-r`",content={[1]="",[2]="Recursive remove",[3]="",[4]="Unsure of how to handle overwriting files."},children={}}}}}}}},[73]={name="main.md",path="/system/details/util/save/main.md",data={[1]={level=1,text="save [path]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Runs the current loaded cartridge (`/ram/cart/`), optionally to a new location `[path]`",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[path]",content={[1]="",[2]="Optional location to save to, automatically appends .p64 if there is no extension",[3]=""},children={}}}},[3]={level=2,text="Future",content={[1]="",[2]="Taken from comments in zep's code",[3]=""},children={[1]={level=3,text="Saving as a folder",content={[1]="",[2]="`-- add extension when none is given (to do: how to save to a regular folder with no extension in name? maybe just don't do that?)`",[3]="",[4]="Possibly making it possible to save a cartridge to a folder, rather than a .p64 file, so that the host OS can open the p64.",[5]="",[6]="> This can be done by creating a folder named `cartridge.p64` in the host os in the meantime."},children={}}}}}}}},[74]={name="main.md",path="/system/details/util/help/main.md",data={[1]={level=1,text="folder [path]",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Prints helpful cheatsheet for Picotron",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Output",content={[1]="",[2]="    - Picotron Cheatsheet",[3]="        ",[4]="        ls (or dir)       \\\"fd list files in the current folder\\\"",[5]="        cd <directory>    \\\"fd change directory (folder)\\\"",[6]="        mkdir <directory> \\\"fd create a directory\\\"",[7]="        load <filename>   \\\"fd load a cartridge (.p64) into /ram/cart\\\"",[8]="        save <filename>   \\\"fd save /ram/cart back to a .p64 file\\\"",[9]="        reset             \\\"fd reset draw state\\\"",[10]="        ",[11]="        CTRL-R            \\\"fd run the loaded cartridge\\\"",[12]="        ESC               \\\"fd stop program or toggle between editor and output\\\"",[13]="        CTRL-L            \\\"fd clear the terminal\\\"",[14]="        ",[15]="        To try out a demo:",[16]="        $ cd /system/demos\\\"",[17]="        $ load highway\\\"",[18]="",[19]="        .. and then CTRL-R to run it\\\""},children={}}}}}},[75]={name="main.md",path="/picotron_api/userdata/methods/transpose/main.md",data={[1]={level=1,text="userdata:transpose(): ud",content={},children={[1]={level=2,text="Overview",content={[1]="Swaps the `x` and `y` indices of all the values in the userdata, as well as the width and height of the userdata. This is equivalent to mirroring the userdata along the diagonal that starts from the low indices.",[2]=""},children={}},[2]={level=2,text="Returns",content={},children={[1]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The transposed userdata. Always 2D, regardless of if the original userdata was 2D or not.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="local ud_in = userdata(\"u8\", 2, 3)",[3]="ud_in:set(0, 0,",[4]="	1, 2,",[5]="	3, 4,",[6]="	5, 6",[7]=")",[8]="",[9]="-- Transposing the userdata will reorganize it like this:",[10]="-- 1, 3, 5",[11]="-- 2, 4, 6",[12]="local ud_out = ud_in:transpose()",[13]="",[14]="assert(ud_in:get(0, 0) == ud_out:get(0, 0))",[15]="assert(ud_in:get(1, 0) == ud_out:get(0, 1))",[16]="assert(ud_in:get(0, 1) == ud_out:get(1, 0))",[17]="assert(ud_in:get(1, 1) == ud_out:get(1, 1))",[18]="assert(ud_in:get(0, 2) == ud_out:get(2, 0))",[19]="assert(ud_in:get(1, 2) == ud_out:get(2, 1))",[20]="```"},children={}}}}}},[76]={name="readme.md",path="/picotron_api/userdata/methods/readme.md",data={[1]={level=1,text="Picotron API > userdata > methods",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on userdata methods for Picotron",[3]=""},children={[1]={level=3,text="Accessors",content={[1]="- [get()](get/main.md)",[2]="- [set()](set/main.md)",[3]="- [row()](row/main.md)",[4]="- [column()](column/main.md)",[5]=""},children={}},[2]={level=3,text="Properties",content={[1]="- [width()](width/main.md)",[2]="- [height()](height/main.md)",[3]="- [attribs()](attribs/main.md)",[4]=""},children={}},[3]={level=3,text="Arithmetic",content={[1]="- [add()](add/main.md)",[2]="- [sub()](sub/main.md)",[3]="- [mul()](mul/main.md)",[4]="- [div()](div/main.md)",[5]="- [idiv()](idiv/main.md)",[6]="- [mod()](mod/main.md)",[7]="- [pow()](pow/main.md)",[8]=""},children={}},[4]={level=3,text="Bitwise",content={[1]="- [band()](band/main.md)",[2]="- [bor()](bor/main.md)",[3]="- [bxor()](bxor/main.md)",[4]="- [shl()](shl/main.md)",[5]="- [shr()](shr/main.md)",[6]=""},children={}},[5]={level=3,text="Piecewise",content={[1]="- [min()](min/main.md)",[2]="- [max()](max/main.md)",[3]="- [abs()](abs/main.md)",[4]="- [sgn()](sgn/main.md)",[5]="- [sgn0()](sgn0/main.md)",[6]=""},children={}},[6]={level=3,text="Linear algebra",content={[1]="- [magnitude()](magnitude/main.md)",[2]="- [distance()](distance/main.md)",[3]="- [dot()](dot/main.md)",[4]="- [cross()](cross/main.md)",[5]="- [transpose()](transpose/main.md)",[6]="- [matmul()](matmul/main.md)",[7]="- [matmul2d()](matmul2d/main.md)",[8]="- [matmul3d()](matmul3d/main.md)",[9]=""},children={}},[7]={level=3,text="Data manipulation",content={[1]="- [copy()](copy/main.md)",[2]="- [take()](take/main.md)",[3]="- [clear()](clear/main.md)",[4]="- [convert()](convert/main.md)",[5]="- [mutate()](mutate/main.md)",[6]="- [sort()](sort/main.md)",[7]="- [lerp()](lerp/main.md)",[8]="- [blit()](blit/main.md)",[9]=""},children={}},[8]={level=3,text="Memory",content={[1]="- [peek()](peek/main.md)",[2]="- [poke()](poke/main.md)",[3]=""},children={}},[9]={level=3,text="Hashing",content={[1]="- [crc()](crc/main.md)"},children={}}}}}}}},[77]={name="main.md",path="/picotron_api/userdata/methods/sub/main.md",data={[1]={level=1,text="sub(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Subtracts elements on the right hand side from elements on the left hand side.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the subtraction operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the subtraction operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[78]={name="main.md",path="/picotron_api/userdata/methods/shr/main.md",data={[1]={level=1,text="shr(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Bitshifts elements in the left hand side to the right by elements in the right hand side.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the bitshift right operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the bitshift right operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[79]={name="main.md",path="/picotron_api/userdata/methods/sgn0/main.md",data={[1]={level=1,text="sgn0([lhs], [rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the sign of elements in a userdata, producing -1 for values less than 0, 1 for values greater than 0, and leaving values of 0 untouched.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`[lhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The userdata used as the input for the sign operations.",[2]=""},children={}},[2]={level=3,text="`[rhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="Alternative source userdata. Only used if `lhs` is not a userdata.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[80]={name="main.md",path="/picotron_api/userdata/methods/pow/main.md",data={[1]={level=1,text="pow(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Raises elements on the left hand side to the power of elements on the right hand side.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the exponentiation operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the exponentiation operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[81]={name="main.md",path="/picotron_api/userdata/methods/mod/main.md",data={[1]={level=1,text="mod(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Calculates the modulo of the elements on the left hand side by elements on the right hand side.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the modulo operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the modulo operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[82]={name="main.md",path="/picotron_api/userdata/methods/mul/main.md",data={[1]={level=1,text="mul(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Multiplies elements on the left and right hand sides.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the multiplication operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the multiplication operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[83]={name="main.md",path="/picotron_api/userdata/methods/column/main.md",data={[1]={level=1,text="userdata:column(column_i): column_ud",content={},children={[1]={level=2,text="Overview",content={[1]="Creates a new 2D userdata containing a single column from the given userdata.",[2]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`column_i`: integer",content={[1]="The index of the column to fetch.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`column_ud`: userdata",content={[1]="A 2D userdata with a width of 1 and the height and type of the original userdata.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="-- 01 02 03",[3]="-- 04 05 06",[4]="local ud = userdata(\"u8\", 3, 2, \"010203040506\")",[5]="local ud_w, ud_h, ud_t = ud:attribs()",[6]="",[7]="local column = ud:column(1)",[8]="local column_w, column_h, column_t = column:attribs()",[9]="",[10]="assert(column_h == ud_h)",[11]="assert(column_w == 1)",[12]="assert(column_t == ud_t)",[13]="",[14]="assert(column[0] == 2)",[15]="assert(column[1] == 5)",[16]="```"},children={}}}}}},[84]={name="main.md",path="/picotron_api/userdata/methods/idiv/main.md",data={[1]={level=1,text="idiv(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Divides elements on the left hand side by elements on the right hand side, and floors the result to an integer.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the integer division operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the integer division operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[85]={name="main.md",path="/picotron_api/userdata/methods/get/main.md",data={[1]={level=1,text="userdata:get(): ...",content={},children={[1]={level=2,text="Overview",content={[1]="Returns every value in the userdata as arguments in flat index order.",[2]=""},children={}},[2]={level=2,text="Returns",content={},children={[1]={level=3,text="`...`: number",content={[1]="Every number in the userdata.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="local tab = {ud:get()} --Copies the values in the userdata into the table tab",[3]="assert(ud[0] == tab[1])",[4]="assert(ud[1] == tab[2])",[5]="-- And so on.",[6]="```",[7]=""},children={}}}},[2]={level=1,text="userdata:get(i, [count]): ...",content={},children={[1]={level=2,text="Overview",content={[1]="For 1D userdatas, returns `count` sequential numbers from the userdata starting at the index `i`. If the starting index is outside the indexable range, will return 0.0.",[2]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`i`: number",content={[1]="The index to start fetching values from. Will be floored.",[2]=""},children={}},[2]={level=3,text="`[count]`: number",content={[1]="The number of values to fetch and return. Will be floored. If the number of values exceeds what is possible to retrieve from the userdata, only the ones that are retreivable are returned. Values less than 0 are undefined behavior, and are known to cause crashes. Defaults to 1.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`...`: number",content={[1]="Each of the requested numbers, or 0.0 if the starting index is out of range.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="local ud = vec(3, 6, 12, 24)",[3]="ud:get(1, 3) -- 6, 12, 24",[4]="```",[5]=""},children={}}}},[3]={level=1,text="userdata:get(column, [row], [count]): ...",content={},children={[1]={level=2,text="Overview",content={[1]="For 2D userdatas, returns `count` sequential numbers from the userdata starting at a specific column and row, enumerating in flat index order. If the starting index is outside the indexable range, will return 0.0.",[2]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`column`: number",content={[1]="The horizontal index to start fetching values from. Will be floored.",[2]=""},children={}},[2]={level=3,text="`[row]`: number",content={[1]="The vertical index to start fetching values from. Will be floored. Defaults to 0.",[2]=""},children={}},[3]={level=3,text="`[count]`: number",content={[1]="The number of values to fetch and return. Will be floored. If the number of values exceeds what is possible to retrieve from the userdata, only the ones that are retreivable are returned. Values less than 0 are undefined behavior, and are known to cause crashes. Defaults to 1.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`...`: number",content={[1]="Each of the requested numbers, or 0.0 if the starting index is out of range.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="local ud = userdata(\"f64\", 2, 3, \"0,10,20,30,40,50\")",[3]="ud:get(0, 1, 3) -- 20, 30, 40",[4]="```"},children={}}}}}},[86]={name="main.md",path="/picotron_api/userdata/methods/div/main.md",data={[1]={level=1,text="div(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Divides elements on the left hand side by elements on the right hand side.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the division operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the division operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[87]={name="main.md",path="/picotron_api/userdata/methods/max/main.md",data={[1]={level=1,text="max(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the largest values between elements on the left and right hand sides.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the max operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the max operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[88]={name="main.md",path="/picotron_api/userdata/methods/sgn/main.md",data={[1]={level=1,text="sgn([lhs], [rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the sign of elements in a userdata, producing -1 for values less than 0, and 1 for values 0 or greater.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`[lhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The userdata used as the input for the sign operations.",[2]=""},children={}},[2]={level=3,text="`[rhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="Alternative source userdata. Only used if `lhs` is not a userdata.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[89]={name="main.md",path="/picotron_api/userdata/methods/set/main.md",data={[1]={level=1,text="userdata:set(i, ...)",content={},children={[1]={level=2,text="Overview",content={[1]="For 1D userdatas, sets one or more values in the userdata starting at index `i`. Will do nothing if the starting index is out of range.",[2]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`i`: number",content={[1]="The index to start setting values from. Will be floored.",[2]=""},children={}},[2]={level=3,text="`...`: number",content={[1]="Each of the arguments to set.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="local ud = userdata(\"f64\", 6)",[3]="ud:set(3, -1, -2, -3)",[4]="",[5]="?ud[0] -- 0",[6]="?ud[1] -- 0",[7]="?ud[2] -- 0",[8]="?ud[3] -- -1",[9]="?ud[4] -- -2",[10]="?ud[5] -- -3",[11]="```",[12]=""},children={}}}},[2]={level=1,text="userdata:set([column], [row], ...)",content={},children={[1]={level=2,text="Overview",content={[1]="For 2D userdatas, sets one or more values in the userdata starting at a specific column and row, enumerating in flat index order. Will do nothing if the starting index is out of range.",[2]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`[column]`: number",content={[1]="The horizontal index to start writing values to. Will be floored. Defaults to 0.",[2]=""},children={}},[2]={level=3,text="`[row]`: number",content={[1]="The vertical index to start writing values to. Will be floored. Defaults to 0.",[2]=""},children={}},[3]={level=3,text="`...`: number",content={[1]="Each of the arguments to set.",[2]=""},children={}}}},[3]={level=2,text="Example",content={[1]="```lua",[2]="local ud = userdata(\"f64\", 2, 3)",[3]="ud:set(0, 1, -12, -32, 10)",[4]="",[5]="?ud:get(0, 0) -- 0",[6]="?ud:get(1, 0) -- 0",[7]="?ud:get(0, 1) -- -12",[8]="?ud:get(1, 1) -- -32",[9]="?ud:get(0, 2) -- 10",[10]="?ud:get(1, 2) -- 0",[11]="```"},children={}}}}}},[90]={name="main.md",path="/picotron_api/userdata/methods/shl/main.md",data={[1]={level=1,text="shl(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Bitshifts elements in the left hand side to the left by elements in the right hand side.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the bitshift left operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the bitshift left operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[91]={name="main.md",path="/picotron_api/userdata/methods/min/main.md",data={[1]={level=1,text="min(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the smallest values between elements on the left and right hand sides.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the min operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the min operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[92]={name="main.md",path="/picotron_api/userdata/methods/bxor/main.md",data={[1]={level=1,text="bxor(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the bitwise XOR between elements on the left and right hand sides. Must be done on an integer typed userdata.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the bitwise XOR operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the bitwise XOR operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[93]={name="main.md",path="/picotron_api/userdata/methods/bor/main.md",data={[1]={level=1,text="bor(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the bitwise OR between elements on the left and right hand sides. Must be done on an integer typed userdata.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the bitwise OR operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the bitwise OR operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[94]={name="main.md",path="/picotron_api/userdata/methods/band/main.md",data={[1]={level=1,text="band(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the bitwise AND between elements on the left and right hand sides. Must be done on an integer typed userdata.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the bitwise AND operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the bitwise AND operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[95]={name="main.md",path="/picotron_api/userdata/methods/add/main.md",data={[1]={level=1,text="add(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Adds elements on the left and right hand sides.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The left hand side of the addition operation.",[2]=""},children={}},[2]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The right hand side of the addition operation.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[96]={name="main.md",path="/picotron_api/userdata/methods/abs/main.md",data={[1]={level=1,text="abs([lhs], [rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="Gets the absolute values (magnitude) of elements in a userdata.",[2]="",[3]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[4]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`[lhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="The userdata used as the input for the absolute operations.",[2]=""},children={}},[2]={level=3,text="`[rhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[1]="Alternative source userdata. Only used if `lhs` is not a userdata.",[2]=""},children={}},[3]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[1]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[2]="",[3]="|`dest`             |`lhs`       |`rhs`   |written to     |",[4]="|-------------------|------------|--------|---------------|",[5]="|userdata           |any         |any     |`dest`         |",[6]="|truthy non-userdata|userdata    |any     |`lhs`          |",[7]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[8]="|falsey             |userdata    |any     |a copy of `lhs`|",[9]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[10]=""},children={}},[4]={level=3,text="`[read_start]`: number",content={[1]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[5]={level=3,text="`[write_start]`: number",content={[1]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[2]=""},children={}},[6]={level=3,text="`[group_size]`: number",content={[1]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[2]=""},children={}},[7]={level=3,text="`[read_increment]`: number",content={[1]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[8]={level=3,text="`[write_increment]`: number",content={[1]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[2]=""},children={}},[9]={level=3,text="`[group_count]`: number",content={[1]="How many groups will be iterated over.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[1]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[97]={name="readme.md",path="/picotron_api/gui/readme.md",data={[1]={level=1,text="Picotron API > GUI",content={[1]="",[2]="Main contributions by `@Podepi`, `@KeyboardDanni`",[3]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Picotron includes a lightweight GUI framework that can be used in apps as well as games. Use of it is optional, and it's possible to make your own GUI system as well, but the built-in GUI can save you considerable development time on small to medium projects.",[3]="",[4]="Picotron's GUI library uses a tree of `GuiElement` tables, with a \"head\" (root) element at the top, and each element containing any number of child elements. If you've ever used other tree-based frameworks like Qt or Godot, this one operates on a similar principle.",[5]="",[6]="Every element has its own set of [Event Callbacks](event_callbacks/readme.md). In most cases, there will be at least a [draw()](event_callbacks/draw/main.md) callback, though there may also be an [update()](event_callbacks/update/main.md) callback, similar to how the `_update()` and `_draw()` callbacks work in Picotron programs. Mouse clicks on buttons are usually implemented using [tap()](event_callbacks/tap/main.md).",[7]=""},children={}},[2]={level=2,text="Creation",content={[1]="",[2]="To begin using the GUI, call `create_gui()` during initialization:",[3]="",[4]="```lua",[5]="local gui",[6]="",[7]="function _init()",[8]="	gui = create_gui()",[9]="end",[10]="```",[11]="",[12]="In order for the GUI to be functional, you will also need to call `gui:update_all()` and `gui:draw_all()` in the appropriate places:",[13]="",[14]="```lua",[15]="function _update()",[16]="	gui:update_all()",[17]="end",[18]="",[19]="function _draw()",[20]="    cls(13)",[21]="",[22]="	gui:draw_all()",[23]="end",[24]="```",[25]="",[26]="To add elements, call one of the [Attachment](attachments/readme.md) functions. For this example, we'll expand our `_init()` function to display our cart in a window and attach a button.",[27]="",[28]="```lua",[29]="function _init()",[30]="	window {",[31]="		title = \"My GUI Cart\",",[32]="		width = 150,",[33]="		height = 100",[34]="	}",[35]="",[36]="	gui = create_gui()",[37]="	",[38]="	gui:attach_button {",[39]="		x = 5,",[40]="		y = 5,",[41]="		label = \"Hello, Picotron!\",",[42]="		tap = function(self, msg)",[43]="			notify(\"Button pressed!\")",[44]="		end",[45]="	}",[46]="end",[47]="```",[48]="",[49]="The result should look like this:",[50]="",[51]="![A simple Picotron GUI cart](simple_window.png)",[52]="",[53]="Clicking the button will trigger a \"Button pressed!\" notification at the bottom of the screen.",[54]=""},children={}},[3]={level=2,text="Nested Elements",content={[1]="",[2]="We've seen that we can create and attach GUI elements by calling `gui:attach_button` and friends. But we can also nest elements to create more complex components. This is the key to reusability. Let's make a basic button box component that contains two buttons, \"Ok\" and \"Cancel\":",[3]="",[4]="```lua",[5]="local button_box = gui:attach {",[6]="    x = 5,",[7]="    y = 74,",[8]="    width = 140,",[9]="    height = 21,",[10]="    draw = function(self, msg)",[11]="        rrectfill(0, 0, self.width, self.height, 2, 18)",[12]="    end",[13]="}",[14]="",[15]="local button_ok = button_box:attach_button {",[16]="    x = 4,",[17]="    y = 4,",[18]="    width = 30,",[19]="    label = \"Ok\"",[20]="}",[21]="",[22]="button_box:attach_button {",[23]="    x = button_ok.width + 8,",[24]="    y = 4,",[25]="    label = \"Cancel\"",[26]="}",[27]="```",[28]="",[29]="The result:",[30]="",[31]="![A Picotron GUI cart with a button box to demonstrate nested elements](window_button_box.png)",[32]="",[33]="A few things are happening here. First, we are creating a \"container\" element for our button box and storing it in the `button_box` variable. This container has a `draw()` callback to illustrate its bounding box. Next, we use `button_box:attach_button` to attach the buttons to the `button_box` instead of `gui`.",[34]="",[35]="You might notice that `button_ok` has `x = 4, y = 4`, yet is located further down instead of at the top of the window. This is because coordinates are local to the parent element. This means we can reposition our `button_box` wherever we want and the buttons will move along with it.",[36]="",[37]="Keep in mind that by default, any child elements will be clipped to be within the parent's bounding box. So remember to set an appropriate `width` and `height` on the parent.",[38]=""},children={}},[4]={level=2,text="Tree Management",content={[1]="",[2]="Previously we've been adding elements to our interface by doing this:",[3]="",[4]="```lua",[5]="gui:attach {",[6]="    x = 5,",[7]="    y = 5,",[8]="    width = 20,",[9]="    height = 20",[10]="}",[11]="```",[12]="",[13]="However, this is actually performing two operations: creating the element, and then attaching it to the tree. The tree includes everything that is currently considered \"part of\" the user interface. However, it is possible to hold onto an element outside the tree. Such elements do not run their `update()` or `draw()` callbacks until they are attached to the tree.",[14]="",[15]="It is possible to create an unattached element using `gui:new()`. You can then later attach it using `gui:attach()`. The GUI system will recognize that it is already a `GuiElement` and avoid creating a new element:",[16]="",[17]="```lua",[18]="local element = gui:new {",[19]="    x = 5,",[20]="    y = 50,",[21]="    width = 100,",[22]="    height = 20,",[23]="    draw = function(self, msg)",[24]="        print(\"I'm in the tree!\", 0, 0, 1)",[25]="    end",[26]="}",[27]="",[28]="gui:attach(element)",[29]="```",[30]="",[31]="![The GUI cart with the attached element](window_attach.png)",[32]="",[33]="It is possible to remove an element from the tree by detaching it:",[34]="",[35]="```lua",[36]="element:detach()",[37]="```",[38]="",[39]="![The GUI cart with the previously attached element detached](window_button_box.png)",[40]="",[41]="The element may now be garbage-collected, assuming it doesn't have any other references pointing to it. Or, you may reattach the previously detached element at a later time.",[42]="",[43]="Every attached GUI element has variables that allow tree traversal: `head`, `parent`, and `child`.",[44]="",[45]="`head` is simply a reference to the root element, which is created via `create_gui()`. In our program, this is the `gui` variable. This is mainly so you don't have to make `gui` accessible to the entire program.",[46]="",[47]="`parent` allows accessing the element's parent. For example, we could add this callback to our \"Ok\" button:",[48]="",[49]="```lua",[50]="tap = function(self, msg)",[51]="    notify(self.parent.width)",[52]="end",[53]="```",[54]="",[55]="Clicking the button will now display `140`, the width of our button box.",[56]="",[57]="`child` is an array table containing every element nested under the current element. For example, you can remove the contents of `element` (but keep `element` itself) with the following:",[58]="",[59]="```lua",[60]="for i = #element.child, 1, -1 do",[61]="    element.child[i]:detach()",[62]="end",[63]="```",[64]="",[65]="Be careful when debugging GUI elements, as the `parent`/`head` references can cause nested iteration to recurse infinitely and crash Picotron.",[66]=""},children={}},[5]={level=2,text="Performance",content={[1]="",[2]="Every frame, the GUI system will recompute the bounds of all the elements in the tree and run their `update()` and `draw()` callbacks. This means that the more elements you have in your tree, the more CPU time is needed. If your UI is split between several pages, consider attaching and detaching them as needed instead of keeping everything attached at once. If you have a large scrolling item list with hundreds of items or more, create only the items that will be in-view, and add/remove items as necessary as the list scrolls.",[3]="",[4]="If you are making a desktop cart that doesn't need to animate while idle, consider only running your drawing code once every 5 frames or so, or when there is an animation update. To keep your UI responsive, you may want to mark it \"dirty\" when interacting with the window so that changes become visible on the same frame instead of several frames later.",[5]="",[6]="Try to limit the use of `update()` callback processing in elements. Where possible, stick to interaction-based event callbacks like `tap()`. And of course, remember to cache the results of expensive calculations such as word-wrapping.",[7]=""},children={}},[6]={level=2,text="References",content={[1]="[Event Callbacks](event_callbacks/readme.md)",[2]="",[3]="[Attachments](attachments/readme.md)",[4]="",[5]="[Attributes](attributes/readme.md)"},children={}}}}}},[98]={name="readme.md",path="/picotron_api/userdata/readme.md",data={[1]={level=1,text="Picotron API > userdata",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="A userdata is a specialized array type that contains numeric values, and is optimized for bulk operations. Because of this, they are an essential tool for optimizing code in Picotron.",[2]="",[3]="Userdatas are especially useful for representing large amounts of numerical data in a manner that's easy to manipulate and copy. They are also a pragmatic way to do operations based in linear algebra, and have a dedicated set of vector/matrix-specific methods, such as [`magnitude()`](methods/magnitude/main.md), [`cross()`](methods/cross/main.md) and [`matmul()`](methods/matmul/main.md).",[4]="",[5]="Userdatas are a reference type. You can have multiple variables pointing to the same userdata. Many of userdata's methods and operators create and return new userdatas by default, rather than mutating the existing userdata, but unlike a string, they are still mutable by certain operations. You can create a new copy of a userdata by calling its [`copy()`](methods/copy/main.md) method with no arguments.",[6]=""},children={}},[2]={level=2,text="Creation",content={[1]="Userdatas are not resizable once created. However, most of the time the actual expense of allocating a userdata is several times cheaper than the overhead of calling the Lua function that would do so. There are several ways to make a new userdata.",[2]="",[3]="- From scratch, using the [`userdata()`](/picotron_api/functions/userdata/main.md) or [`vec()`](/picotron_api/functions/vec/main.md) functions.",[4]="- When using an operator on an existing userdata.",[5]="- By calling an [operation](#bulk-operations) function when the `dest` argument is falsey.",[6]=""},children={}},[3]={level=2,text="Numerical types",content={[1]="Every userdata is an array containing one of the following numerical types:",[2]="",[3]="- u8 - An unsigned 8-bit integer.",[4]="- i16 - A signed 16-bit integer.",[5]="- i32 - A signed 32-bit integer.",[6]="- i64 - A signed 64-bit integer.",[7]="- f64 - A 64-bit floating point number, useful for representing fractional values to high precision. This is also the type that will be created by the [`vec()`](/picotron_api/functions/vec/main.md) function.",[8]="",[9]="If any operation on an integer typed userdata, including setting an element explicitly, would cause a number to overflow or underflow, the value will wrap around.",[10]=""},children={}},[4]={level=2,text="Indexing",content={[1]="You can fetch the total number of elements in a userdata by using the [`#`](metamethods/__len/main.md) operator, much like you would for a table array. For the number of rows or columns, you can use the [`height()`](methods/height/main.md), [`width()`](methods/width/main.md), or [`attribs()`](methods/attribs/main.md) methods.",[2]="",[3]="2D userdatas, as arrays, are completely flat, as opposed to being a nested structure of arrays within arrays. Every element is somewhere in one contiguous set of indices. 2D userdatas are row-major, meaning that the elements in each row are stored consecutively, and each of those rows is stored in width-sized chunks. The indices in the userdata are traversed in lexicographical order.",[4]="",[5]="There are two ways to index a userdata. You can do it the same way you would for a table, by using the [`[i]`](metamethods/__index/main.md) syntax. You can also call the [`get()`](methods/get/main.md) method, which will allow you to use row and column indices instead of a flat index.",[6]="",[7]="Unlike a table-based array, userdatas are indexed starting from 0. This is especially important to keep in mind when writing a for loop, because Lua uses inclusive/inclusive range syntax.",[8]="",[9]="```lua",[10]="local tab = {0, 1, 2, 3, 4}",[11]="",[12]="-- Tables are 1-indexed, meaning the final index to iterate over",[13]="-- should be the same as the total count of elements in the array.",[14]="-- This is why Lua is inclusive of #tab in the iteration.",[15]="for i = 1, #tab do",[16]="	?tab[i]",[17]="end",[18]="",[19]="local ud = vec(0, 1, 2, 3, 4)",[20]="",[21]="-- Userdatas are 0-indexed. The final index that should be iterated",[22]="-- is not the same as the total count of elements, meaning you will",[23]="-- have to subtract one from the count. If you forget to do this,",[24]="-- the iterator will index the userdata out of range, fetching a",[25]="-- nil value.",[26]="-- It's also worth noting you will need this mindset for ud:width()",[27]="-- and ud:height() as well, since they also give you counts, not",[28]="-- final indices.",[29]="for i = 0, #ud - 1 do",[30]="	?ud[i]",[31]="end",[32]="```",[33]="",[34]="With this in mind, the following snippet is meant to demonstrate where each flat index ends up in a 2D userdata's coordinates.",[35]="```lua",[36]="-- ud is created with a layout like so:",[37]="-- 00 01 02",[38]="-- 03 04 05",[39]="-- 06 07 08",[40]="local ud = userdata(\"u8\", 3, 3, \"000102030405060708\")",[41]="",[42]="-- ud:get(x, y) uses column/row coordinates rather than a flat index.",[43]="-- First row",[44]="assert(ud[0] == ud:get(0, 0))",[45]="assert(ud[1] == ud:get(1, 0))",[46]="assert(ud[2] == ud:get(2, 0))",[47]="",[48]="-- Second row",[49]="assert(ud[3] == ud:get(0, 1))",[50]="assert(ud[4] == ud:get(1, 1))",[51]="assert(ud[5] == ud:get(2, 1))",[52]="",[53]="-- Third row",[54]="assert(ud[6] == ud:get(0, 2))",[55]="assert(ud[7] == ud:get(1, 2))",[56]="assert(ud[8] == ud:get(2, 2))",[57]="```",[58]=""},children={}},[5]={level=2,text="Dimensionality",content={[1]="Userdatas can have one or two dimensions. The [`userdata()`](/picotron_api/functions/userdata/main.md) function can be called with or without a `height` argument to produce a 2D or 1D userdata, respectively, and [`vec()`](/picotron_api/functions/vec/main.md) will always produce a 1D userdata.",[2]="",[3]="1D userdatas do not have a height. That doesn't mean that their height value is 1 or 0, but that height is not an attribute that they keep track of. Having or not having a height is a property that is stored on the userdata. This will cause certain functions, such as [`get()`](methods/get/main.md) and [`set()`](methods/set/main.md), to behave differently, under the assumption that the effective height of a 1D userdata is always 1.",[4]=""},children={}},[6]={level=2,text="Bulk operations",content={[1]="Userdatas have several bulk number manipulation methods that all work in roughly the same way. These operations are the main reason why userdatas are an attractive tool for optimization, because they skip the overhead of using a for loop in Lua, where each operation costs an order of magnitude more than it would running in native code, where bulk operations do most of their work.",[2]="",[3]="One-op:",[4]="- [`abs`](methods/abs/main.md)",[5]="- [`sgn`](methods/sgn/main.md)",[6]="- [`sgn0`](methods/sgn0/main.md)",[7]="- [`crc`](methods/crc/main.md)",[8]="",[9]="Two-op:",[10]="- [`copy`](methods/copy/main.md)",[11]="- [`add`](methods/add/main.md)",[12]="- [`sub`](methods/sub/main.md)",[13]="- [`mul`](methods/mul/main.md)",[14]="- [`div`](methods/div/main.md)",[15]="- [`idiv`](methods/idiv/main.md)",[16]="- [`mod`](methods/mod/main.md)",[17]="- [`pow`](methods/pow/main.md)",[18]="- [`band`](methods/band/main.md)",[19]="- [`bor`](methods/bor/main.md)",[20]="- [`bxor`](methods/bxor/main.md)",[21]="- [`shl`](methods/shl/main.md)",[22]="- [`shr`](methods/shr/main.md)",[23]="- [`min`](methods/min/main.md)",[24]="- [`max`](methods/max/main.md)",[25]="",[26]="The signature for these methods is `ud = lhs:op([rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count])`, but to build robust knowledge, this section will start with the most basic usage and gradually add additional features from each of the arguments.",[27]=""},children={[1]={level=3,text="The `lhs` and `rhs` arguments",content={[1]="For the one-op methods, the `rhs` argument is completely ignored, unless `lhs` is not a userdata. Without any arguments this will just apply the operation to every element in the userdata. `ud = lhs:abs()` will create a userdata `ud` which is identical to `lhs`, except every value will be absolute instead of signed.",[2]="",[3]="For the two-op methods, `rhs` is required, and will be applied just like the respective instruction the operation is named after. `ud = lhs:div(rhs)` will produce a userdata `ud` which is identical to `lhs`, except each element will be divided by the element in `rhs` which shares the same index. `ud = vec(1, 2):div(vec(2, 3))` will produce a userdata with the elements in index 0 and 1 being 1/2 and 2/3, respectively.",[4]="",[5]="Either `lhs` or `rhs` can be a scalar value, which will be broadcast to every element in the userdata on the opposite side. You can use a scalar value for the left hand side by calling the operation as a function, either on the userdata, like `ud = rhs.div(1, rhs)`, or through the `USERDATA` table, `ud = USERDATA.div(1, rhs)`. The `USERDATA` table is not mentioned in the official documentation, so while it's a perfectly practical way to do this, it is unknown if it's reliable from version to version.",[6]="",[7]="Userdatas have their operators aliased to these two-op methods, so `vec(1, 2):div(vec(2, 3))` is exactly equivalent to `vec(1, 2) / vec(2, 3)`. This will allow you to use scalar values for `lhs` easily, since `rhs` will get the call with the relevant operands. For example, you can get a userdata of reciprocals through the expression `ud = 1 / vec(2, 3)`.",[8]=""},children={}},[2]={level=3,text="The `dest` argument",content={[1]="`dest` controls which userdata the resulting values should be written to. If `dest` is falsey, a copy of `lhs` will be created, and the values will be written to that. If `dest` is a userdata, then the values will be written into that userdata. If `dest` is some other truthy value, then the values will be written directly to `lhs`. In every case, the userdata that was written to will be returned.",[2]="",[3]="```lua",[4]="local dest = vec(0, 0, 0)",[5]="local lhs = vec(1, 2)",[6]="local rhs = vec(2, 3)",[7]="",[8]="-- Result will be a new userdata containing lhs/rhs.",[9]="local result = lhs:div(rhs)",[10]="-- Replaces the values in lhs with lhs/rhs.",[11]="-- The result variable will point to the same userdata as lhs.",[12]="local result = lhs:div(rhs, true)",[13]="-- Replaces the values in dest with lhs/rhs.",[14]="-- The result variable will point to the same userdata as dest.",[15]="local result = lhs:div(rhs, dest)",[16]="```",[17]="",[18]="Below is a reference table for the behavior of `dest`.",[19]="|`dest`             |`lhs`       |`rhs`   |written to     |",[20]="|-------------------|------------|--------|---------------|",[21]="|userdata           |any         |any     |`dest`         |",[22]="|truthy non-userdata|userdata    |any     |`lhs`          |",[23]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[24]="|falsey             |userdata    |any     |a copy of `lhs`|",[25]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[26]="",[27]="The next six arguments dictate how the userdatas will be iterated over.",[28]=""},children={}},[3]={level=3,text="The `read_start` and `write_start` arguments",content={[1]="`read_start` and `write_start` control where iteration will start for `rhs` and `lhs`, respectively. These both default to 0, which is why without these arguments, both inputs and the output operate on the same indices for each operation. Setting `read_start` to some other positive value will cause the indices being read from `rhs` to be offset by as much, and similarly for `write_start`, the indices being read from `lhs` and written to in the destination userdata will be offset.",[2]="",[3]="The fact that the index that is being read from `lhs` is also the one being written to in the destination userdata is worth underlining. Even with additional arguments, this correlation never changes.",[4]="",[5]="The operation `ud = vec(1, 2, 3):add(vec(1, 2), false, 0, 1)` will result in `ud` being populated with `1, 3, 5`. The first value is skipped, the second value is `2 + 1`, and the third value is `3 + 2`.",[6]="",[7]="All iteration during the call will automatically clamp to a safe range, never letting accesses go out of bounds. What this means in this case is that if the iteration would cause the `rhs` index to go out of range of `rhs`, or the `lhs` index to go out of range of either `lhs` or the destination userdata, iteration will stop. Without the `group_count` argument, this will stop the function, and return the result immediately.",[8]="",[9]="With just these arguments, it is possible to perform a prefix sum, or any running total operation, by writing to the same userdata that is being read in such a way that the written values will be revisited and used for a future operation.",[10]="```lua",[11]="local ud = userdata(\"i64\", 10)",[12]="-- Copies 1 into every element of ud.",[13]="ud:copy(1, true)",[14]="-- Sums element i with element i + 1, and writes to element i + 1.",[15]="-- i + 1 will be immediately revisited in the next iteration as i, meaning",[16]="-- that the sum total propagates forwards with each iteration.",[17]="ud:add(ud, true, 0, 1)",[18]="ud:add(ud, true, 0, 1) -- Does it again.",[19]="",[20]="for i = 0, #ud - 1 do",[21]="	?ud[i] -- Prints triangle numbers up to 55.",[22]="end",[23]="```",[24]=""},children={}},[4]={level=3,text="The `group_size` argument",content={[1]="The `group_size` argument controls the number of consecutive elements that will be operated on. For instance, if you want to put an arbitrary section of one userdata into an equivalently sized section of another userdata, you can use `group_size` to indicate how many elements should be moved. `lhs:copy(rhs, true, 5, 2, 3)` will copy 3 consecutive elements starting from index 5 of `rhs` into `lhs` starting at index 2.",[2]=""},children={}},[5]={level=3,text="The `read_increment`, `write_increment` and `group_count` arguments",content={[1]="`read_increment`, `write_increment` and `group_count` control an additional layer of iteration. All three of these arguments default to 1. When `group_count` is greater than 1, the entire previous set of operations will happen that many times. Each time, `read_start` and `write_start` will be incremented by `read_increment` and `write_increment`. This is why `group_size` and `group_count` refer to 'groups'. These control the size and number of groups of concecutive elements that will be operated on.",[2]="",[3]="If you wanted to divide every other element from `lhs` with each element from `rhs`, you could do so by using a `group_size` of 1, `write_increment` of 2, and `group_count` equal to the number of elements in `rhs`. The operation would look like: `ud = lhs:div(rhs, false, 0, 0, 1, 1, 2, #rhs)`",[4]="",[5]="It's also possible to set `read_increment` or `write_increment` to 0, which will cause it to repeatedly index the same section of the array for each group. This is useful for broadcasting scalars and groups of values. For example, you may have a 2D userdata with 3D coordinates in each row.",[6]="",[7]="If you wanted to scale them by 10, and flip them on the z axis, you could do so by calling `scaled = coords:mul(vec(10, 10, -10), false, 0, 0, 3, 0, 3, coords:height())`. By setting `read_increment` to 0, each time a coordinate is done being scaled, it will start over at the begining of the `rhs` vector for every group.",[8]="",[9]="As a final example, if you had a 2D userdata that was 9x9, and you wanted to copy a 3x3 userdata with the top left sitting on the (2, 3) coordinate, you can take advantage of every argument to do so.",[10]="```lua",[11]="local bigger = userdata(\"u8\",9,9,\"1c071c0c1c0c110c11071c0c1c0c110c11101c0c1c0c110c1110110c1c0c110c111011101c0c110c11101110010c110c111011100110110c111011100110010c1110111001100100111011100110010001\")",[12]="",[13]="local smaller = userdata(\"u8\",3,3,\"141a141a1a1a141a14\")",[14]="",[15]="-- Note that because userdatas use flat indices, the element one row",[16]="-- down from any given element is located at i + ud:width().",[17]="bigger:copy(",[18]="	smaller, -- Read from smaller",[19]="	true, -- Write to bigger.",[20]="	0, -- Start reading from smaller at index 0.",[21]="	2 + bigger:width() * 3, -- Start writing to the coordinate (2, 3) on bigger.",[22]="	smaller:width(), -- Write 3 consecutive elements at a time.",[23]="	smaller:width(), -- After each group, read from the next row in smaller.",[24]="	bigger:width(), -- After each group, write to the next row in bigger.",[25]="	smaller:height() -- Write 3 rows.",[26]=")",[27]="",[28]="spr(bigger) -- Draws the bigger userdata to the screen now that it's mutated.",[29]="```",[30]="",[31]="This is effectively a more verbose way to implement the [`blit`](methods/blit/main.md) operation, but it demonstrates what makes these arguments flexible, and why each is useful for bulk data manipulation.",[32]="",[33]="The same rules about overrunning the end of the array that applies to each individual group also applies to `read_i` and `write_i`. If either exceed the end of the array, iteration will stop, and the value will be immediately returned. Note that even if an individual group overruns, this will not stop the next group from operating if `read_i` and `write_i` are still valid indices.",[34]=""},children={}}}},[7]={level=2,text="References",content={[1]="[userdata()](/picotron_api/functions/userdata/main.md)",[2]="",[3]="[vec()](/picotron_api/functions/vec/main.md)",[4]="",[5]="[methods](methods/readme.md)",[6]=""},children={}}}}}},[99]={name="main.md",path="/picotron_api/map/main.md",data={[1]={level=1,text="Map",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This information is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html)",[3]="",[4]="A map in Picotron is a 2d userdata of type i16. Each tile value uses 13 bits for the @{Sprite Indexes},  and 3 bits for orientation:",[5]=""},children={}},[2]={level=2,text="Userdata Structure",content={[1]="```",[2]="0x00ff the sprite number within a .gfx file (0..255)",[3]="0x1f00 the gfx file number (0..31)",[4]="0x2000 flip the tile diagonally  -- not supported by tline3d()",[5]="0x4000 flip the tile horizontally",[6]="0x8000 flip the tile vertically",[7]="```",[8]=""},children={}},[3]={level=2,text="Flipping bits",content={[1]="",[2]="All tile flipping bits are observed by the map editor and [map()](/picotron_api/functions/map/main.md).",[3]="",[4]="The default tile width and height are set to match sprite 0.",[5]=""},children={}},[4]={level=2,text="Map Files",content={[1]="",[2]="A map file (`foo.map`) is a table of layers, where each layer has a `.bmp` (the userdata for that layer) a `.name`, and some other values for the editor (`.pan_x`, `.zoom` etc). So, to access the userdata for a given layer of a map file:",[3]="",[4]="```lua",[5]="layers = fetch(\"map/mountains.map\") -- call once when e.g. loading a level",[6]="ud = layers[1].bmp -- grab the top layer's userdata",[7]="map(ud) -- draw that layer",[8]="print(\"the layer is \"..ud:width()..\" tiles wide\")",[9]="```",[10]="",[11]="By default, The first layer of map/0.map is set as the current working map if PICO-8 style manipulation is preferred (see below). Map files can be alternatively be manually loaded, in which each layer can be manipulated as regular [Userdata](/picotron_api/userdata/readme.md) and passed to [map()](/picotron_api/functions/map/main.md) or [tline3d()](/picotron_api/functions/tline3d/main.md) as the first parameter.",[12]="",[13]="```lua",[14]="layers = fetch(\"map/forest.map\") -- call once when e.g. loading a level",[15]="map(layers[2].bmp)   -- draw a particular layer",[16]="?map:get(5,3) -- print the tile value at 5,3 ",[17]="```",[18]=""},children={}},[5]={level=2,text="Setting a Current Working Map",content={[1]="",[2]="This is an optional PICO-8 compatibility feature",[3]="",[4]="When only a single global map is needed, there is the option to set the \"current working map\" and use only PICO-8 style map functions [map](/picotron_api/functions/map/main.md), [mset](/picotron_api/functions/mset/main.md) and [mget](/picotron_api/functions/mget/main.md).",[5]="",[6]="The current working map is taken to be whatever i16 userdata is [memmap()](/picotron_api/functions/memmap/main.md)'ed to `0x100000`. This happens automatically when a cartridge is run and `map/0.map` exists (the first layer is used).",[7]="",[8]="```lua",[9]="mymap = fetch(\"forest.map\")[2].bmp -- grab layer 2 from a map file",[10]="memmap(mymap, 0x100000)",[11]="map()  -- same as map(mymap)",[12]="?mget(2,2) -- same as mymap:get(2,2)",[13]="```"},children={}}}}}},[100]={name="main.md",path="/picotron_api/picotron_lua/main.md",data={[1]={level=1,text="Picotron Lua",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This information is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html)",[3]="",[4]="Picotron uses a slightly extended version of Lua 5.4, and most of the standard Lua libraries are available. For more details, or to find out about Lua, see www.lua.org.",[5]=""},children={}},[2]={level=2,text="A Quick Introduction to Lua",content={[1]="",[2]="This section a primer for getting started with standard Lua syntax.",[3]=""},children={[1]={level=3,text="Comments",content={[1]="",[2]="```lua",[3]="-- use two dashes like this to write a comment",[4]="--[[ multi-line",[5]="comments ]]",[6]="```",[7]="",[8]="To create nested multi-line comments, add a matching number of ='s between the opening and ",[9]="closing square brackets:",[10]="",[11]="```lua",[12]="--[===[",[13]="--[[",[14]="this comment can appear inside another multi-line comment ",[15]="]]",[16]="]===]",[17]="```",[18]=""},children={}},[2]={level=3,text="Types and assignment",content={[1]="",[2]="Types in Lua are numbers, strings, booleans, tables, functions and nil:",[3]="",[4]="```lua",[5]="num = 12/100",[6]="s = \"this is a string\"",[7]="b = false",[8]="t = {1,2,3}",[9]="f = function(a) print(\"a:\"..a) end",[10]="n = nil",[11]="```",[12]="",[13]="Numbers can be either doubles or 64-bit integers, and are converted automatically between the ",[14]="two when needed.",[15]=""},children={}},[3]={level=3,text="Conditionals",content={[1]="",[2]="A block of code can be executed when some condition is true, by using if {condition} then {code} end:",[3]="",[4]="```lua",[5]="if (4 == 4) then print(\"equal\") end",[6]="if (4 ~= 3) then print(\"not equal\") end",[7]="if (4 <= 4) then print(\"less than or equal\") end",[8]="if (4 > 3) then print(\"more than\") end",[9]="```",[10]="",[11]="Use \"else\" for code that should be executed when the condition is false:",[12]="",[13]="```lua",[14]="if not b then",[15]="    print(\"b is false\")",[16]="else",[17]="    print(\"b is not false\")",[18]="end",[19]="```",[20]="",[21]="\"elseif\" can be used when there is more than one conditional block:",[22]="",[23]="```lua",[24]="if x == 0 then",[25]="    print(\"x is 0\")",[26]="elseif x < 0 then",[27]="    print(\"x is negative\")",[28]="else",[29]="    print(\"x is positive\")",[30]="end",[31]="```",[32]=""},children={}},[4]={level=3,text="Loops",content={[1]="",[2]="Loop ranges are inclusive:",[3]="",[4]="```lua",[5]="-- print 1,2,3,4,5",[6]="for x=1,5 do",[7]="    print(x)",[8]="end",[9]="```",[10]="",[11]="The same with a while loop:",[12]="",[13]="```lua",[14]="x = 1",[15]="while x <= 5 do",[16]="    print(x)",[17]="    x = x + 1",[18]="end",[19]="```",[20]="",[21]="The default for loop step value is 1. To jump a different amount or to loop backwards:",[22]="",[23]="```lua",[24]="for x = 1, 10, 3 do print(x) end   -- 1,4,7,10",[25]="",[26]="for x = 5, 1, -2 do print(x) end   -- 5,3,1",[27]="```",[28]=""},children={}},[5]={level=3,text="Functions and Local Variables",content={[1]="",[2]="Variables declared as local are scoped to their containing block of code (for example, inside a function, for loop, or if then end statement).",[3]="",[4]="```lua",[5]="y = 0",[6]="function plusone(x)",[7]="    local y = x",[8]="    y = y + 1",[9]="    return y",[10]="end",[11]="print(plusone(2)) -- 3",[12]="print(y)  -- still 0",[13]="```",[14]="",[15]="Functions can take and return any number of values:",[16]="",[17]="```lua",[18]="function swap(x, y)",[19]="    return y, x",[20]="end",[21]="a,b = swap(1,2)",[22]="?a -- 2",[23]="?b -- 1",[24]="```",[25]=""},children={}},[6]={level=3,text="Lua Tables",content={[1]="",[2]="In Lua, tables are a collection of key-value pairs where the key and value types can both be mixed. They can be used as arrays by indexing them with integers.",[3]="",[4]="```lua",[5]="a={} -- create an empty table",[6]="a[1] = \"blah\"",[7]="a[2] = 42",[8]="a[\"foo\"] = {1,2,3}",[9]="```",[10]="",[11]="Arrays use 1-based indexing by default:",[12]="",[13]="```lua",[14]="a = {11,12,13,14}",[15]="print(a[2]) -- 12",[16]="```",[17]="",[18]="For a 0-based array, set the zeroth slot by providing an explicit index: (or use [Userdata](/picotron_api/userdata/readme.md)):",[19]="",[20]="```lua",[21]="a = {[0]=10,11,12,13,14}",[22]="```",[23]="",[24]="Tables with 1-based integer indexes are special though. The length of such a table can be found with the # operator, and Picotron uses such arrays to implement the [add](/picotron_api/functions/add/main.md), [del](/picotron_api/functions/del/main.md), [deli](/picotron_api/functions/deli/main.md), [all](/picotron_api/functions/all/main.md) and [foreach](/picotron_api/functions/foreach/main.md) functions.",[25]="",[26]="```lua",[27]="print(#a)   -- 4",[28]="add(a, 15)",[29]="print(#a)   -- 5",[30]="```",[31]="",[32]="Indexes that are strings can be written using dot notation",[33]="",[34]="```lua",[35]="player = {}",[36]="player.x = 2 -- is equivalent to player[\"x\"]",[37]="player.y = 3",[38]="```",[39]=""},children={}}}},[3]={level=2,text="Picotron Shorthand",content={[1]="",[2]="Picotron offers some shorthand forms following PICO-8's dialect of Lua, that are not standard Lua.",[3]=""},children={[1]={level=3,text="Shorthand if / while statements",content={[1]="",[2]="\"if .. then  .. end\" statements, and \"while .. then .. end\" can be written on a single line:",[3]="",[4]="```lua",[5]="if (not b) i=1 j=2",[6]="```",[7]="",[8]="Is equivalent to:",[9]="",[10]="```lua",[11]="if not b then i=1 j=2 end",[12]="```",[13]="",[14]="Note that brackets around the short-hand condition are required, unlike the expanded version.",[15]=""},children={}},[2]={level=3,text="Shorthand Assignment Operators",content={[1]="",[2]="Shorthand assignment operators can be constructed by appending a '=' to any binary operator, including arithmetic (+=, -= ..), bitwise (&=, |= ..) or the string concatenation operator (..=)",[3]="",[4]="```lua",[5]="a += 2   -- equivalent to: a = a + 2",[6]="```",[7]=""},children={}},[3]={level=3,text="Integer divide",content={[1]="",[2]="Picotron accepts `\\\"` as well as `//` for integer divide, which is equivalent to [`flr(x/y)`](/picotron_api/functions/flr/main.md):",[3]="",[4]="```lua",[5]="print(5 / 2)  -- 2.5",[6]="print(5 // 2) -- 2 (standard Lua)",[7]="print(5 \\\" 2)  -- 2 (same as the PICO-8 operator)",[8]="```",[9]=""},children={}},[4]={level=3,text="!= operator",content={[1]="",[2]="Not shorthand, but Picotron also accepts != instead of ~= for \"not equal to\"",[3]="",[4]="```lua",[5]="print(1 != 2) -- true",[6]="```"},children={}}}}}}}},[101]={name="main.md",path="/picotron_api/gui/attachments/attach_button/main.md",data={[1]={level=1,text="attach_button(el)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Attaches a button with default styling",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Expected attributes",content={[1]=""},children={[1]={level=3,text="x",content={[1]="",[2]="x-position of the element",[3]=""},children={}},[2]={level=3,text="y",content={[1]="",[2]="y-position of the element",[3]=""},children={}}}},[3]={level=2,text="Available attributes",content={[1]=""},children={[1]={level=3,text="width",content={[1]="",[2]="Width of the element. Omit to auto-calculate (see limitations)",[3]=""},children={}},[2]={level=3,text="height",content={[1]="",[2]="Height of the element. Omit to auto-calculate (see limitations)",[3]=""},children={}},[3]={level=3,text="label",content={[1]="",[2]="Text to be displayed on the button",[3]=""},children={}},[4]={level=3,text="fgcol",content={[1]="",[2]="Foreground color of the button. Low byte is normal color, high byte is hover color. For example, `18 + (7 << 8)` will use color 18 (dark purple) normally, and switch to color 7 (white) when hovered. If the high byte is omitted, hover becomes color 0 (black).",[3]=""},children={}},[5]={level=3,text="bgcol",content={[1]="",[2]="Background color of the button. Low byte is normal color, high byte is hover color.",[3]=""},children={}},[6]={level=3,text="border",content={[1]="",[2]="Border color of the button. Low byte is normal color, high byte is hover color.",[3]=""},children={}}}},[4]={level=2,text="Limitations",content={[1]="",[2]="The current automatic sizing logic is very basic and does not account for P8SCII, newlines, or fonts other than the default. In these cases you may want to provide your own width/height values.",[3]=""},children={}},[5]={level=2,text="Future",content={[1]="",[2]="calculate width with current font",[3]="",[4]="can define a \"class\" or \"style\" at system-wide level or gui level that has these default values",[5]="",[6]=""},children={}}}}}},[102]={name="main.md",path="/picotron_api/gui/attachments/attach/main.md",data={[1]={level=1,text="attach(el)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Attaches a generic UI element with `el` (a table)",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Expected attributes",content={[1]=""},children={[1]={level=3,text="x",content={[1]="",[2]="x-position of the element",[3]=""},children={}},[2]={level=3,text="y",content={[1]="",[2]="y-position of the element",[3]=""},children={}},[3]={level=3,text="width",content={[1]="",[2]="width of the element",[3]=""},children={}},[4]={level=3,text="height",content={[1]="",[2]="height of the element"},children={}}}}}}}},[103]={name="readme.md",path="/picotron_api/functions/readme.md",data={[1]={level=1,text="Picotron API > Functions",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on all of the functions in the Picotron API",[3]="",[4]="[`set_spr`](set_spr/main.md)",[5]="",[6]="[`spr`](spr/main.md)",[7]="",[8]="[`sspr`](sspr/main.md)",[9]="",[10]="[`store`](store/main.md)",[11]="",[12]="[`store_metadata`](store_metadata/main.md)",[13]="",[14]="[`unmap`](unmap/main.md)",[15]="",[16]="[`memmap`](memmap/main.md)",[17]="",[18]="[`mkdir`](mkdir/main.md)",[19]="",[20]="[`mv`](mv/main.md)",[21]="",[22]="[`rm`](rm/main.md)",[23]="",[24]="[`cp`](cp/main.md)",[25]="",[26]="[`pid`](pid/main.md)",[27]="",[28]="[`send_message`](send_message/main.md)",[29]="",[30]="[`create_process`](create_process/main.md)",[31]="",[32]="[`camera`](camera/main.md)",[33]="",[34]="[`map`](map/main.md)",[35]="",[36]="[`printh`](printh/main.md)",[37]="",[38]="[`include`](include/main.md)"},children={}}}}}},[104]={name="main.md",path="/picotron_api/functions/window/main.md",data={[1]={level=1,text="window([width,height],attribs)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Create a window and/or set the window's attributes.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[width,height]",content={[1]="",[2]="Proportions of the window",[3]=""},children={}},[2]={level=3,text="attribs",content={[1]="",[2]="Table of desired attributes of the window",[3]="",[4]="Cannot overwrite `parent_pid`",[5]=""},children={[1]={level=4,text="`width`: number",content={[1]="",[2]="width in pixels (not including the frame)",[3]=""},children={}},[2]={level=4,text="`height`: height",content={[1]="",[2]="height in pixels",[3]=""},children={}},[3]={level=4,text="`title`: string",content={[1]="",[2]="set a title displayed on the window's titlebar",[3]=""},children={}},[4]={level=4,text="`pauseable`: boolean",content={[1]="",[2]="false to turn off the app menu that normally comes up with ENTER/START button",[3]=""},children={}},[5]={level=4,text="`tabbed`: boolean",content={[1]="",[2]="true to open in a tabbed workspace (like the code editor)",[3]=""},children={}},[6]={level=4,text="`has_frame`: boolean",content={[1]="",[2]="Default: true",[3]="",[4]="Whether to have a frame around the window",[5]=""},children={}},[7]={level=4,text="`moveable`: boolean",content={[1]="",[2]="Default: true",[3]="",[4]="Whether to allow the window to be dragged",[5]=""},children={}},[8]={level=4,text="`resizeable`: boolean",content={[1]="",[2]="Default: true",[3]="",[4]="Whether to allow the window to be resized",[5]=""},children={}},[9]={level=4,text="`wallpaper`: boolean",content={[1]="",[2]="Default: true",[3]="",[4]="acts as a wallpaper:",[5]="* z defaults to -1000 in that case",[6]="* opens a filenav (for the desktop interface)",[7]=""},children={}},[10]={level=4,text="`autoclose`: boolean",content={[1]="",[2]="close window when is no longer in focus or when press escape",[3]=""},children={}},[11]={level=4,text="`x`: number",content={[1]="",[2]="Position of the window",[3]=""},children={}},[12]={level=4,text="`y`: number",content={[1]="",[2]="Position of the window",[3]=""},children={}},[13]={level=4,text="`z`: number",content={[1]="",[2]="Default: 0",[3]="",[4]="windows with higher z are drawn on top.",[5]=""},children={}},[14]={level=4,text="`cursor`: string|number",content={[1]="",[2]="0 for no cursor",[3]="",[4]="1 for Default",[5]="",[6]="userdata for a custom cursor",[7]="",[8]="Use strings for some built in cursors, e.g: `pointer`",[9]=""},children={}},[15]={level=4,text="`squashable`: boolean",content={[1]="",[2]="window resizes itself to stay within the desktop region",[3]=""},children={}},[16]={level=4,text="`background_updates`: boolean",content={[1]="",[2]="allow _update() callbacks when parent window is not visible",[3]=""},children={}},[17]={level=4,text="`background_draws`: boolean",content={[1]="",[2]="allow _draw() callbacks when parent window is not visible",[3]=""},children={}}}},[3]={level=3,text="`show_context_menu`: boolean",content={[1]="",[2]="displays the menu at the user's cursor",[3]=""},children={}},[4]={level=3,text="`ghost`: boolean",content={[1]="",[2]="Window is drawn, uninteractable, inputs passthrough to the below window"},children={}}}}}}}},[105]={name="main.md",path="/picotron_api/functions/vec/main.md",data={[1]={level=1,text="vec(...): ud",content={},children={[1]={level=2,text="Overview",content={[1]="The vec function is one of two ways to create a new userdata from scratch, with the other being the [userdata](picotron_api/functions/userdata/main.md) function.",[2]="Produces a new f64 typed 1D [userdata](/picotron_api/userdata/readme.md) populated with each of the arguments.",[3]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`...`: number|nil",content={[1]="Each value to populate the userdata with. The number of arguments dictates the width of the produced userdata. Defaults to 0.",[2]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)|nil",content={[1]="The userdata produced, or nil if no arguments were provided.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="local position = vec(12, 19)",[3]="",[4]="?position:get(0) -- 12",[5]="?position:get(1) -- 19",[6]="```",[7]=""},children={}}}}}},[106]={name="main.md",path="/picotron_api/functions/userdata/main.md",data={[1]={level=1,text="userdata(type, width, height, [data]): ud",content={},children={[1]={level=2,text="Overview",content={[1]="The userdata function is one of two ways to create a new userdata from scratch, with the other being the [vec](picotron_api/functions/vec/main.md) function.",[2]="Produces a new 2D [userdata](/picotron_api/userdata/readme.md) with a specified type and size. 2D userdatas with a height of 1 are not the same as 1D userdatas, and will cause certain functions, such as [`get`](/picotron_api/userdata/methods/get/main.md) and [`set`](/picotron_api/userdata/methods/set/main.md), to behave differently.",[3]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`type`: \"u8\"|\"i16\"|\"i32\"|\"i64\"|\"f64\"",content={[1]="",[2]="The type of number that the userdata will contain.",[3]="- \"u8\" is an unsigned 8-bit integer",[4]="- \"i16\" is a signed 16-bit integer",[5]="- \"i32\" is a signed 32-bit integer",[6]="- \"i64\" is a signed 64-bit integer",[7]="- \"f64\" is a 64-bit floating point number",[8]=""},children={}},[2]={level=3,text="`width`: number",content={[1]="",[2]="The number of columns in the produced userdata. Will be floored. If less than 1, causes the returned value to be nil.",[3]=""},children={}},[3]={level=3,text="`height`: number",content={[1]="The number of rows in the produced userdata. Will be floored. If less than 1, causes the returned value to be nil.",[2]=""},children={}},[4]={level=3,text="`[data]`: string",content={[1]="The values to initialize the userdata with. Defaults to setting every entry to 0.",[2]="",[3]="If the userdata is an integer type, `data` must be formatted as a contiguous 0-padded hexidecimal string. For instance, if `type` is `i16`, the string `\"000F2001\"` would produce the numbers (in decimal) 15 and 8,193 for indices 0 and 1.",[4]="",[5]="If the userdata is a floating point type, `data` must be formatted as a comma-separated list of decimal values. For instance, `\"0.1,0.5,12\"`.",[6]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)|nil",content={[1]="The userdata produced, or nil if `width` or `height` is less than 1.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="local ud = userdata(\"u8\", 2, 2, \"080D1522\")",[3]="",[4]="?ud:get(0, 0) -- 8",[5]="?ud:get(1, 0) -- 13",[6]="?ud:get(0, 1) -- 21",[7]="?ud:get(1, 1) -- 34",[8]="```",[9]=""},children={}}}},[2]={level=1,text="userdata(type, width, [data]): ud",content={},children={[1]={level=2,text="Overview",content={[1]="The userdata function is one of two ways to create a new userdata from scratch, with the other being the [vec](picotron_api/functions/vec/main.md) function.",[2]="Produces a new 1D [userdata](/picotron_api/userdata/readme.md) with a specified type and size. 1D userdatas are not the same as 2D userdatas with a height of 1, and will cause certain functions, such as [`get`](/picotron_api/userdata/methods/get/main.md) and [`set`](/picotron_api/userdata/methods/set/main.md), to behave differently.",[3]=""},children={}},[2]={level=2,text="Arguments",content={},children={[1]={level=3,text="`type`: \"u8\"|\"i16\"|\"i32\"|\"i64\"|\"f64\"",content={[1]="",[2]="The type of number that the userdata will contain.",[3]="- \"u8\" is an unsigned 8-bit integer",[4]="- \"i16\" is a signed 16-bit integer",[5]="- \"i32\" is a signed 32-bit integer",[6]="- \"i64\" is a signed 64-bit integer",[7]="- \"f64\" is a 64-bit floating point number",[8]=""},children={}},[2]={level=3,text="`width`: number",content={[1]="",[2]="The number of columns in the produced userdata. Will be floored. If less than 1, causes the returned value to be nil.",[3]=""},children={}},[3]={level=3,text="`[data]`: string",content={[1]="The values to initialize the userdata with. Defaults to setting every entry to 0.",[2]="",[3]="If the userdata is an integer type, `data` must be formatted as a contiguous 0-padded hexidecimal string. For instance, if `type` is `i16`, the string `\"000F2001\"` would produce the numbers (in decimal) 15 and 8,193 for indices 0 and 1.",[4]="",[5]="If the userdata is a floating point type, `data` must be formatted as a comma-separated list of decimal values. For instance, `\"0.1,0.5,12\"`.",[6]=""},children={}}}},[3]={level=2,text="Returns",content={},children={[1]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)|nil",content={[1]="The userdata produced, or nil if `width` is less than 1.",[2]=""},children={}}}},[4]={level=2,text="Example",content={[1]="```lua",[2]="local ud = userdata(\"u8\", 4, \"080D1522\")",[3]="",[4]="?ud:get(0) -- 8",[5]="?ud:get(1) -- 13",[6]="?ud:get(2) -- 21",[7]="?ud:get(3) -- 34",[8]="```",[9]=""},children={}}}}}},[107]={name="main.md",path="/picotron_api/functions/unmap/main.md",data={[1]={level=1,text="unmap(ud,addr,[len])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="this is the only way to release mapped userdata for collection",[3]="",[4]="e.g. memmapping a userdata over an old one is not sufficient to free it for collection",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="ud",content={[1]="",[2]="The userdata that is unmapped from memory",[3]=""},children={}},[2]={level=3,text="addr",content={[1]="",[2]="The address to unmap the userdata from",[3]=""},children={}},[3]={level=3,text="[len]",content={[1]="",[2]="Length of the userdata to unmap, defaults to the full userdata length",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="This function does not return anything"},children={}}}}}},[108]={name="main.md",path="/picotron_api/functions/store_metadata/main.md",data={[1]={level=1,text="store_metadata(filename,meta)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`store_metadata` stores metadata, `meta`, at a file or directory, `filename`, merging with the original metadata.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="filename",content={[1]="",[2]="The path to the file or directory to store metadata in",[3]=""},children={}},[2]={level=3,text="meta",content={[1]="",[2]="The metadata to store in the file or directory",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="This function does not return anything",[3]=""},children={}},[4]={level=2,text="Possible Future",content={[1]="",[2]="Ability to remove metadata items from the pre-existing metadata"},children={}}}}}},[109]={name="main.md",path="/picotron_api/functions/store/main.md",data={[1]={level=1,text="store(location, obj, [metadata])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`store` allows you to store files, typically used for save files by storing tables in the `pod` file format.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="location",content={[1]="",[2]="The location you want to store a file at, e.g: `/appdata/mypod.pod`",[3]=""},children={}},[2]={level=3,text="obj",content={[1]="",[2]="The file data, e.g: a table for a `.pod` file.",[3]=""},children={}},[3]={level=3,text="[metadata]",content={[1]="",[2]="Optional metadata of the file, e.g: `{mymetadatavalue=\"grapes\"}`",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="This function does not return anything"},children={}}}}}},[110]={name="main.md",path="/picotron_api/functions/stat/main.md",data={[1]={level=1,text="function stat(n,[...])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Greatly helped by [@akd-io and @Maxine](https://github.com/akd-io/picotron/blob/ccb6d34d8594cd4c2d45930cf8723c241f5aa6e9/drive/projects/stat/stats.md?plain=1#L80)",[3]="Returns information about the system and can sometimes do actions such as garbage collection.",[4]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="n: `number`",content={[1]="",[2]="The id for the information you want to fetch",[3]=""},children={}},[2]={level=3,text="[...]: `arbritrary`",content={[1]="",[2]="Arbritrary arguments, sometimes used in stat, e.g: with `stat(302,keycode)`",[3]=""},children={}},[3]={level=3,text="Valid usage",content={[1]="",[2]="Where the first number is `n` and any other arguments, if present, are `[...]`",[3]="",[4]="`Unknown` signifies that it returns values, but what they mean is unknown.",[5]="",[6]="@Astralsparv's [Picotron Logger Distribution](https://github.com/Astralsparv/Picotron-Logger-Distribution) will be updated to help document this, fed the arbritrary values seen in unknown stats and detecting any change in the stat per frame in hopes of finding a cause and reproducing it.",[7]=""},children={[1]={level=4,text="Stats",content={[1]="where c is a channel, addr is an address, n is a node:",[2]="",[3]="* 0 - memory usage (bytes), also triggers a garbage collection",[4]="* 1 - cpu usage (decimal)",[5]="* 2 - reserved",[6]="* 3 - raw memory usage (bytes), no garbage collection",[7]="* 5 - runtime, system version",[8]="     `runtime,system_version=stat(5)`",[9]="* 7 - operating fps (60, 30, 20, 15)",[10]="* 86 - epoch time",[11]="* 87 - timezone delta (seconds)",[12]="* 101 - web: player cart id (when playing a bbs cart; nil otherwise)",[13]="* 150 - web: window.location.href",[14]="* 151 - web: stat(150) up to the end of the window.location.pathname",[15]="* 152 - web: window.location.host",[16]="* 153 - web: window.location.hash",[17]="* 301 - total CPU usage",[18]="* 302, keycode - returns human readable name for the keycode, surface [SDL's GetKeyName](https://wiki.libsdl.org/SDL2/SDL_GetKeyName)",[19]="* 305 - Whether any key is pressed",[20]="* 307 - 1.0 if current working path is `/system` (including if the cartridge is located in `/system/`)",[21]="* 308 - Unknown",[22]="* 309 - Unknown",[23]="* 310 - Unknown",[24]="* 311 - Unknown",[25]="* 312 - 4096 (amount of bytes in a page)",[26]="* 313 - Unknown, *likely* amount of memory allocated total",[27]="* 314 - Pi as `3..1415926535898`",[28]="* 315 - Presence of `-x` CLI argument when running Picotron headless",[29]="* 316 - Path specified when running headless",[30]="* 317 - `3.0` when a binary or html export, `1.0` when running on the BBS web player, `0.0` otherwise",[31]="* 318 - `1.0` when a html export (including BBS web player), `0.0` otherwise",[32]="* 320 - `1.0` when recording a gif, `0.0` otherwise",[33]="* 321 - amount of frames that the active gif capture has, `0.0` otherwise",[34]="* 322 - `1.0` when you're actively capturing a gif, `0.0` otherwise",[35]="* 330 - `1.0` when Picotron's battery saver is active, `0.0` otherwise",[36]="* 400+c,0 - `1.0` when a note is held, `0.0` otherwise",[37]="* 400+c,1 - channel instrument",[38]="* 400+c,2 - channel volume",[39]="* 400+c,3 - channel pan",[40]="* 400+c,4 - channel pitch",[41]="* 400+c,5 - channel bend",[42]="* 400+c,6 - channel effect",[43]="* 400+c,7 - channel effect_p",[44]="* 400+c,8 - channel tick length",[45]="* 400+c,9 - channel row",[46]="* 400+c,10 - channel row tick",[47]="* 400+c,11 - channel sfx tick",[48]="* 400+c,12 - channel sfx index, `-1` if no sfx playing",[49]="* 400+c,13 - channel last played sfx index",[50]="* 400+c,19,addr - stereo output of buffer (returns number of samples)",[51]="* 400+c,20+n,addr - mono output of buffer for a node (0..7)",[52]="* 464 - bitfield indicating which channels are playing (sfx)",[53]="* 465, addr - copy last mixer stereo output buffer output is written as int16's to addr. (returns number of samples written)",[54]="* 466 - which pattern is playing (-1 when no music is playing)",[55]="* 467 - index of the left-most non-looping music channel",[56]="* 498 - bitfield of currently active audio channels system-wide",[57]="* 984 - Unknown",[58]="* 985 - Unknown",[59]="* 987 - miliseconds picotron has been running",[60]="* 988 - `1.0` if both left and right control keys are held, `0.0` otherwise",[61]=""},children={}}}}}},[3]={level=2,text="Returns",content={[1]="",[2]="The queried information from the stat, unique to `n`, see the valid stats above for information on specific stats.",[3]=""},children={}},[4]={level=2,text="Unknown stats",content={[1]="",[2]="More information on unknown stats.",[3]="",[4]="[stat.lua](https://github.com/akd-io/picotron/blob/main/drive/projects/stat/stat.lua) (a test from akd-io)",[5]=""},children={[1]={level=3,text="308",content={[1]="",[2]="Observed value `1973.0` and `2334.0` in stat.lua output.",[3]="",[4]="No code references.",[5]=""},children={}},[2]={level=3,text="309",content={[1]="",[2]="Observed value `60531740.0` and `63912031.0` in stat.lua output.",[3]="",[4]="No code references.",[5]=""},children={}},[3]={level=3,text="310",content={[1]="",[2]="Observed value `551.0`, `565.0` and `3689.0` in stat.lua output.",[3]="",[4]="Same decompiled code as for stat(311) below, but passing 2 to pdisk_count_slots_by_kind() instead of 0.",[5]="",[6]="No code references.",[7]=""},children={}},[4]={level=3,text="311",content={[1]="",[2]="Functionality unknown.",[3]="",[4]="Observed value `15833.0`, `15819.0` and `12342.0` in stat.lua output.",[5]="",[6]="Decompiled code by Maxine:",[7]="",[8]="```C",[9]="if (stat_type != UNDOCUMENTED_311) goto LAB_00460c7f;",[10]="tmp_int0 = pdisk_count_slots_by_kind(0);",[11]="result_num = (lua_Number)tmp_int0;",[12]="```",[13]=""},children={[1]={level=4,text="Picotron Manual reference",content={[1]="Each process in Picotron has a limit of 32MB RAM, which includes both allocations for Lua objects, and data stored directly in RAM using memory functions like poke() and memcpy(). In the latter case, 4k pages are allocated when a page is written, and can not be deallocated during the process lifetime.",[2]="",[3]="Only 16MB of ram is addressable: 0x000000..0xffffff. Memory addresses below 0x80000 and above 0xf00000 are mostly reserved for system use, but anything in the 0x80000..0xefffff range can be safely used for arbitrary purposes.",[4]=""},children={}}}},[5]={level=3,text="313",content={[1]="",[2]="Amount of memory allocated",[3]="",[4]="Decompiled by Maxine",[5]="```C",[6]="    case UNDOCUMENTED_313:",[7]="        lua_pushnumber(L, cproc->mem_highwater);",[8]="        return 1;",[9]="```",[10]=""},children={}},[6]={level=3,text="984",content={[1]="",[2]="To do with yielding and coroutines",[3]="",[4]="Code reference: ",[5]="```lua",[6]="if costatus(c) == \"suspended\" and stat(984) == 0 then",[7]="```"},children={}},[7]={level=3,text="985",content={[1]="",[2]="Observed value `1.0` in stat.lua output.",[3]=""},children={}},[8]={level=3,text="988",content={[1]="",[2]="To do with minimal terminal setup",[3]="",[4]="Code reference:",[5]="```lua",[6]="-- give a guaranteed short window to skip",[7]="if (stat(988) > 0) bypass = true _signal(35)",[8]="```",[9]=""},children={}}}}}}}},[111]={name="main.md",path="/picotron_api/functions/sspr/main.md",data={[1]={level=1,text="sspr(sprite,sx,sy,sw,sh,x,y,[dw],[dh][flip_x],[flip_y])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`sspr` draws a sprite, similar to [`spr()`](/functions/spr/main.md), but allows you to also resize the sprite.",[3]="",[4]="This is scaling sprites, e.g: zoom",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="sprite: `index` or `userdata u8`",content={[1]="",[2]="What is drawn to the screen",[3]=""},children={}},[2]={level=3,text="sx,sy: `number`",content={[1]="",[2]="The coordinates of what is treated as the top left of `sprite`, allowing you to add offsets",[3]=""},children={}},[3]={level=3,text="sw,sh: `number`",content={[1]="",[2]="The width & height of `sprite` - allows you to crop the sprite.",[3]=""},children={}},[4]={level=3,text="dx,dy: `number`",content={[1]="",[2]="Where the sprite is to be drawn on screen",[3]=""},children={}},[5]={level=3,text="[dw],[dh]: `number`",content={[1]="",[2]="Optional, defaults to the proportions of the sprite",[3]="",[4]="The new width & height of `sprite`.",[5]="",[6]="`sprite` will be drawn rescaled to match the proportions of `[dw],[dh]`.",[7]=""},children={}},[6]={level=3,text="[flip_x],[flip_y]",content={[1]="",[2]="Flips the sprite on their respective axis",[3]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="```lua",[3]="local mapUD=userdata(\"u8\",480,270)",[4]="",[5]="set_draw_target(mapUD) --all graphical operations now go to the map userdata",[6]="map() --draw map",[7]="set_draw_target() --return graphical operations to the window/screen",[8]="",[9]="--mapwidth,mapheight is the proportions of the map",[10]="--x,y is where to draw the map",[11]="",[12]="sspr(mapUD,0,0,mapwidth,mapheight,x,y,mapwidth*2,mapheight*2)",[13]="```",[14]=""},children={}},[4]={level=2,text="Returns",content={[1]="",[2]="Unknown",[3]=""},children={}}}}}},[112]={name="main.md",path="/picotron_api/functions/spr/main.md",data={[1]={level=1,text="spr(sprite,[x],[y],[flip_x],[flip_y])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`spr` draws a sprite from either a userdata or the spritebank",[3]="",[4]="This is scaling sprites, e.g: zoom",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="sprite",content={[1]="",[2]="Sprite index from the spritesheet, or a `userdata u8` piece of data - this is what is drawn.",[3]=""},children={}},[2]={level=3,text="x,y",content={[1]="",[2]="The coordinates of where to draw the sprite",[3]=""},children={}},[3]={level=3,text="[flip_x],[flip_y]",content={[1]="",[2]="Flips the sprite on their respective axis",[3]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="Draw a sprite from sprite index 0 to position (0,0)",[3]="```lua",[4]="spr(0,0,0)",[5]="```",[6]="",[7]="Draw a sprite from a `userdata u8` to position (0,0)",[8]="```lua",[9]="sp=--[[pod_type=\"gfx\"]]unpod(\"b64:bHo0ALEAAAC4AQAA_gFweHUAQyBAQATw9jPwHDOwBQCvcDM3M-AUMzEzMAkACEuz8BSzBQCPcDNw8wxwM7AHAAGN8ABz_wxz8AQGADAAM-t3AAkFAO9wMzt-IPsMfjszMDM7fgkABo8_dz77BD53PgsAEz9_u34KABBf-gS7-gQIAAjvPxp_Nz67Pjd_PTMwMz0MAA6fcDN9frt_fTOwCAAEYPAAc7s_uwwBDwcAAFQM8wzwFAQAUPMM8P8D\")",[10]="",[11]="spr(sp,0,0)",[12]="```",[13]=""},children={}},[4]={level=2,text="Returns",content={[1]="",[2]="Unknown",[3]=""},children={}}}}}},[113]={name="main.md",path="/picotron_api/functions/set_spr/main.md",data={[1]={level=1,text="set_spr(index, s, [flags_val])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`set_spr` adds or removes a sprite at a set index.",[3]="",[4]="Sprite flags are stored at 0xc000 (16k)",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="index",content={[1]="",[2]="The index of the sprite you're modifying in the spritesheet.",[3]=""},children={}},[2]={level=3,text="s",content={[1]="",[2]="The sprite data to set in sprite `index`, form of a `userdata u8`.",[3]=""},children={}},[3]={level=3,text="[flags_val]",content={[1]="",[2]="The flag information to be set for sprite `index`, defaults to 0",[3]="",[4]="Poked into `0xc000`, offset by `index &= 0x3fff`",[5]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="This function does not return anything"},children={}}}}}},[114]={name="main.md",path="/picotron_api/functions/send_message/main.md",data={[1]={level=1,text="send_message(proc_id, msg, [response])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`send_message` allows you to communicate with other processes.",[3]="",[4]="This is useful for communication between processes",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="proc_id",content={[1]="",[2]="The process ID of which to send the message to",[3]=""},children={}},[2]={level=3,text="msg",content={[1]="",[2]="The message, a table, to send to the process `proc_id`.",[3]="",[4]="A message must have the key `event`, being a string that is sent to the process as its event.",[5]="",[6]="This can be any arbritrary string - handled by the process that receives it.",[7]=""},children={}},[3]={level=3,text="[response]",content={[1]="",[2]="Optional argument",[3]="",[4]="By setting `[response]` to `true`, it causes the function to stall the entire program until it receives a response from the other process.",[5]="",[6]="Note that blocking in this way can be quite slow - it is intended to be used in situations where it is acceptable to skip a frame or two while waiting for a reply.",[7]="",[8]="When `[response]` is a function, the event handler of the receiving process can reply with another message that is handled by that function.",[9]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="> From the Picotron Manual",[3]="",[4]="When reply is true, send_message blocks until the process responds with a reply. For example, paste the following in to terminal to set up a headless process that responds to \"get_id\" messages:",[5]="",[6]="```lua",[7]="store(\"/ram/get_id.lua\", [[",[8]="    id = 1",[9]="    function _update() end",[10]="    on_event(\"get_id\", function() ",[11]="        id += 1",[12]="        return {id = id} ",[13]="    end)",[14]="]])",[15]="pid2 = create_process(\"/ram/get_id.lua\")",[16]="```",[17]="",[18]="A unique id can be fetched from this process with:",[19]="",[20]="```lua",[21]="?send_message(pid2, {event = \"get_id\"}, true).id",[22]="```",[23]="",[24]="The true argument for `[response]` causes the message to be blocking - waiting for the response from `pid2`, being the data including the `id` it requests.",[25]=""},children={}},[4]={level=2,text="Sandboxed Nature",content={[1]="",[2]="Sandboxed processes can send messages to:",[3]="",[4]="* itself",[5]="* /system/",[6]="* wm",[7]="",[8]="alongside sending certain events:",[9]="",[10]="* \"set_palette\"",[11]="* \"broadcast\" *if* it has a contained event of `set_palette`",[12]=""},children={}},[5]={level=2,text="Returns",content={[1]="",[2]="This function returns nothing, unless you have a response, where it instead returns the response of the event."},children={}}}}}},[115]={name="main.md",path="/picotron_api/functions/rm/main.md",data={[1]={level=1,text="rm(f0)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`rm` deletes `f0`, a file or directory (including all of the directory's contents).",[3]="",[4]="Attempting to delete `/desktop/host` just causes the Host OS to unmount, rather than deleting the folder and contents.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="f0",content={[1]="",[2]="The path to the file or directory to delete",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="Returns something, unknown what it returns"},children={}}}}}},[116]={name="main.md",path="/picotron_api/functions/print/main.md",data={[1]={level=1,text="print(str,x,y,color)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This prints text to the active display of Picotron.",[3]="",[4]="When there is no graphical display, e.g: Picotron is running headless (no display), or there is no window setup - this feeds to the [`printh`](/picotron_api/functions/printh/main.md) function.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="str",content={[1]="",[2]="String to print",[3]=""},children={}},[2]={level=3,text="x,y",content={[1]="",[2]="The top left position of the text that is printed",[3]=""},children={}},[3]={level=3,text="color",content={[1]="",[2]="The index of the color in the color palette to draw the text in.",[3]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="Prints the CPU usage in the top left of the screen in the color white (`7`)",[3]="",[4]="```lua",[5]="function _update()",[6]="    print(stat(1)*100 ..\"% cpu usage\",0,0,7)",[7]="end",[8]="```",[9]=""},children={}},[4]={level=2,text="Returns",content={[1]="",[2]="Returns the ending x & y coordinate of the text that is printed.",[3]="```lua",[4]="fx,fy=print(\"hi\")",[5]="```",[6]=""},children={}}}}}},[117]={name="main.md",path="/picotron_api/functions/printh/main.md",data={[1]={level=1,text="printh(str)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="printh() allows for you to print text to the Host OS Terminal.",[3]="",[4]="This allows for you to do more informative debugging of your program, alongside allowing stuff like logs in your program.",[5]="",[6]="[Setting up a Host OS terminal for Picotron](/guides/host_os_terminal/main.md)",[7]="",[8]="Source: [source.lua](source.lua)",[9]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="str",content={[1]="",[2]="String to print",[3]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="Prints the CPU usage every time the frame updates",[3]="```lua",[4]="function _update()",[5]="    printh(stat(1)*100 ..\"% cpu usage\")",[6]="end",[7]="```",[8]=""},children={}},[4]={level=2,text="Returns",content={[1]="",[2]="Unknown"},children={}}}}}},[118]={name="main.md",path="/picotron_api/functions/pid/main.md",data={[1]={level=1,text="pid()",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`pid` returns the process id of the process calling it.",[3]="",[4]="This is useful for communication between processes",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Usage Example",content={[1]="",[2]="Using the filenav with the intention to save a file.",[3]="",[4]="```lua",[5]="create_process(\"/system/apps/filenav.p64\", {",[6]="    open_with = pid(), --shows the id of the process that opened it",[7]="    intention = \"save_file_as\",",[8]="    path=\"/desktop/\",",[9]="    use_ext=\"spr\",",[10]="    window_attribs = {",[11]="        workspace=\"current\",",[12]="        autoclose=true",[13]="    }",[14]="})",[15]="```",[16]=""},children={}},[3]={level=2,text="Returns",content={[1]="",[2]="The process ID"},children={}}}}}},[119]={name="main.md",path="/picotron_api/functions/mv/main.md",data={[1]={level=1,text="mv(src_p, dest_p)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`mv` moves the file or folder from `src_p` to `dest_p`.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={}},[3]={level=2,text="src_p",content={[1]="",[2]="The path to the source file/folder",[3]=""},children={}},[4]={level=2,text="dest_p",content={[1]="",[2]="Path to a folder to put the source file/folder into",[3]=""},children={}},[5]={level=2,text="Returns",content={[1]="",[2]="If src is nil > \"could not resolve source path\"",[3]="If dest is nil > \"could not resolve destination path\"",[4]="If using a protocol (e.g: `bbs://`) > \"can not write to {protocol you attempted}://\"",[5]="",[6]="More returns are for other failures, unknown.",[7]=""},children={}},[6]={level=2,text="Future",content={[1]="",[2]="Ability to write to protocols"},children={}}}}}},[120]={name="main.md",path="/picotron_api/functions/mouse/main.md",data={[1]={level=1,text="mouse([new_mx,new_my])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`mouse` is used to get and set the positioning of the cursor relative to the window.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="new_mx",content={[1]="",[2]="The new x position of the mouse",[3]=""},children={}},[2]={level=3,text="new_my",content={[1]="",[2]="The new y position of the mouse",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]=""},children={[1]={level=3,text="mouse_x",content={[1]="",[2]="x-coordinate of the mouse",[3]=""},children={}},[2]={level=3,text="mouse_y",content={[1]="",[2]="y-coordinate of the mouse",[3]=""},children={}},[3]={level=3,text="mouse_b",content={[1]="",[2]="a bitfield:",[3]="",[4]="* 0x1 left mouse button",[5]="* 0x2 right mouse button",[6]="* 0x4 middle mouse button",[7]=" "},children={}},[4]={level=3,text="wheel_x",content={[1]="",[2]="The amount scrolled on the scrollwheel in the x-axis",[3]=""},children={}},[5]={level=3,text="wheel_y",content={[1]="",[2]="The amount scrolled on the scrollwheel in the y-axis",[3]=""},children={}}}},[4]={level=2,text="Examples",content={[1]="",[2]="Get the properties of the mouse & print when you left click or right click.",[3]="```lua",[4]="function _update()",[5]=" mouse_x, mouse_y, mouse_b, wheel_x, wheel_y = mouse()",[6]=" if (mouse_b&0x1==0x1) then",[7]="  print(\"left click!\")",[8]=" end",[9]=" if (mouse_b&0x2==0x2) then",[10]="  print(\"right click!\")",[11]=" end",[12]="end",[13]="```",[14]=""},children={}},[5]={level=2,text="Limitations",content={[1]="",[2]="The mouse() function does not allow you to set full properties of the mouse.",[3]="",[4]="This can be fixed using the following snippet to have access to the full mouse properties.",[5]="",[6]="```lua",[7]="--@astralsparv",[8]="function setMouse(x,y,b)",[9]="    send_message(3,{event=\"mouse\",mx=x,my=y,mb=b or 0})",[10]="end",[11]="```",[12]=""},children={}}}}}},[121]={name="main.md",path="/picotron_api/functions/mkdir/main.md",data={[1]={level=1,text="mkdir(p)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`mkdir` creates a new directory (empty folder) at the path `p`",[3]="",[4]="This does not support protocols (e.g: bbs://)",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="p",content={[1]="",[2]="The path for the new directory",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="This function returns an error in the form of a string if the function fails.",[3]="Otherwise, returns nil",[4]=""},children={}},[4]={level=2,text="Future",content={[1]="",[2]="Ability to write to protocols"},children={}}}}}},[122]={name="main.md",path="/picotron_api/functions/menuitem/main.md",data={[1]={level=1,text="menuitem",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`menuitem` lets you edit the drop down menu on the window / context menu of the window.",[3]="",[4]="This has multiple different argument setups.",[5]="Source: [source.lua](source.lua)",[6]=""},children={}}}},[2]={level=1,text="menuitem()",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Leaving the function with no arguments clears the menu of its items",[3]=""},children={}},[2]={level=2,text="Returns",content={[1]="",[2]="Returns nothing",[3]=""},children={}}}},[3]={level=1,text="menuitem(m)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Picotron method for menu items, more capability than the legacy support p8 method",[3]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="m",content={[1]="",[2]="Setting this to `---` creates a divider menu item",[3]="",[4]="Otherwise modifies the menu through `m` acting as a table.",[5]="",[6]="`m` having the following values can have different effects:",[7]=""},children={[1]={level=4,text="id",content={[1]="",[2]="Sets the ID of the item, replaces any item with this id with this.",[3]=""},children={}},[2]={level=4,text="label",content={[1]="",[2]="The text to display as the option",[3]="",[4]="A lack of label causes the item to be deleted",[5]=""},children={}}}}}},[3]={level=2,text="Returns",content={[1]="",[2]="Returns nothing"},children={}}}}}},[123]={name="main.md",path="/picotron_api/functions/memmap/main.md",data={[1]={level=1,text="memmap(ud,addr,[offset],[len])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`memmap` allows you to write a 4k (`0x1000`) userdata, `ud` to an address, `addr` in memory",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="ud",content={[1]="",[2]="The userdata that is mapped into memory",[3]=""},children={}},[2]={level=3,text="addr",content={[1]="",[2]="The address to map the userdata into",[3]="",[4]="Mapping to address `0x100000` automatically unmaps the loaded map data & replacing the loaded map in memory with `ud`.",[5]=""},children={}},[3]={level=3,text="[offset]",content={[1]="",[2]="Unknown",[3]="",[4]="> Presuming that it's the offset in either memory in the userdata",[5]=""},children={}},[4]={level=3,text="[len]",content={[1]="",[2]="Unknown",[3]="",[4]="> Presuming that it's the length of the userdata"},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="Returns the inputted `ud`",[3]="",[4]="Allows things such as:",[5]="",[6]="```",[7]="pfxdat = fetch(\"tune.sfx\"):memmap(0x30000)",[8]="```"},children={}}}}}},[124]={name="main.md",path="/picotron_api/functions/map/main.md",data={[1]={level=1,text="map(ud, [b], [...])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`map` draws a map, either through picotron system or legacy pico-8 method",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Picotron System",content={[1]=""},children={[1]={level=3,text="ud",content={[1]="",[2]="The map data in the datatype `userdata`",[3]="",[4]="If `ud` is not in the datatype `userdata`, it follows the legacy Pico-8 format.",[5]=""},children={}},[2]={level=3,text="[b]",content={[1]="",[2]="Unknown",[3]=""},children={}},[3]={level=3,text="[...]",content={[1]="",[2]="Extra arguments that are sent through to the system _draw_map function.",[3]=""},children={}},[4]={level=3,text="> Returns",content={[1]="",[2]="This function does not return anything",[3]=""},children={}}}},[3]={level=2,text="Legacy Pico-8 System",content={[1]="",[2]="The legacy Pico-8 system is added for legacy support and an alternative way to use maps.",[3]="",[4]="Legacy Pico-8 function",[5]="",[6]="`map(celx, cely, sx, sy, celw, celh, [layer])`",[7]=""},children={[1]={level=3,text="celx",content={[1]="",[2]="The column location of the map cell in the upper left corner of the region to draw, where 0 is the leftmost column.",[3]=""},children={}},[2]={level=3,text="cely",content={[1]="",[2]="The row location of the map cell in the upper left corner of the region to draw, where 0 is the topmost row.",[3]=""},children={}},[3]={level=3,text="sx",content={[1]="",[2]="The x coordinate of the screen to place the upper left corner.",[3]="",[4]=""},children={}},[4]={level=3,text="sy",content={[1]="",[2]="The y coordinate of the screen to place the upper left corner.",[3]=""},children={}},[5]={level=3,text="celw",content={[1]="",[2]="The number of map cells wide in the region to draw.",[3]=""},children={}},[6]={level=3,text="celh",content={[1]="",[2]="The number of map cells tall in the region to draw.",[3]=""},children={}},[7]={level=3,text="[layer]",content={[1]="",[2]="If specified, only draw sprites that have flags set for every bit in this value (a bitfield). The default is 0 (draw all sprites).",[3]=""},children={}}}},[4]={level=2,text="Returns",content={[1]="",[2]="This function does not return anything"},children={}}}}}},[125]={name="main.md",path="/picotron_api/functions/include/main.md",data={[1]={level=1,text="include(filename)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="The `include` function allows you to attach scripting files to your program (`lua`).",[3]="",[4]="If the source has a syntax error, it reports errors to the console, listing the syntax error and location",[5]="If the source file is not a text file, it notifies that it cannot include it.",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="filename",content={[1]="",[2]="The relative or absolute path to the file.",[3]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="Example `module.lua` which returns a version number and creates two helper functions for drawing sprites.",[3]="",[4]="```lua",[5]="function sprFlippedX(s,x,y)",[6]="    spr(s,x,y,true)",[7]="end",[8]="",[9]="function sprFlippedY(s,x,y)",[10]="    spr(s,x,y,nil,true)",[11]="end",[12]="",[13]="return \"1.0\"",[14]="```",[15]="",[16]="Cartridge that includes this",[17]="",[18]="```lua",[19]="local version=include(\"module.lua\")",[20]="if (version != latestVersion){",[21]="    notify(\"module.lua is not the running the latest version.\")",[22]="}",[23]="",[24]="sprFlippedX(1,0,0)",[25]="```",[26]="",[27]="This warns you if the version is not the latest version (e.g: taken from a webpage), then proceeds to draw sprite 1 at 0,0 using the helper function.",[28]=""},children={}},[4]={level=2,text="Returns",content={[1]="",[2]="Returns `func()`, so that the imported file can return something - this also runs the file with `func()`",[3]="256 file limit > `nil`",[4]="Can't fetch the file > `nil`",[5]=""},children={}},[5]={level=2,text="Limitations",content={[1]="",[2]="There is an arbritrary limit where only 256 of the same files can be included."},children={}}}}}},[126]={name="main.md",path="/picotron_api/functions/get_spr/main.md",data={[1]={level=1,text="get_spr(index)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`get_spr` returns the sprite information of the sprite at `index`.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="index",content={[1]="",[2]="The sprite index of which you want the information",[3]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="This returns the `userdata u8` graphical data of the sprite at sprite `index`."},children={}}}}}},[127]={name="main.md",path="/picotron_api/functions/create_process/main.md",data={[1]={level=1,text="create_process(prog_name_p, [env_patch])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`create_process` runs a process, `prog_name_p`, with optional env data patched in through `[env_patch]`;",[3]="",[4]="This can be done to package multiple pieces of software into one, alongside allowing for multi-process software.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="prog_name_p",content={[1]="",[2]="The filepath to the file of which to create a process from.",[3]="",[4]="This is typically a picotron cartridge or a `.lua` file.",[5]=""},children={}},[2]={level=3,text="[env_path]",content={[1]="",[2]="Optional argument",[3]="",[4]="This allows you to patch environmental information to the process in the form of a table.",[5]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="This creates a process, running `app.p64` where `app.p64` prints the text that was fed into it.",[3]="",[4]="When this process runs `env()`, it contains the argument `text`.",[5]="",[6]="```lua",[7]="create_process(\"app.p64\",{text=\"Hi!\"})",[8]="```",[9]="",[10]="Within `app.p64`:",[11]="",[12]="```lua",[13]="print(env().text);",[14]="```",[15]=""},children={}},[4]={level=2,text="Sandboxed Nature",content={[1]="",[2]="Sandboxed apps can only create processes of:",[3]="",[4]="* /system/apps/filenav.p64",[5]="* /system/apps/notebook.p64",[6]="* /system/util/open.lua",[7]="* /system/util/ls.lua",[8]="* files stored within the sandboxed app",[9]="* apps from `bbs://`",[10]="",[11]="All apps run through this are also sandboxed",[12]=""},children={}},[5]={level=2,text="Returns",content={[1]="",[2]="This function returns the process id of the created process & an error string.",[3]="",[4]="If the process created is a process that they cannot create > nil, \"sandboxed process can not create_process()\"",[5]="",[6]="If the process creates more than 20 processes in a single minute > return nil, \"sandboxed process can not create_process() more than 20 / minute\""},children={}}}}}},[128]={name="main.md",path="/picotron_api/functions/cp/main.md",data={[1]={level=1,text="cp(src_p, dest_p)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`cp` copies the file or folder from `src_p` to the location `dest_p`.",[3]="",[4]="If `dest_p` is a file, it overwrites the file.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={}},[3]={level=2,text="src_p",content={[1]="",[2]="The path to the source file/folder",[3]=""},children={}},[4]={level=2,text="dest_p",content={[1]="",[2]="Path to a folder/file to replace",[3]=""},children={}},[5]={level=2,text="Returns",content={[1]="",[2]="If src is nil > \"could not resolve source path\"",[3]="If dest is nil > \"could not resolve destination path\"",[4]="If using a protocol (e.g: `bbs://`) > \"can not write to {protocol you attempted}://\"",[5]="",[6]="Other failures:",[7]="    fstat of the source fails > \"could not read source location\"",[8]="    copying a folder inside of itself > \"can not copy inside self\"",[9]="    copying `/` inside of itself > \"can not copy /\"",[10]=""},children={}},[6]={level=2,text="Future",content={[1]="",[2]="Ability to write to protocols"},children={}}}}}},[129]={name="main.md",path="/picotron_api/functions/cls/main.md",data={[1]={level=1,text="cls([color])",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="`cls` clears the draw target by filling it with a color",[3]="",[4]="Often used in `_draw()` at the start of the frame to flush the previous frame.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="[color]",content={[1]="",[2]="Defaults to 0 (black)",[3]="",[4]="The color to draw to the draw target",[5]=""},children={}}}},[3]={level=2,text="Returns",content={[1]="",[2]="Unknown"},children={}}}}}},[130]={name="main.md",path="/picotron_api/functions/camera/main.md",data={[1]={level=1,text="camera(x,y)",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="camera() allows for you to set the relative 0,0 of all graphical operations.",[3]="",[4]="Source: [source.lua](source.lua)",[5]=""},children={}},[2]={level=2,text="Arguments",content={[1]=""},children={[1]={level=3,text="x",content={[1]="",[2]="x coordinate to set",[3]=""},children={}},[2]={level=3,text="y",content={[1]="",[2]="y coordinate to set",[3]=""},children={}}}},[3]={level=2,text="Examples",content={[1]="",[2]="Sets a player object to be in the middle of the screen",[3]="```lua",[4]="",[5]="--player object",[6]="player={",[7]="    x=0,",[8]="    y=0",[9]="}",[10]="",[11]="--set the player to be in the middle of the screen",[12]="",[13]="screen={",[14]="    width=480,",[15]="    height=270",[16]="}",[17]="",[18]="function _update()",[19]="    camera={",[20]="        x=player.x-(screen.width/2),",[21]="        y=player.y-(screen.height/2),",[22]="    }",[23]="",[24]="    camera(x,y)",[25]="end",[26]="```",[27]="",[28]="This can be paired with `mid()` to clamp it to the viewable area, e.g: the map.",[29]=""},children={}},[4]={level=2,text="Returns",content={[1]="",[2]="Returns the previous camera's x,y positions."},children={}}}}}},[131]={name="readme.md",path="/information/readme.md",data={[1]={level=1,text="Picotron Information",content={[1]="",[2]="[Roadmap](roadmap.md)",[3]="",[4]="[What Is Picotron](whatis.md)"},children={}}}},[132]={name="roadmap.md",path="/information/roadmap.md",data={[1]={level=3,text="from the [main page](https://www.lexaloffle.com/picotron.php?page=roadmap)",content={[1]=""},children={}},[2]={level=1,text="Picotron Roadmap",content={[1]=""},children={[1]={level=2,text="Picotron 0.0: \"Playground\" (2022 Q4)",content={[1]="",[2]="// Open-access web build for testing (became unavailable at 0.1)",[3]="",[4]="Architecture	// File system, system events, memory mapping, wm",[5]="",[6]="GFX Pipeline	// Colour tables, draw state",[7]="",[8]="API	// Based on Lua 5.4, compatible w/ PICO-8 where possible",[9]="",[10]="CPU	// Find costs that roughly match slowest hosts",[11]="",[12]="Audio	// Synthesizer runtime & test carts",[13]="",[14]="** offline for now, but will come back later in some form",[15]=""},children={}},[2]={level=2,text="Picotron 0.1 (~~2023~~ 2024-03-14)",content={[1]="",[2]="",[3]="Binary Builds	// Windows, Mac, Linux",[4]="",[5]="Editors	// Code, Pixels, Maps, Synth Designer, Tracker",[6]="",[7]="Desktop	// Run window-based programs, file management gui",[8]="",[9]="Customisation	// Theme editor, wallpapers, screensavers",[10]="",[11]="File Formats	// Plain-text .p64, Binary .p64.rom, Shareable .p64.png",[12]="",[13]="HTTP GET	// From local apps and exports only; not BBS carts",[14]="",[15]="BBS Integration	// Submit carts to a sub-forum, load # directly from bbs",[16]="",[17]="Sandboxing	// Safe to run untrusted carts without exposing Picotron drive",[18]="",[19]="HTML Exporter	// .wasm runtime + bundled cartridge, licensed similar to P8",[20]=""},children={}},[3]={level=2,text="Picotron 0.2 (~~2024~~ 2025-03-14)",content={[1]="",[2]="",[3]="Binary Exporters	// Windows, Mac, Linux -- includes desktop export",[4]="",[5]="bbs://	// [in 0.1.1e] Cross-platform bbs access; handles caching / offline access",[6]="",[7]="Tooltray	// [in 0.1.1e] Install widgets into the tooltray that can run sandboxed",[8]=""},children={}},[4]={level=2,text="Picotron 0.2.0* (2025-Q2/Q3)",content={[1]="",[2]="Raspi 64-bit	// Requires raspi 3 or later",[3]="",[4]="UDP / TCP sockets	// For binaries / exports",[5]="",[6]="GFX API	// rrect, P8SCII outline / underline",[7]="",[8]="Headless Programs	// interactive terminal apps, background processes",[9]="",[10]="Spritesheet Importer	// load from png / p8",[11]=""},children={}},[5]={level=2,text="Picotron 0.2.1 (2025-10)",content={[1]="",[2]="",[3]="Anywhen	// Fetch files and directory listings from any point in time",[4]="",[5]="File System	// sandboxing, mounting, robustness improvements",[6]="",[7]="Unsaved Changes	// monitor at the cart / file level and confirm overwrites etc",[8]="",[9]="Events	// non-blocking fetch(), blocking send_message(), custom mainloops",[10]=""},children={}},[6]={level=2,text="Picotron 0.2.2 (2025-11)",content={[1]="",[2]="Splore",[3]=""},children={}},[7]={level=2,text="Picotron 0.2.3 (2025-12)",content={[1]="",[2]="",[3]="Logins	// User can log in with bbs account, apps can read username",[4]="",[5]="podnet://	// User-wise public storage that can be used by sandboxed apps",[6]="",[7]="flp.io	// Bucket naming service; allows publishing podnet websites",[8]="",[9]="Cart switching	// BBS carts can load & run other BBS carts",[10]=""},children={}},[8]={level=2,text="Picotron 0.2.4 (2026-01)",content={[1]="",[2]="",[3]="Video Modes	// Support for extra fullscreen video modes",[4]="",[5]="Native Windows	// Export carts that run directly in a native host window",[6]="",[7]="Export Headless	// Export commandline programs",[8]=""},children={}},[9]={level=2,text="Picotron 0.3 [beta] (2026-03-14)",content={[1]="",[2]="BBS highscores	// Submit scores + extra data while logged in",[3]="",[4]="Websockets	// For exports [and bbs carts] on all platforms",[5]=""},children={}},[10]={level=2,text="Picotron 0.?",content={[1]="",[2]="// ongoing projects / no ETA",[3]="",[4]="Log Navigation	// Browse logs by category: notifications, errors, system crash etc",[5]="",[6]="Gui Builder	// Gui card editor and data format integrated with create_gui",[7]="",[8]="Libraries	// Standard fonts, instruments, fill patterns, palettes",[9]="",[10]="Stickers	// A general tagging and bookmarking scheme (experimental)",[11]="",[12]="Tool Improvements	// Miscelaneous features for bundled tools & accessories",[13]="",[14]="PFX6416 Features	// pcm instrument type, sfx instruments, channel-fx envelope control",[15]=""},children={}},[11]={level=2,text="Picotron 1.0",content={[1]="",[2]="Runtime / API Freeze	",[3]="",[4]="Extra Bundled Software	",[5]="",[6]="Runtime source exporting (export foo.src)	",[7]="",[8]="// Exported runtime licensing is TBD, but the focus will be on allowing cart authors to",[9]="",[10]="// implement additional platform support or custom features for their own projects."},children={}}}}}},[133]={name="whatis.md",path="/information/whatis.md",data={[1]={level=3,text="from the [main page](https://www.lexaloffle.com/picotron.php)",content={[1]=""},children={}},[2]={level=1,text="What is Picotron?",content={[1]="",[2]="Picotron is a Fantasy Workstation: a self-contained creative environment built for imaginary hardware. Create and share cute Lua apps that can run on the Picotron desktop, be shared as cartridge files, or exported as stand-alone HTML and binary distributables.",[3]=""},children={}},[3]={level=1,text="Specifications",content={[1]=""},children={[1]={level=2,text="Display: 480x270",content={[1]="",[2]="Picotron comes with a 480x270 64-colour display, which can also run at 240x135 or 160x90 and with custom palettes in fullscreen mode. The built-in graphics api gives versatile low-level access to the display, with features like 8x8 fill patterns, palette swapping and blending, stencil bits and tline3d for rasterizing perspective correct textures.",[3]=""},children={}},[2]={level=2,text="Cosy Filesystem",content={[1]="",[2]="Picotron uses a virtual filesystem that only exposes parts of your host system as needed. All files inside Picotron are in a special format (POD: Picotron Object Data) that allows Lua tables to be directly stored and fetched from disk. Storing data like save games and level data is simple: bundle everything into a Lua table and store() it as a pod.",[3]=""},children={}},[3]={level=2,text="Audio: PFX6416",content={[1]="",[2]="All of the audio in Picotron is generated in realtime by a purpose-built 64-node, 16 channel synthesizer called PFX6416. Nodes can either generate a signal from a wavetable, or modify it using FM/RING modulation, delay, HP/LP resonant filters and wave-shaping. Instruments and music/tracker data in Picotron are extremely tiny on disk; a piece of music with custom instrument design can be stored in 5~20k.",[3]=""},children={}},[4]={level=2,text="8M inst/sec",content={[1]="",[2]="Picotron uses a separate (slightly modified) Lua 5.4 vm per \"process\", and virtual cpu is divided up between processes for a maximum of 8M vm instructions per second. This means that Picotron cartridges can run at a consistent speed across varying platforms; if it runs ok on a high-end desktop machine, it will look roughly the same running under web on an old netbook.",[3]=""},children={}},[5]={level=2,text="256K Cartridges",content={[1]="",[2]="Applications, projects and distributable bundles are all the same type of thing in Picotron: a cartridge. Each cartridge acts like a regular folder and contains all of the source files and resources needed to run the program. On the host system it is stored as a single git-friendly text file (.p64: any size that fits in ram), or a shareable png format (.p64.png: max 256k of ROM data).",[3]=""},children={}}}},[4]={level=1,text="More information",content={[1]=""},children={[1]={level=2,text="Fantasy Desktop",content={[1]="",[2]="![Fantasy Desktop](https://www.lexaloffle.com/gfx/fantasy_desktop.gif)",[3]="",[4]="Picotron comes with a cute desktop interface featuring tabbed workspaces and a fold-out tooltray that is accessible from any workspace. The tooltray acts as a second desktop for handy access to frequently used files and widgets. Files can also be dropped on top of each other to form tidy stacks that are shuffleable with the mousewheel.",[5]=""},children={}},[2]={level=2,text="Bundled Tools",content={[1]="",[2]="![Bundled Tools](https://www.lexaloffle.com/gfx/picotron_bamboo.gif)",[3]="",[4]="Use the built-in editors or create your own! The included editors for code, graphics, tile maps, music and sound effects are themselves all made in Picotron and use standard /system/lib libraries for handling things like unlimited undo stacks, gui, and file management.",[5]=""},children={}},[3]={level=2,text="Customise your Workstation",content={[1]="",[2]="![Picotron Desktop](https://www.lexaloffle.com/dl/wip/picotron_desktop2.png)",[3]="",[4]="Make your own live wallpapers, screensavers, icons, widgets, and set up workflows just the way you like! Or have a look around the BBS to see what other cartridge authors are up to.",[5]="",[6]="> Example Wallpaper by [castpixel](https://twitter.com/castpixel)",[7]=""},children={}},[4]={level=2,text="Next Generation Fantasy Hardware",content={[1]="",[2]="![Picotron Bunny](https://www.lexaloffle.com/gfx/picotron_bunny.gif)",[3]="",[4]="Picotron is built on tightly integrated, flexible graphics and audio pipelines that can happily run on low powered host machines and web. They each come with a simple-to-use API for handling common things like drawing a colour-swapped sprite or triggering a sound effect, but the underlying data and machine state is all exposed in virtual RAM, offering a myriad of possibilities for those willing to venture down the rabbithole.",[5]=""},children={}}}},[5]={level=1,text="Status: Alpha",content={[1]="Picotron 0.2 is still new, but has a relatively complete API, binary and HTML exporters and BBS cartridge browsing. See the roadmap for future plans:",[2]="",[3]="[Roadmap](roadmap.md)"},children={}}}},[134]={name="readme.md",path="/guides/readme.md",data={[1]={level=1,text="guides",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Guides for development in Picotron",[3]="",[4]="[Writing a simple grid-based game](/guides/grid_based_game/main.md)",[5]="",[6]="[Using a Host OS terminal with Picotron](/guides/host_os_terminal/main.md)",[7]="",[8]="[Using the BBS](/guides/bbs/main.md)",[9]="",[10]="[Creating a Cartridge](/guides/creating_a_cart/main.md)",[11]="",[12]="[Default Apps](/guides/default_apps/main.md)",[13]="",[14]="[Desktop Customisation](/guides/desktop_customisation/main.md)",[15]="",[16]="[Exporting](/guides/exports/main.md)",[17]="",[18]="[Keyboard Layout](/guides/keyboard_layout/main.md)",[19]="",[20]="[Terminal Commands](/guides/terminal_commands/main.md)"},children={}}}}}},[135]={name="main.md",path="/guides/terminal_commands/main.md",data={[1]={level=1,text="Terminal Commands",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html).",[3]="",[4]="This displays example usage of commands you can use in the terminal.",[5]="",[6]="Note that a \"directory\" is a folder.",[7]=""},children={}},[2]={level=2,text="Commands",content={[1]=""},children={[1]={level=3,text="`ls`",content={[1]="List the current directory",[2]=""},children={}},[2]={level=3,text="`cd foo`",content={[1]="change directory (e.g. `cd /desktop`)",[2]=""},children={}},[3]={level=3,text="`mkdir foo`",content={[1]="create a directory ",[2]=""},children={}},[4]={level=3,text="`folder`",content={[1]="open the current directory in your Host OS",[2]=""},children={}},[5]={level=3,text="`open .`",content={[1]="open the current directory in filenav",[2]=""},children={}},[6]={level=3,text="`open fn`",content={[1]="open a file with an associated editor",[2]=""},children={}},[7]={level=3,text="`rm filename`",content={[1]="remove a file or directory (be careful!)",[2]=""},children={}},[8]={level=3,text="`cp f0 f1`",content={[1]="copy file / directory from f0 to f1",[2]=""},children={}},[9]={level=3,text="`mv f0 f1`",content={[1]="move file / directory from f0 to f1",[2]=""},children={}},[10]={level=3,text="`info`",content={[1]="information about the current cartridge",[2]=""},children={}},[11]={level=3,text="`load cart`",content={[1]="load a cartridge into /ram/cart",[2]=""},children={}},[12]={level=3,text="`save cart`",content={[1]="save a cartridge ",[2]=""},children={}}}},[3]={level=2,text="Custom Commands",content={[1]="",[2]="To create your own terminal commands, put `.p64` or `.lua` files in `/appdata/system/util`.",[3]="",[4]="When a command is used from commandline (e.g. [`ls`](/system/details/util/ls/main.md)), terminal first looks for it in `/system/util` and `/system/apps`, before looking in `/appdata/system/util` and finally the current directory for a matching `.lua` or `.p64` file.",[5]="",[6]="The present working directory when a program starts is the same directory as the program's entry point (e.g. where main.lua is, or where the stand-alone Lua file is). This is normally not desireable for commandline programs, which can instead change to the directory the command was issued from using env().path. For example:",[7]="",[8]="```lua",[9]="cd(env().path)",[10]="print(\"args: \"..pod(env().argv))",[11]="print(\"pwd: \"..pwd())",[12]="```",[13]="",[14]="Save it as `/appdata/system/util/foo.lua`, and then run it from anywhere by typing \"foo\"."},children={}}}}}},[136]={name="readme.md",path="/guides/short_snippets/readme.md",data={[1]={level=1,text="guides > short snippets",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Short code snippets rather than full guides",[3]=""},children={}}}}}},[137]={name="main.md",path="/guides/keyboard_layout/main.md",data={[1]={level=1,text="Keyboard Layout",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html).",[3]="",[4]="This goes over how keyboard inputs are handled, and changing them.",[5]=""},children={}},[2]={level=2,text="Input",content={[1]="",[2]="Text input (using @peektext() / @readtext()) defaults to the host OS keyboard layout / text entry method.",[3]="",[4]="Key states used for things like CTRL-key shortcuts (e.g. [key(\"ctrl\")](/picotron_api/functions/key/main.md) and [keyp(\"c\")](/picotron_api/functions/keyp/main.md)) are also mapped to the host OS keyboard layout by default.",[5]=""},children={}},[3]={level=2,text="Configuring keycodes",content={[1]="",[2]="The keyboard layout can be further configured by creating a file called `/appdata/system/keycodes.pod` which assigns each keyname to a new scancode. The raw names of keys (same as US layout) can alternatively be used on the RHS of each assignment, as shown in this example that patches a US layout with AZERTY mappings:",[3]="",[4]="```lua",[5]="store(\"/appdata/system/keycodes.pod\", {a=\"q\",z=\"w\",q=\"a\",w=\"z\",m=\";\",[\";\"]=\",\",[\",\"]=\"m\"})",[6]="```",[7]="",[8]="You probably do not need need to do this! The default layout should work in most cases. ",[9]="",[10]="Raw scancodes themselves can also be remapped in a similar way using /appdata/system/scancodes.pod, but is also normally not needed. The raw mapping is used in situations where the physical location  of the key matters, such as the piano-like keyboard layout in the tracker. See /system/lib/events.lua  for more details."},children={}}}}}},[138]={name="main.md",path="/guides/host_os_terminal/main.md",data={[1]={level=1,text="Using a Host OS terminal in Picotron",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This is a short guide designed to show you how to setup an environment to use [`printh`](/picotron_api/functions/printh/main.md) for debugging or logging.",[3]=""},children={}},[2]={level=2,text="Windows:",content={},children={[1]={level=3,text="Step 1. Getting the path of your Picotron executable",content={[1]="",[2]="This is typically found at `C:\\\"Program Files (x86)\\\"Picotron\\\"picotron.exe` if you installed it, otherwise in the extracted folder if you are using the portable version of Picotron.",[3]="",[4]="If it is not in this location, you can:",[5]="* open the start menu",[6]="* type Picotron",[7]="* press open file location",[8]="* click Picotron's executable",[9]="* press `CTRL+SHIFT+C` to copy the path",[10]=""},children={}}}},[3]={level=2,text="Step 2. Creating the batch file",content={[1]="",[2]="Now that you have the path, all you have to do is open any text editor and paste in the path, e.g:",[3]="`\"C:\\\"Program Files (x86)\\\"Picotron\\\"picotron.exe\"`",[4]="",[5]="You must ensure that there are double quotes `\"` surrounding the path as seen above.",[6]="",[7]="Save this file with the `.bat` extension, e.g: `picotron.bat`.",[8]=""},children={}},[4]={level=2,text="Step 3. Running the batch file",content={[1]="",[2]="Now once you run this batch file (the same as you would an exe), it will open up a terminal alongside Picotron.",[3]="",[4]="When anything is printed to the terminal with `printh`, it will now appear in your host OS terminal.",[5]=""},children={}}}}}},[139]={name="main.md",path="/guides/exporting/main.md",data={[1]={level=1,text="Exporting",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html)",[3]="",[4]="This goes over the different formats for exports alongside how to export cartridges.",[5]=""},children={}},[2]={level=2,text="Exporting a PNG",content={[1]="",[2]="To save a copy of the currently loaded cartridge in .p64.png format (without making it the new ",[3]="working cartridge), press ctrl-7 while running the cartridge to capture a label and then:",[4]="",[5]="```",[6]="> export foo.p64.png",[7]="```",[8]="",[9]="Cartridges in .p64.png format can have up to 256k of (compressed) rom data, and can be shared ",[10]="on the Lexaloffle BBS.",[11]=""},children={}},[3]={level=2,text="Exporting in HTML (a web export)",content={[1]="",[2]="Cartridges can be exported and shared as stand-alone html pages.",[3]="",[4]="To export the currently loaded cartridge as a single file:",[5]="",[6]="```",[7]="> export foo.html",[8]="```",[9]="",[10]="View the page by opening the folder and double clicking on it:",[11]="",[12]="```",[13]="> folder",[14]="```",[15]=""},children={[1]={level=3,text="HTML Export Size Limit",content={[1]="",[2]="The html exporter can handle carts that are up to 8MB in .p64.rom format (use [`info`](/system/details/util/info/main.md) command to check).",[3]="",[4]="Beyond that size, fetch() can be used to download more data as needed using [`stat(151)`](/picotron_api/functions/stat/main.md) to prepend the host and path the page is being served from: [`fetch(stat(151)..\"level2.pod\")`](/picotron_api/functions/fetch/main.md).",[5]=""},children={}}}},[4]={level=2,text="Exporting Binary Executables",content={[1]="",[2]="Binaries for Windows, Mac and Linux can be generated by exporting to a .bin folder:",[3]="",[4]="```",[5]="> export foo.bin",[6]="```",[7]="",[8]="A folder for each platform is generated for testing, along with zip files that are ready to distribute. It is recommended to distribute the zip files as-is instead of re-packing them, because they include file attribute bits that are set on the executable files when unzipped. For example, it is possible  to export from a Windows dev machine, and then a linux user can unzip and run the cart without needing to `chmod +x thegame`.",[9]=""},children={[1]={level=3,text="Icons",content={[1]="",[2]="The cartridge's 16x16 icon is used as the host file and window icon if one exists. Colour 0 is always taken to be transparent, and every other colour index is solid.",[3]=""},children={}},[2]={level=3,text="Extra Files",content={[1]="",[2]="Bundle files in the `.zip` output with `-e`:",[3]="",[4]="```",[5]="> cart -e readme.txt foo.bin",[6]="```",[7]="",[8]="When a folder is given instead of a file, the contents of that folder are flattened and saved in the root of the zip.",[9]="",[10]="To remove the metadata section of a text file so that it looks nicer outside of Picotron:",[11]="",[12]="```lua",[13]="> store_metadata(\"foo.txt\",{metadata_format=\"none\"})",[14]="```",[15]=""},children={}},[3]={level=3,text="Storing Data from a Binary Export",content={[1]="",[2]="store() data somewhere in \"/appdata/mygame\" as usual, and it will be persisted on the end user's machine. Exports use a separate home data folder on host so that they don't accidentally interfere with any regular Picotron installations. Instead of a home path (in linux) of:",[3]="",[4]="```",[5]="~/.lexaloffle/Picotron",[6]="```",[7]="",[8]="Exports by default all use:",[9]="",[10]="```",[11]="~/.lexaloffle/Picotron/exp/shared",[12]="```",[13]="",[14]="This means that exports can still read and write each other's /desktop, settings and other files. That is usually not a problem (and is sometimes desirable), but if additional separation is needed, add `export_home` to the cart's metadata:",[15]="",[16]="```lua",[17]="> store_metadata(\"/ram/cart\", {export_home = \"my_game_name\"}) ",[18]="```",[19]="",[20]="The exported cartridge will then have its own isolated home path, and can do things like mess up /desktop with low risk of interfering with other exports:",[21]="",[22]="```",[23]="~/.lexaloffle/Picotron/exp/my_game_name",[24]="```",[25]="",[26]="By using export_home, and bundling .p64.rom files inside the exported cartridge, it is possible to create software that uses the Picotron desktop environment. For example, suites of tools that boot up into their own customised desktop environments, or UI  story games that come with a desktop already populated with files and widgets.",[27]=""},children={}},[4]={level=3,text="Binary Export Size Limit",content={[1]="",[2]="The binary exporter can handle carts that are up to 32MB in .p64.rom format (use [`info`](/system/details/util/info/main.md) command to check). After exporting, additional data can also be stored in a folder called \"data\" in the same path as the executable. When this path exists, it is automatically mounted as `/host_data` on boot.",[3]="",[4]="Note that the `data/` folder is not automatically bundled into the distributable zip files, so for exports that need > 32MB of data, some extra work is needed to create distributables.",[5]=""},children={}},[5]={level=3,text="Native Window Exports",content={[1]="",[2]="Binary exports can run as a native window directly on the host desktop by using the `-n` switch:",[3]="",[4]="```",[5]="> export -n foo.bin",[6]="```",[7]="",[8]="Or set `export_native_window` to `true` in the cartridge metadata before exporting:",[9]="",[10]="```lua",[11]="> store_metadata(\"/ram/cart\", {export_native_window=true})",[12]="```",[13]="",[14]="This allows the cartridge's window and the host window to be one and the same thing.",[15]="There is no boot sequence, desktop, pause menu or message bar. When the program is finished, the host window immediately closes. Only a single userland process (4) can run in such an export, so features like [`open()`](/picotron_api/functions/open/main.md) and [`chooser()`](/picotron_api/functions/chooser/main.md) are also not available.",[16]="",[17]="Runtime errors also cause the window to close immediately, but the error is still logged to `{picotron home}/exp/shared/log.txt`.",[18]="",[19]="The virtual window resolution can be any size within Picotron limits, but may not change during runtime. The host window is resizeable and fullscreenable (alt+enter) as usual. Settings like stretch, pixel_perfect and pixel_scale are applied when storing changes to `/appdata/system/settings.pod`. Other window attributes like `.frameless`, `.moveable` and transparency are ignored by the host window.",[20]="",[21]="If no window is created by the exported cartridge, it will continue to run headless and all [`print()`](/picotron_api/functions/print/main.md) commands go to `stdout` (if there is one). The usual file system mounting rules apply though, so along with the startup time, it is not very useful for creating general commandline tools.",[22]=""},children={}}}},[5]={level=2,text="Cartridge Exporter Limitations",content={[1]="",[2]="1. Exported cartridges can not load and run other cartridges that were not part of the export.",[3]="",[4]="The exporters are targetted at authors wishing to export and distribute their own work, and this limitation aims to reduce unwanted exploitation of the Picotron ecosystem.",[5]="",[6]="It is still possible to bundle many .p64.rom cartridges together inside an export and run them with [`create_process()`](/picotron_api/functions/create_process/main.md); just make sure you have permission from all of the included cartridges' authors first.",[7]="",[8]="2. When exporting fullscreen cartridges, the user can not access the Picotron desktop, terminal, or other parts of the system. To enable escaping the fullscreen workspace using `alt+L/R` or `Ctrl-P`: create the window with `can_escape_fullscreen` set to true: ",[9]="",[10]="```lua",[11]="window{can_escape_fullscreen = true}",[12]="```",[13]="",[14]="3. `bbs://` can not be used from exported cartridges.",[15]="",[16]="4. widgets, themes, screensavers and wallpapers are not loaded on boot, and are not selectable in the settings app from exported cartridges. This is to avoid exports that use the same default `exp/shared/` data from interfering with each other, including producing runtime version vs. cart version mismatches. Instead, a cart can optionally customise its own desktop each time it is run."},children={}}}}}},[140]={name="main.md",path="/guides/grid_based_game/main.md",data={[1]={level=1,text="Simple grid based game",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This is a short guide designed to teach you to create a simple game on a grid.",[3]=""},children={}},[2]={level=2,text="Step 1. Creating the sprites",content={[1]="",[2]="To begin, you should draw the following sprites:",[3]="",[4]="* a player",[5]="* a ground tile",[6]="* a solid tile",[7]="",[8]="Do this through the GFX Editor in `gfx/0.gfx`, and have all sprites the same size (e.g: 16x16).",[9]=""},children={}},[3]={level=2,text="Step 2. Creating the map",content={[1]="",[2]="You will need the map that your player will be on, this can be done with the map editor at `map/0.map`.",[3]="",[4]="Using the ground tiles and solid tiles, draw out the terrain.",[5]=""},children={}},[4]={level=2,text="Step 3. Drawing the screen",content={[1]="",[2]="In your `main.lua` is the main code for your cartridge. This is called when your cartridge is run, allowing you to import other `lua` files and create the basis of your game.",[3]="",[4]="To create the main loop, you can create the `_init`, `_update` and `_draw` functions - these are called on startup, every frame, and when a draw is called (less frequent than `_update` if there's lag) respectively.",[5]="",[6]="You will want to have a player variable, a table, and something to draw the player to the screen. Treat the player's positioning as fixed to the grid.",[7]="",[8]="The `_init` function creates the player",[9]="```lua",[10]="function _init()",[11]="    player={",[12]="        x=2,",[13]="        y=2,",[14]="        sprite=0",[15]="    }",[16]="end",[17]="```",[18]="",[19]="You can now access the player with stuff like `player.x`, `player.y` and `player.sprite`.",[20]="",[21]="Your update loop can be ignored for now.",[22]="",[23]="Your draw loop can draw the screen.",[24]="",[25]="The screen will consist of the map and the sprite.",[26]="",[27]="You can draw the map with [`map`](/functions/map/main.md) and draw the sprite with [`spr`](/functions/spr/main.md).",[28]="",[29]="You will need to call `cls()` at the beginning of the draw function - this will clear the screen and avoid drawing ontop of the previous frame continuously.",[30]="",[31]="```lua",[32]="function _draw()",[33]="    cls()",[34]="    map()",[35]="    spr(player.sprite,player.x*16,player.y*16)",[36]="end",[37]="```",[38]="",[39]="By multiplying it by 16, it applies it to a grid where each tile is 16x16. Replace `16` with your custom size if you have a different proportion - this does not affect anything else.",[40]="",[41]="By running this, you will now see the player at (2,2) but you cannot interact with the player.",[42]=""},children={}},[5]={level=2,text="Step 4. Moving the player",content={[1]=""},children={[1]={level=3,text="Basic movement",content={[1]="",[2]="Using the `_update` loop, you can add movement to the player.",[3]="",[4]="This can be done with the `btnp` function, which detects button presses every 4 frames.",[5]="",[6]="Create your update loop as such",[7]="```lua",[8]="function _update()",[9]="    if (btnp(0)) then",[10]="        player.x-=1",[11]="    end",[12]="end",[13]="```",[14]="",[15]="This will move the player left when you press left on the DPAD or analog joystick (left arrow key)",[16]="",[17]="Adding the following adds the other directions.",[18]="",[19]="```lua",[20]="function _update()",[21]="    if (btnp(0)) then",[22]="        player.x-=1",[23]="    end",[24]="    if (btnp(1)) then",[25]="        player.x+=1",[26]="    end",[27]="    if (btnp(2)) then",[28]="        player.y-=1",[29]="    end",[30]="    if (btnp(3)) then",[31]="        player.y+=1",[32]="    end",[33]="end",[34]="```",[35]="",[36]="This allows you to have full movement control of the player.",[37]="",[38]="If you run it now, it allows you to move along the grid for your game - though, it doesn't include collisions and stop you from leaving the map.",[39]="",[40]="Within Picotron Lua, you can also make use of inline code to clean the functions as seen:",[41]="```lua",[42]="function _update()",[43]="    if (btnp(0)) player.x-=1",[44]="    if (btnp(1)) player.x+=1",[45]="    if (btnp(2)) player.y-=1",[46]="    if (btnp(3)) player.y+=1",[47]="end",[48]="```",[49]=""},children={}},[2]={level=3,text="Collisions",content={[1]="",[2]="You can add collisions using `mget` by checking if the tile the player wants to move to is a solid tile or not.",[3]="",[4]="```lua",[5]="if (mget(nx,ny)==1)",[6]="```",[7]="",[8]="You can set this up in the update loop by creating a temporary x,y position that checks the collision before setting the player's true position.",[9]="",[10]="This craetes an x,y identical to the player's position at the start of the function.",[11]="",[12]="```lua",[13]="function _update()",[14]="    local nx,ny=player.x,player.y",[15]="    ...",[16]="```",[17]="",[18]="Now, instead of applying the movements to player.x,player.y, you apply it to nx,ny",[19]="```lua",[20]="function _update()",[21]="    local nx,ny=player.x,player.y",[22]="    if (btn(0)) nx-=1",[23]="    if (btn(1)) nx+=1",[24]="    if (btn(2)) ny-=1",[25]="    if (btn(3)) ny+=1",[26]="    ...",[27]="```",[28]="",[29]="This can be continued with:",[30]="",[31]="```lua",[32]="function _update()",[33]="    local nx,ny=player.x,player.y",[34]="    if (btn(0)) nx-=1",[35]="    if (btn(1)) nx+=1",[36]="    if (btn(2)) ny-=1",[37]="    if (btn(3)) ny+=1",[38]="",[39]="    if (mget(nx,ny)==1) then",[40]="        player.x,player.y=nx,ny",[41]="    end",[42]="end",[43]="```",[44]="",[45]="This treats tile `1` as a tile the player can walk ontop of & through.",[46]="",[47]="If the tile that the player tries to enter is not tile `1`, it ignores the collision.",[48]=""},children={}},[3]={level=3,text="Adding a tile system",content={[1]="",[2]="You can upgrade the tile system (checking collisions) with tables.",[3]="",[4]="Creating a lookup table with a table allows you to refer to this with the tile the player moves into.",[5]="",[6]="Create a tile registry is as such:",[7]="",[8]="```lua",[9]="walkableTiles={",[10]="    [1]=true",[11]="}",[12]="```",[13]="",[14]="Using `[index]`, it allows you to write an index into it, with a `true` value indicating that it is walkable.",[15]="",[16]="You do not need to add `[2]=false` or any other solid tile to this as such as it will default to being seen as false.",[17]="",[18]="Checking the collision is now seen as such:",[19]="",[20]="```lua",[21]="local tile=mget(nx,ny)",[22]="",[23]="if (walkableTiles[tile]) then",[24]="    player.x,player.y=nx,ny",[25]="end",[26]="```",[27]="",[28]="If `walkableTiles[tile]` is not set, this fails - indicating that it is solid.",[29]="If it is set, it indicates that it is walkable, and allows the player to walk through the tile.",[30]="",[31]="This tile system can be continued for any arbritrary purpose, e.g: if you want another type of tile.",[32]="",[33]="```lua",[34]="waterTiles={",[35]="    [3]=true",[36]="}",[37]="```",[38]="",[39]="You can check this in the same way that you checked collisions before, using the `waterTiles` lookup table alongside the `walkableTiles` lookup table",[40]=""},children={}}}},[6]={level=2,text="Step 5. Continue on",content={[1]="",[2]="You now have a simple player controller and a simple game loop, you can build on top of this yourself (or with any following guides) to create a larger game!",[3]=""},children={}}}}}},[141]={name="main.md",path="/guides/desktop_customisation/main.md",data={[1]={level=1,text="Desktop Customisation",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html).",[3]="",[4]="This goes over customising your Picotron Desktop.",[5]=""},children={}},[2]={level=2,text="Settings",content={[1]="",[2]="The Picotron settings can be opened via the Picotron menu (top left) or by accessed by typing \"settings\" in the terminal.",[3]="",[4]="Within the settings, you can customise your desktop, e.g: changing the theme, wallpapers or screensavers.",[5]=""},children={}},[3]={level=2,text="Themes",content={[1]="",[2]="There are some default themes packaged within Picotron, these are located in `/system/themes/`.",[3]="",[4]="These themes change the color palette of Picotron.",[5]="",[6]="You can add custom themes by creating a folder at `/appdata/system/themes/` and creating `.theme` files in that folder.",[7]="",[8]="These themes will then be accessible through the Settings.",[9]=""},children={}},[4]={level=2,text="Wallpapers",content={[1]="There are some default wallpapers packaged within Picotron, these are located in `/system/wallpapers/`.",[2]="",[3]="",[4]="These wallpapers change the backdrop of the desktop. Each wallpaper is a `.p64` cartridge.",[5]="",[6]="You can add custom wallpapers by creating a folder at `/appdata/system/wallpapers/` and placing `.p64` cartridges in that folder.",[7]="",[8]="These wallpapers will then be accessible through the Settings.",[9]=""},children={}},[5]={level=2,text="Screensavers",content={[1]="",[2]="There are some default screensavers packaged within Picotron, these are located in `/system/screensavers/`.",[3]="",[4]="These screensavers change the backdrop of the desktop. Each screensaver is a `.p64` cartridge.",[5]="",[6]="You can add custom screensavers by creating a folder at `/appdata/system/screensavers/` and placing `.p64` cartridges in that folder.",[7]="",[8]="These screensavers will then be accessible through the Settings.",[9]=""},children={}},[6]={level=2,text="Widgets",content={[1]="",[2]="Widgets are programs that run in the slide-out tooltray (pull the toolbar down from the top), and are windowed programs that are not moveable and do not have a frame. To install a widget, first run it as a windowed program, adjust the window size to your liking (if it resizeable),  and then drag and drop it into the tooltray. The widget will now be re-launched every time  Picotron boots.",[3]="Running BBS apps can be installed directly in the tooltray -- there is no need  to make a local copy first.",[4]="",[5]="Right-click a widget to pop in back out as a window, or to remove it."},children={}}}}}},[142]={name="main.md",path="/guides/default_apps/main.md",data={[1]={level=1,text="Default Apps",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html).",[3]="",[4]="This guide goes over how default apps work in Picotron and how to change them.",[5]=""},children={}},[2]={level=2,text="How default apps work",content={[1]="",[2]="When opening a file via filenav or the open command, an application to open it with is selected based on the extension. ",[3]="",[4]="To change or add the default application for an extension, use the [`default_app`](/system/details/util/default_app/main.md) command. The following will associate files ending with `.sparkle` with the program located at `/apps/tools/sparklepaint.p64`:",[5]="",[6]="```",[7]="default_app sparkle /apps/tools/sparklepaint.p64",[8]="```",[9]="",[10]="The table of associations is stored in: /appdata/system/default_apps.pod. Delete that file to reset to defaults, or reset a particular extension to default with:",[11]="",[12]="```",[13]="default_app lua",[14]="```",[15]=""},children={[1]={level=3,text="Using Sandboxed Tools",content={[1]="",[2]="Although bbs:// carts always run sandboxed, they can be set as default apps with little practical difference.  They do not need to be \"installed\" locally, and are cached forever for offline use. For example, to use Strawberry Src as the default app for txt files:",[3]="",[4]="```",[5]="default_app txt #strawberry_src",[6]="```",[7]="",[8]="or",[9]="",[10]="```",[11]="default_app txt bbs://strawberry_src.p64",[12]="```",[13]="",[14]="BBS carts can still be used to access any file on the drive when there is clear intent: via the filenav file  chooser, when loading/saving carts, or when using the open command. In each of these cases, the sandoxed view of the file system is expanded to include the requested file(s). For more technical details, see @{File Sandboxing}.",[15]="",[16]="The advantages of using BBS carts directly without unsandboxing them:",[17]="",[18]="1. They do not need to be as trusted. BBS carts can do limited damage to your system *",[19]="2. The latest version is always used (when no version number is given)",[20]="3. They don't take any space on your picotron drive (but are cached for offline use).",[21]="4. Files authored with a BBS cart are automatically associated with that tool +",[22]="",[23]="Editors for lua files are a special case; tools that edit e.g. `/ram/cart/main.lua` could maliciously inject arbitrary code that is then run unsandboxed. But the risk only extends to anything mounted inside the Picotron drive.",[24]="",[25]="When a `bbs://` cartridge is used to create or edit a file, the location of that cartridge is stored in the file's metadata as `metadata.prog`. When a default app can not be found to open a file, `metadata.prog` is used instead when it is available.",[26]=""},children={}}}}}}}},[143]={name="main.md",path="/guides/creating_a_cart/main.md",data={[1]={level=1,text="Creating a Cartridge",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html).",[3]="",[4]="Picotron is a cartridge-orientated workstation. A cartridge is like an application bundle, or a project folder: it is a collection of Lua source code files, graphics, audio and any other data files the cartridge needs to run. The \"present working cartridge\" is always in a RAM folder named /ram/cart.",[5]=""},children={}},[2]={level=2,text="The Code Editor",content={[1]="",[2]="Click on the code editor workspace at top right, which looks like this: ()",[3]="",[4]="Paste in a program (select here, CTRL-C, and then CTRL-V inside Picotron)",[5]="",[6]="```lua",[7]="function _init()",[8]="    bunny =",[9]="--[[pod_type=\"gfx\"]]unpod(\"b64:bHo0AEIAAABZAAAA-wpweHUAQyAQEAQgF1AXQDcwNzAHHxcHMAceBAAHc7cwFwFnAQcGAPAJZx8OJ0CXcF8dkFeQFy4HkBcuB5AXEBdA\")",[10]="    x = 232",[11]="    y = 127",[12]="end",[13]="",[14]="function _draw()",[15]="    cls(3)   -- clear the screen to colour 3 (green)",[16]="    rrectfill(x+2,y+15,12,4,1,19) -- draw a 12x4 px shadow with colour 19 (dark green)",[17]="    spr(bunny, x, y + (x/8%2), hflip) -- draw bunny; (x/8%2) is for hopping motion",[18]="end",[19]="",[20]="function _update()",[21]="    if (btn(0)) x -= 2 hflip = true",[22]="    if (btn(1)) x += 2 hflip = false",[23]="    if (btn(2)) y -= 2",[24]="    if (btn(3)) y += 2",[25]="end",[26]="```",[27]=""},children={}},[3]={level=2,text="Running the program",content={[1]="Now, press [CTRL-R](/environment/reload/main.md) to run it. CTRL-R runs whatever is in /ram/cart, and the entry point in the cartridge is always main.lua (the file you were editing).",[2]="",[3]="After hopping around with the cursor keys, press [ESCAPE](/environment/workspaces/main.md) to halt the program and then  ESCAPE  once more to get back to the code editor.",[4]=""},children={[1]={level=3,text="Cartridge loop",content={[1]="",[2]="There is a lot going on here! The `_init()` function is always called once when the program starts, and here it creates an image stored as text (a \"pod\") and sets  the bunny's initial x,y position.",[3]="",[4]="`_draw()` is called whenever a frame is drawn (at 60fps or 30fps if there isn't enough available cpu). There are some comments in the `_draw` function that explain what is happening; everything after `--` on each line is not part of the program.",[5]="",[6]="`_update()` is always called at 60fps, so is a good place to put code that updates the world at a consistent speed. In this example, it looks for button presses [`btn()`](/picotron_api/functions/btn/main.md) to control the bunny's position.",[7]="",[8]="Each line of the program is run in order. Try swapping the `rrectfill` and `spr` lines to draw the shadow after drawing the bunny, to see what happens. Also, try removing the `cls(3)` and running the program again to see why it is important!",[9]=""},children={}}}},[4]={level=2,text="Adding Graphics",content={[1]="",[2]="Normally graphics are stored in `.gfx` files included in the cartridge as `gfx/*.gfx`",[3]="",[4]="Lets get rid of the \"bunny\" variable and use the sprite editor instead. Click on the second workspace, which already has `gfx/0.gfx` open by default, and scribble something.",[5]="",[6]="Now, instead of drawing the \"bunny\" image, the index of the new sprite can be used instead:",[7]="",[8]="```lua",[9]="spr(1, x, y, hflip) -- hflip controls horizontal flipping",[10]="```",[11]="",[12]="Hit [CTRL-R](/environment/reload/main.md) to run the cartridge, and the new sprite should be visible.",[13]=""},children={}},[5]={level=2,text="Adding a map",content={[1]=""},children={[1]={level=3,text="Map Editor",content={[1]="",[2]="The [Map Editor](/environment/map_editor/main.md) works the same way: `map/0.map` is loaded by default, and uses the sprites in  0.gfx. First, draw some tiles in the sprite editor (e.g. a flower or plant). Next, click on the map  workspace at the top right (next to the gfx workspace). The new tiles can now be placed in the map.  Hold down SPACE and click and drag to pan around.",[3]=""},children={}},[2]={level=3,text="Drawing the map",content={[1]="",[2]="Finally, the map can be drawn inside the _draw callback using [`map()`](/picotron_api/functions/map/main.md). Add it after the `cls(3)`:",[3]="",[4]="```lua",[5]="cls(3)",[6]="map()",[7]="```",[8]="",[9]="To adjust the draw position to keep the player centered, try using [`camera()`](/picotron_api/functions/camera/main.md) at the start of `_draw()`:",[10]="",[11]="```lua",[12]="camera(x - 240, y - 135)",[13]="```",[14]="",[15]="To create more complex worlds with multiple map files and layers and sprite banks, see the [Map Editor](/environment/map_editor/main.md), @Map api and @{Sprite Indexes}.",[16]=""},children={}}}},[6]={level=2,text="Adding sound and music",content={[1]="",[2]="To create a sound effect, open the [SFX workspace](/environment/sfx_editor/main.md) (the musical notes icon at the top right) and scribble in the PITCH area. Press SPACE to play and once again to stop the current sfx.",[3]="",[4]="The default speed (\"SPD\") is 16, which is good for playing tunes, but try something faster (1 ~ 4 ticks per row) for creating  sound effects. Adjust the SPD value (at the top right) by clicking and dragging it or by using the mousewheel while hovering over the value.",[5]="",[6]="The new sound effect can now be played wile the cart is running using the [`sfx()`](/picotron_api/functions/sfx/main.md) function. Try the following at the end of `_update` to  play the sound when the X button is pressed:",[7]="",[8]="```lua",[9]="if (btnp(5)) sfx(0)",[10]="```",[11]="",[12]="To load and play a separate `.sfx` file as music, see [`music()`](/environment/music/main.md) for an example.",[13]=""},children={}},[7]={level=2,text="Adding Code Tabs",content={[1]="",[2]="Multiple code tabs can be created by making a lua file for each one. Click on the [+] tab ",[3]="button near the top and type in a name for the new file (a `.lua` extension will be added ",[4]="automatically if needed), and then include them at the top of your  main.lua program:",[5]="",[6]="```lua",[7]="include \"title.lua\"",[8]="include \"monster.lua\"",[9]="include \"math.lua\"",[10]="```",[11]="",[12]="The filename is relative to the present working directory, which starts as the directory a ",[13]="program is run from (e.g. `/ram/cart`).",[14]=""},children={}},[8]={level=2,text="Saving a Cartridge",content={[1]="",[2]="To save a cartridge to disk, open a terminal from the picotron menu (top left), and type:",[3]="",[4]="```",[5]="save mycart.p64",[6]="```",[7]="",[8]="(or just `save mycart` ~ the `.p64` extension will be added automatically)",[9]="",[10]="The save command simply copies the contents of `/ram/cart` to `mycart.p64`.",[11]="",[12]="Once a cartridge has been saved, the filename is set as the \"present working cartridge\", and ",[13]="subsequent saves can be issued with the shortcut: [CTRL-S](/environments/save/main.md). To get information about the current cartridge, type [info](/system/details/util/info/main.md) at the terminal prompt.",[14]="",[15]="When editing code and graphics files inside a cartridge, those individual files are \"auto-saved\" to `/ram/cart` so that [CTRL-R](/environments/reload/main.md) will run the current version; there's no need to save before each run to sync changes.",[16]="",[17]="When using an editor to edit a file that is outside `/ram/cart` (e.g. `/desktop/todo.txt`), [CTRL-S](/environments/save/main.md) saves only that individual file. Otherwise, [CTRL-S](/environments/save/main.md) always saves the whole cartridge.",[18]=""},children={}}}}}},[144]={name="main.md",path="/guides/bbs/main.md",data={[1]={level=1,text="Using the BBS",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This guide is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html).",[3]="",[4]="This goes over using the [Picotron Bulletin Board System](https://www.lexaloffle.com/bbs/?cat=8).",[5]=""},children={}},[2]={level=2,text="Uploading a Cartridge to the BBS",content={[1]="",[2]="Cartridges can be shared on the [Lexaloffle BBS](https://www.lexaloffle.com/bbs/?cat=8):",[3]="",[4]="First, capture a label while your cart is loaded and running with [CTRL-7](/environment/screenshot/main.md). For windowed programs, the label will include a screenshot of your desktop, so make sure you don't have anything personal lying around!",[5]="",[6]="You can give the cartridge some metadata (title, version, author, notes) using the system app `about.p64`.",[7]="This can also be opened through the terminal.",[8]="",[9]="```",[10]="about /ram/cart",[11]="```",[12]="",[13]="Hit [CTRL-S](/environment/save/main.md) to save the changes made to the label and metadata.",[14]="",[15]="Then make a copy of your cartridge in the `.p64.png` format just by copying it:",[16]="",[17]="```",[18]="cp mycart.p64 releaseable.p64.png",[19]="```",[20]="",[21]="The label will be printed on the front along with the title, author and version metadata if it exists.  You can check the output by opening the folder you saved to, and then double clicking on `releaseable.p64.png` (it is just a regular `png` image)",[22]="",[23]="```",[24]="folder",[25]="```",[26]="",[27]="Finally, go to the [Submit Cartridge page on the BBS](https://www.lexaloffle.com/picotron.php?page=submit) to upload the cartridge. Cartridges are not publicly listed until a BBS post has been made including the cartridge.",[28]=""},children={}},[3]={level=2,text="Browsing BBS Cartridges",content={[1]="",[2]="Cartridges can be browsed using the `bbs://` protocol from within filenav. In the Picotron menu (top left) there is an item \"BBS Carts\" that opens bbs:// in the root folder.",[3]="",[4]="Cartridges can alternative be loaded directly from the BBS using the cartridge id:",[5]="",[6]="```",[7]="load #cart_id",[8]="```",[9]="This is the same as `load bbs://cart_id.p64`",[10]="",[11]="A specific version of the cart can be specified with the revision suffix:",[12]="",[13]="```",[14]="load #cart_id-0.p64	",[15]="```",[16]="",[17]="They can also be run as if they are a local file:",[18]="",[19]="```",[20]="bbs://cart_id.p64",[21]="```",[22]="",[23]="BBS Cartridges are all run sandboxed by default, which means they are only allowed to write to their own folder in /appdata/bbs/cart_id, among other limitations. To give a BBS cart (that you trust!) access to the entire Picotron drive, it can be loaded with  the -u switch:",[24]="",[25]="```",[26]="load -u #cart_id",[27]="```",[28]="",[29]="You can also use the system app Splore by entering `splore` in the terminal which lets you search, open and download BBS cartridges."},children={}}}}}},[145]={name="readme.md",path="/environment/readme.md",data={[1]={level=1,text="environment",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Documentation on the Picotron environment/ecosystem",[3]=""},children={}},[2]={level=2,text="Main sections",content={[1]="",[2]="[Settings](/environment/settings/readme.md)",[3]="",[4]="[Keybinds](/environment/keybinds/readme.md)",[5]=""},children={}},[3]={level=2,text="Miscellaneous",content={[1]="",[2]="[Capturing GIFs](/environment/gif/main.md)",[3]="",[4]="[Capturing Screenshots](/environment/screenshot/main.md)",[5]="",[6]="[Reload](/environment/reload/main.md)",[7]="",[8]="[Saving](/environment/save/main.md)",[9]="",[10]="[Workspaces](/environment/workspaces/main.md)",[11]="",[12]="[Pausing](/environment/pause/main.md)",[13]="",[14]="[Host OS](/environment/host_os/main.md)",[15]="",[16]="[Fast Quit](/environment/fast_quit/main.md)",[17]="",[18]="[Anywhen](/environment/anywhen/main.md)"},children={}}}}}},[146]={name="main.md",path="/environment/workspaces/main.md",data={[1]={level=1,text="Workspaces",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Workspaces are different spaces for work, e.g: the code editor or gfx editor.",[3]="",[4]="Fullscreen or tabbed apps have their own workspace.",[5]="",[6]="The desktop is the default workspace and is where windowed apps are placed by default.",[7]=""},children={}},[2]={level=2,text="Changing Workspaces",content={[1]="",[2]="Changing workspaces can be done by clicking the respective workspace icon in the top right.",[3]="",[4]="This can alternatively be done with `ALT+LEFT` and `ALT+RIGHT` where the active workspace cycles left and right respectively.",[5]="",[6]="By pressing `ESCAPE`, you can switch between the current workspace and either: the terminal or a fullscreen process that has been opened. The fullscreen process takes presedence over the terminal."},children={}}}}}},[147]={name="readme.md",path="/environment/settings/readme.md",data={[1]={level=1,text="environment > settings",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Settings in Picotron, set through [`config`](/system/util/config/main.md) util, `settings.p64` or directly at `/appdata/system/settings.pod`",[3]=""},children={}},[2]={level=2,text="Settings",content={[1]="",[2]="[Picotron's Battery Saver](battery_saver/main.md)",[3]="",[4]="[720p upscaler](blit_720p/main.md)",[5]="",[6]="[Fullscreen](fullscreen/main.md)",[7]="",[8]="[Mute Audio](mute_audio/main.md)",[9]="",[10]="[Pixel Perfect](pixel_perfect/main.md)",[11]="",[12]="[Right Shift Magnify](rshift_magnify/main.md)",[13]="",[14]="[Snap To Grid](snap_to_grid/main.md)",[15]="",[16]="[Sparkles](sparkles/main.md)",[17]="",[18]="[Stretch](stretch/main.md)",[19]="",[20]="[Theme](theme/main.md)",[21]="",[22]="[Wallpaper](wallpaper/main.md)",[23]="",[24]="[Floppy Windows](floppy_windows/main.md) - does absolutely nothing, just exists in settings!"},children={}}}}}},[148]={name="main.md",path="/environment/settings/wallpaper/main.md",data={[1]={level=1,text="wallpaper `string (filepath)`",content={[1]="",[2]="Path to a picotron cartridge"},children={}}}},[149]={name="main.md",path="/environment/settings/theme/main.md",data={[1]={level=1,text="theme `string (filepath)`",content={[1]="",[2]="Path to a .theme file"},children={}}}},[150]={name="main.md",path="/environment/settings/swap_stereo/main.md",data={[1]={level=1,text="swap_stereo `boolean`",content={[1]="",[2]="Swap the sides of your stereo audio"},children={}}}},[151]={name="main.md",path="/environment/settings/stretch/main.md",data={[1]={level=1,text="stretch `boolean`",content={[1]="",[2]="Stretch the Picotron screen to fill the entirity of your native screen"},children={}}}},[152]={name="main.md",path="/environment/settings/sparkles/main.md",data={[1]={level=1,text="sparkles `boolean`",content={[1]="",[2]="Sparkles follow the cursor"},children={}}}},[153]={name="main.md",path="/environment/settings/snap_to_grid/main.md",data={[1]={level=1,text="snap_to-grid `boolean`",content={[1]="",[2]="Files on the desktop snapping to a grid"},children={}}}},[154]={name="main.md",path="/environment/settings/rshift_magnify/main.md",data={[1]={level=1,text="rshift_magnify `boolean`",content={[1]="",[2]="Whether pressing `RIGHT SHIFT` should magnify the area around your cursor"},children={}}}},[155]={name="main.md",path="/environment/settings/pixel_perfect/main.md",data={[1]={level=1,text="pixel_perfect `boolean`",content={[1]="",[2]="Whether Picotron should be scaled up to be pixel perfect"},children={}}}},[156]={name="main.md",path="/environment/settings/network_access/main.md",data={[1]={level=1,text="network_access `boolean`",content={[1]="",[2]="Allow Picotron to access your network"},children={}}}},[157]={name="main.md",path="/environment/settings/mute_audio/main.md",data={[1]={level=1,text="mute_audio `boolean`",content={[1]="",[2]="Mute the audio of Picotron"},children={}}}},[158]={name="main.md",path="/environment/settings/fullscreen/main.md",data={[1]={level=1,text="fullscreen `boolean`",content={[1]="",[2]="Fullscreen Picotron in the host OS"},children={}}}},[159]={name="main.md",path="/environment/settings/floppy_windows/main.md",data={[1]={level=1,text="floppy_windows `nil`",content={[1]="",[2]="Does absolutely nothing!",[3]="",[4]="Left in by zep on accident?",[5]="",[6]="No reference to floppy_windows in /system/"},children={}}}},[160]={name="main.md",path="/environment/settings/blit_720p/main.md",data={[1]={level=1,text="blit_720p `boolean`",content={[1]="",[2]="Use Picotron's 720p upscaler, information by @bloodninja",[3]="",[4]="720p monitors (or resolutions which are multiples of that, such as 1440p) do not allow Picotron to show the display edge-to-edge - there will be black bars around the image.",[5]="",[6]="When players enable this somewhat vaguely-named option in Settings.p64, Picotron zooms in so that the display is filled, meaning some outer areas are cut off. Those of you of a certain vintage may remember this as overscan.",[7]=""},children={[1]={level=2,text="800p/Steamdeck example",content={[1]="",[2]="800p-fill-safe area",[3]="",[4]="For 800p and Deck players using the \"fill screen\" mode, the visible area is a rectangle of 432x270 starting at (24,0), visible with this code:",[5]="```lua",[6]="rect(24,0,467,269,31)",[7]="print(\"Steam Deck (800p in 'Fill' display mode)\",28,2,31)",[8]="```",[9]="",[10]="By default, the Deck does very well in 720p mode without enabling the \"720p scaler\" option, instead keeping small black bars at the top and bottom of the display while keeping the image sharp. For those players who use the Deck overlay to force the image to fill the screen, some horizontal area may be cut off.",[11]=""},children={}},[2]={level=2,text="720p-safe area",content={[1]="",[2]="For users using the \"720p scaler\", the visible area is a rectangle of 360x202 starting at (60,34), visible with this code:",[3]="",[4]="```lua",[5]="rect(60,34,419,235,8)",[6]="print(\"720p scaler\",62,36,8)",[7]="```",[8]="",[9]="[Example Cart](https://www.lexaloffle.com/bbs/?tid=153523) by @bloodninja for an example!",[10]="",[11]="![Display of the cart in runtime](https://www.lexaloffle.com/bbs/thumbs/pico64_dagupigewe-0.png)"},children={}}}}}},[161]={name="main.md",path="/environment/settings/battery_saver/main.md",data={[1]={level=1,text="battery_saver `boolean`",content={[1]="",[2]="Enable Picotron's battery saver"},children={}}}},[162]={name="main.md",path="/environment/screenshot/main.md",data={[1]={level=1,text="Screenshots",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="There are two forms of screenshots in Picotron, cart labels and generic `.png` screenshots.",[3]=""},children={}},[2]={level=2,text="Generic `.png` screenshots",content={[1]="",[2]="Generic screenshots can be captured through pressing `CTRL+6`.",[3]="This is created in the `png` format.",[4]="",[5]="These screenshots are automatically appended to `{Your Host OS desktop}/picotron_desktop`.",[6]=""},children={}},[3]={level=2,text="Cart labels",content={[1]="",[2]="Cart labels are generated through pressing `CTRL+7`.",[3]="This generates a label for the currently loaded cart (in `/ram/cart`) in the `.qoi` format."},children={}}}}}},[163]={name="main.md",path="/environment/save/main.md",data={[1]={level=1,text="Saving",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="You can save the currently loaded cartridge or save the active file with `CTRL+S`.",[3]=""},children={}},[2]={level=2,text="Saving rules",content={[1]="",[2]="`CTRL+S` saves the currently loaded cartridge if the active file is located within `/ram/cart` (the current loaded cartridge).",[3]="",[4]="Otherwise, `CTRL+S` saves the current file.",[5]=""},children={}},[3]={level=2,text="Limitations",content={[1]="",[2]="If you attempt to save to `/system`, the changes are only temporary and are lost on reboot.",[3]="This can be counteracted if you have a [persistent system](/system/persistence/main.md).",[4]="",[5]="You cannot save to the loaded cart if it is not in your picotron drive, e.g: loaded from the bbs."},children={}}}}}},[164]={name="main.md",path="/environment/reload/main.md",data={[1]={level=1,text="Reloading a cartridge",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="You can reload the currently loaded cartridge through the full cart or only one file.",[3]="",[4]="This only applies to the cartridge in `/ram/cart` and works in exports.",[5]=""},children={}},[2]={level=2,text="Full reloading",content={[1]="",[2]="`CTRL+R` fully reloads the currently loaded cartridge",[3]=""},children={}},[3]={level=2,text="Live reloading",content={[1]="",[2]="`CTRL+SHIFT+R` live-reloads a single .lua or .gfx file while the cartridge is running"},children={}}}}}},[165]={name="main.md",path="/environment/pause/main.md",data={[1]={level=1,text="Pause",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="The pause menu is opened when you press `ENTER` or the `START`/`MENU` button (btn 6).",[3]="It contains the default options that Picotron provides alongside the cart-given options.",[4]=""},children={}},[2]={level=2,text="Options",content={[1]="",[2]="The default options consist of:",[3]="",[4]="* Resume",[5]="* Favourite",[6]="* Reset Cart",[7]="* Exit",[8]="",[9]="More options can be given through the use of [menuitem()](/picotron_api/functions/menuitem/main.md) by Picotron.",[10]="",[11]="The default options are impossible to remove or change."},children={}}}}}},[166]={name="readme.md",path="/environment/keybinds/readme.md",data={[1]={level=1,text="environment > keybinds",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="Information on the keybinds in Picotron",[3]=""},children={}},[2]={level=2,text="Keybinds",content={[1]=""},children={}},[3]={level=2,text="General",content={[1]="",[2]="The `ALT` key is `OPTION` on Mac devices.",[3]="",[4]="ALT+ENTER - Sets Picotron to be fullscreen (in the Host OS)",[5]="[ALT+F4](/environment/fastquit/main.md) - Fast Quit (Windows)",[6]="[CTRL+Q](/environment/fastquit/main.md) - Fast Quit (Mac, Linux) - requires enabling in settings",[7]="[CTRL+R](/environment/reload/main.md) - Reload / Run / Restart cartridge",[8]="[CTRL+SHIFT+R](/environment/reload/main.md) - Live-reload a single .lua or .gfx file while /ram/cart is running",[9]="[CTRL+S](/environment/save/main.md) - Quick save the working cartridge or the current file",[10]="[ALT+LEFT/RIGHT](/environment/workspaces/main.md) - Cycle workspaces",[11]="[ESCAPE](/environment/workspaces/main.md) - Toggle between the desktop and the terminal",[12]="[ENTER](/environment/pause/main.md) - ",[13]="[CTRL+6](/environment/screenshot/main.md) - Capture a screenshot (png) of the current screen, stored in `{Your Host OS desktop}/picotron_desktop`",[14]="[CTRL+7](/environment/screenshot/main.md) - Capture the label for the currently loaded cartridge",[15]="[SHIFT+CTRL+8](/environment/gif/main.md) - Select a region for the gif (default is the full visible screen)",[16]="[CTRL+8](/environment/gif/main.md) - Begin capturing a gif",[17]="[CTRL+9](/environment/gif/main.md) - End the capture of a gif, stored in `{Your Host OS desktop}/picotron_desktop`"},children={}}}}}},[167]={name="main.md",path="/environment/host_os/main.md",data={[1]={level=1,text="Host OS",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="The Host OS is the operating system that is running Picotron.",[3]="",[4]="e.g: if you are on Windows:",[5]="",[6]="* the host OS is your windows system",[7]="* the virtual OS is Picotron",[8]=""},children={}},[2]={level=2,text="Virtual OS",content={[1]="",[2]="The Host OS stores the Virtual OS (Picotron)",[3]=""},children={[1]={level=3,text="Config Files",content={[1]="",[2]="The configuration files for picotron are created here:",[3]="",[4]="* Windows: `C:/Users/Yourname/AppData/Roaming/Picotron/picotron_config.txt`",[5]="* OSX:     `/Users/Yourname/Library/Application Support/Picotron/picotron_config.txt`",[6]="* Linux:   `~/.lexaloffle/Picotron/picotron_config.txt`",[7]=""},children={}},[2]={level=3,text="Virtual Drive location",content={[1]="",[2]="The virtual drive for picotron is found here:",[3]="",[4]="* Windows: `C:/Users/Yourname/AppData/Roaming/Picotron/drive/`",[5]="* OSX:     `/Users/Yourname/Library/Application Support/Picotron/drive/`",[6]="* Linux:   `~/.lexaloffle/Picotron/drive/`",[7]="",[8]="This can be edited in the config file.",[9]=""},children={}},[3]={level=3,text="Interacting with the Host OS",content={[1]="",[2]="Files from inside of Picotron can be told to open in the Host OS.",[3]="This is typically done from within the system filenav by right clicking a file and selecting `View in Host OS`.",[4]="",[5]="The code equivalent of this is:",[6]="",[7]="```lua",[8]="send_message(2,{event=\"open_host_path\",path=\"path/to/open\"})",[9]="```"},children={}}}}}}}},[168]={name="main.md",path="/environment/fast_quit/main.md",data={[1]={level=1,text="Fast Quitting",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="You can quit Picotron instantly through the use of your respective keybind.",[3]=""},children={}},[2]={level=2,text="How to fast quit",content={[1]="",[2]="For MacOS and Linux users - this keybind is `CTRL+Q` but requires enabling in the settings.",[3]="",[4]="For Windows users - this keybind is `ALT+F4` and does not need enabling."},children={}}}}}},[169]={name="main.md",path="/environment/gif/main.md",data={[1]={level=1,text="Recording gifs",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="You can record gifs natively in Picotron through `CTRL+8` and `CTRL+9` or through use of the `capture.p64` system app.",[3]=""},children={}},[2]={level=2,text="Recording a gif",content={[1]=""},children={[1]={level=3,text="Starting a recording",content={[1]="",[2]="To start capturing a gif, you can press `CTRL+8`, this will begin recording the selected area.",[3]=""},children={}},[2]={level=3,text="Ending a recording",content={[1]="",[2]="The gif will automatically end recording at a certain point.",[3]=""},children={}},[3]={level=3,text="Settings a recording area",content={[1]="",[2]="To set the area that is captured, you can press `CTRL+SHIFT+8` to select an area to record.",[3]="",[4]="This defaults to the full visible area in Picotron if you don't use `CTRL+SHIFT+8`.",[5]=""},children={}},[4]={level=3,text="Missing information",content={[1]="",[2]="The amount of time that the gif records is variable (see `/system`), the details as of writing this are unknown.",[3]="",[4]="Details on using the capture app to record is missing."},children={}}}}}}}},[170]={name="main.md",path="/environment/anywhen/main.md",data={[1]={level=1,text="Anywhen",content={[1]=""},children={[1]={level=2,text="Overview",content={[1]="",[2]="This information is sourced from the [Picotron Manual](https://www.lexaloffle.com/dl/docs/picotron_manual.html)",[3]="",[4]="Anywhen is a tool for viewing the state of cartridges, files and folders at any point in time.",[5]=""},children={}},[2]={level=2,text="Details",content={[1]="",[2]="When a file is modified inside Picotron, the file system records a delta between the previous version on disk and the new version being written. This allows changes to be listed and viewed at exactly the moment they happened.",[3]="",[4]="Past versions of a file are not stored inside the file itself, but in a separate read-only storage area outside of the Picotron drive.",[5]="",[6]="Anywhen logging can be disabled in settings by un-checking the Anywhen checkbox in settings. While disabled, file changes will not be recorded (but past changes are still accessible).",[7]="",[8]="Anywhen paths (that contain `/@/`) are not visible to sandboxed cartridges.",[9]=""},children={}},[3]={level=2,text="Anywhen Paths",content={[1]="",[2]="Paths on the local drive can be appened with \"/@/\" to access a list of days that the path changed (`yyyy-mm-dd`), and a version of that file or folder at each point in time (`hh:mm:ss.ext`). All times are in GMT.",[3]="",[4]="For example, a cartridge sitting on the desktop that had changes saved in April and June might look like this:",[5]="",[6]="```",[7]="> ls /desktop/mycart.p64/@",[8]="2025-04-19",[9]="2025-04-24",[10]="2025-06-11",[11]="```",[12]="",[13]="Inside each `day` folder is a collection cartridges: one for each moment in time the cartridge was modified:",[14]="",[15]="```",[16]=">ls /desktop/mycart.p64/@/2025-04-19",[17]="09:23:55.p64",[18]="11:40:23.p64",[19]="```",[20]="",[21]="Each item can be run directly, loaded or explored as if it were a regular cartridge. The same works for separate files. For example, to view a text file as it was at a particular point in time:",[22]="",[23]="```",[24]="> edit /desktop/todo.txt/@/2025-01-01/00:00:00.txt",[25]="```",[26]="",[27]="Anywhen paths include `:` character to make times more readable, but `_` can be used instead. ",[28]="Local file paths do not support `:`, so `_` is used when e.g. copying a file from the past into the ",[29]="present:",[30]="",[31]="```",[32]="> cp /desktop/todo.txt/@/2025-01-01/00:00:00.txt .",[33]="> ls",[34]="00_00_00.txt",[35]="```",[36]="",[37]="Folders can also be viewed at any time. A \"change\" to the folder is marked when the folder was created or an item was added to it.",[38]="",[39]="To view all version of `/desktop` in filenav:",[40]="",[41]="```",[42]="> open /desktop/@",[43]="```",[44]=""},children={}},[4]={level=2,text="Logging And Access Rules",content={[1]="",[2]="Anywhen only stores changes made to files from within Picotron; it does not proactively look for changes made in external editors except when generating the first log file per day. ",[3]="",[4]="It does not store any changes made to `/ram/`.",[5]="",[6]="Changes made to paths that include \".bin\" are never recored to save space (binary exports are very large compared with typical Picotron files, and normally do not need to be logged).",[7]="",[8]="Anywhen paths are not available to sandboxed cartridges",[9]=""},children={}},[5]={level=2,text="Anywhen Storage",content={[1]="",[2]="The modification history is stored outside of the Picotron drive, and can be managed in the host OS if desired. The default storage location is in the same folder as `picotron_config.txt`: use \"folder /\" to open the drive in the Host OS, and go up one folder.",[3]="",[4]="Change logs are organised by month, and it is safe to remove a month folder (e.g. \"2024-09\") if it is no longer needed. Doing so means that any changes made during that month will no longer be visible, but the rest of the history will work as normal.",[5]="",[6]="Newer versions of Picotron (from 0.2.0i) store binary blobs in a shared folder called \"anywhen/blob\",  which is shared between all months to avoid redundancy and save space. These are currently not possible to be removed by month, but a tool to sweep \"dangling blob references\" will be available in the future."},children={}}}}}}}