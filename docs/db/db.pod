{[0]={name="documenting.md",path="/documenting.md",data={[0]={level=1,text="Documenting the Picotron Wiki",content={[0]=""},children={[0]={level=2,text="Current Process",content={[0]="",[1]="If you would like to add documentation to the Picotron Wiki, please:",[2]="* create a pull request",[3]="* contact me through `@astralsparv` on discord.",[4]="* make a post on the [lexaloffle BBS post](https://www.lexaloffle.com/bbs/?pid=143916)",[5]=""},children={}},[1]={level=2,text="How to format pages",content={[0]="",[1]="main.md pages (e.g: functions, methods) are formatted as such:",[2]="",[3]="For each overload of a function or method, a heading describes the signature.",[4]="",[5]="```md"},children={}}}},[1]={level=1,text="function:(args, [optional_args]): returned_a, returned_b",content={[0]="```",[1]="",[2]="For methods, the type they belong to should be included on the left as though that method were being invoked, separated from the function name with a colon.",[3]="```md"},children={}},[2]={level=1,text="class:method(args, [optional_args]): returned_a, returned_b",content={[0]="```",[1]="",[2]="Arguments and return values in the signature are just descriptive labels without specified types. For arguments which are optional, they must surrounded with [brackets].",[3]="",[4]="Below the signature, a general description of what the function does and what it's used for appears under a subheading labeled \"Overview\".",[5]="",[6]="```md"},children={[0]={level=2,text="Overview",content={[0]="Does x for y. Useful for cases of z. Only works when w.",[1]="```",[2]="",[3]="After the overview, if the function has arguments, each will be listed in the order they appear in the signature under a subheading labeled \"Arguments\".",[4]="",[5]="Each argument's label should be wrapped in as code using back ticks. The types should link to the relevant document page if it's part of Picotron's API.",[6]="",[7]="If an argument can take different types, each possible type should be listed in that argument definition, with pipes (|) separating them. Below the argument should be a description of what it's used for and how it works.",[8]="",[9]="",[10]="```md"},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`argument1`: [userdata](picotron_api/userdata/readme.md)|integer",content={[0]="Used to determine x. If the type is an integer, y will happen.",[1]=""},children={}},[1]={level=3,text="`argument2`: string",content={[0]="The string used to do z.",[1]="```",[2]="",[3]="After the arguments, if the function has return values, each will be listed in the order they appear in the signature under a subheading labeled \"Returns\", using the same structuring rules as the arguments.",[4]="",[5]="```md"},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`return_value`: thread|nil",content={[0]="The thread created by x. Will return nil if y condition is not met.",[1]="```",[2]="",[3]="At the end of the definition of the function, one or more examples may be added to demonstrate how the function is used.",[4]="",[5]="````md"},children={}}}},[3]={level=2,text="Examples",content={[0]="Prints the string \"apple sauce\"",[1]="```",[2]="print(\"apple sauce\")",[3]="```",[4]="````",[5]="",[6]="If there's another overload for the function or method, it can go after each of these subheading as another heading.",[7]=""},children={}},[4]={level=2,text="Updating the search engine DB",content={[0]="",[1]="Open the [ripper](https://astralsparv.github.io/Picotron-Wiki/ripper/) page & simply drag and drop the Picotron-Wiki folder.",[2]="",[3]="Download the file and replace /docs/db.json with it (in the repository)."},children={}}}}}},[1]={name="main_to_do.md",path="/main_to_do.md",data={[0]={level=1,text="to do",content={[0]="",[1]="this is features that are more important/requested to be documented",[2]="",[3]="* userdata",[4]="* gui"},children={}}}},[2]={name="README.md",path="/README.md",data={[0]={level=1,text="Picotron Wiki",content={[0]=""},children={[0]={level=2,text="Wiki Information",content={[0]="",[1]="A likely futile attempt to support the documentation of [Picotron](https://www.lexaloffle.com/picotron.php).",[2]="",[3]="Hopefully having a markdown viewer cartridge with the ability to view all of this information within Picotron natively (& any github pages in extension)",[4]="",[5]="Information on contribution to documentation is [here](documenting.md)",[6]=""},children={}},[1]={level=2,text="Search Engine",content={[0]="",[1]="There is a search engine for the Picotron Wiki.",[2]="It can be found [here](https://astralsparv.github.io/Picotron-Wiki/)",[3]=""},children={}},[2]={level=2,text="Picotron Information",content={[0]="",[1]="Information on Picotron can be found [here](information/whatis.md)",[2]=""},children={}},[3]={level=2,text="System documentation",content={[0]="",[1]="System documentation can be found [here](system/readme.md)",[2]="",[3]="Documenting every section of `/system`",[4]=""},children={}},[4]={level=2,text="Picotron API",content={[0]="",[1]="Documentation on the Picotron API can be found [here](picotron_api/readme.md)",[2]=""},children={}},[5]={level=2,text="Environment",content={[0]="",[1]="Documentation on the ecosystem/environment of Picotron can be found [here](environment/readme.md)",[2]=""},children={}},[6]={level=2,text="Guides",content={[0]="",[1]="Guides for Picotron can be found [here](guides/readme.md)",[2]=""},children={}},[7]={level=2,text="Contributors",content={[0]="",[1]="@Podepi - GUIs",[2]="",[3]="[@KeyboardDanni](https://github.com/KeyboardDanni) - GUI overview",[4]="",[5]="[@abledbody](https://github.com/abledbody) - Userdata",[6]="",[7]="[@akd-io](https://github.com/akd-io) - stat documentation support",[8]="",[9]="[@Maxine](https://github.com/MaxTheMooshroom) - stat documentation support",[10]="",[11]="@bloodninja - 720p upscaler documentation",[12]="",[13]="@Astralsparv - creator/writing up of lots of general things"},children={}}}}}},[3]={name="readme.md",path="/system/readme.md",data={[0]={level=1,text="system",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on things related to `/system/`",[2]="",[3]="[System Persistence](persistence/main.md)",[4]="",[5]="[Details of /system (the per file nitty gritty information)](details/readme.md)"},children={}}}}}},[4]={name="main.md",path="/system/persistence/main.md",data={[0]={level=1,text="Persistence",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="How System persistence works.",[2]="",[3]="System persistence allows or you to customise the `/system` folder in Picotron (the system files of it)",[4]=""},children={}},[1]={level=2,text="Persisting Picotron",content={[0]="You can do this easily by opening the Picotron Terminal and typing",[1]="```lua",[2]="cp(\"/system\",\"/system.\")",[3]="```",[4]="",[5]="This creates a clone of your picotron system that is editable by the Host Operating System - this causes all changes to `/system` to be **permenant** from both edits within and outside of Picotron.",[6]=""},children={}},[2]={level=2,text="Use cases",content={[0]="",[1]="You could use this for editing system files such as the default software used, e.g: using a different filenav or code editor by default.",[2]="",[3]="This is used within the [Picotron Distribution System](https://github.com/Astralsparv/Distribution_Manager.p64/blob/main/distribution_manager.p64) to allow custom operating systems.",[4]=""},children={}},[3]={level=2,text="v0.2.2 (unreleased)",content={[0]="",[1]="Going by communications with Zep, `/system` persistence is going to be supported more, allowing for you to have passthrough files rather than cloning the entire `/system` drive to change something.",[2]="",[3]="This allows for stuff like distributions to not affect the licensing of `/system`.",[4]="",[5]="This works by:",[6]="",[7]="Picotron's `/system` being defaulted to the system rom (stored within the Picotron runtime).",[8]="",[9]="*If* the folder `/picotron/drive/system` exists, it will overwrite any files that exist in `/picotron/drive/system` into Picotron's loaded `/system`.",[10]="",[11]="This adds better support for updating Picotron with a persistent system as you can safely edit stuff like system apps without losing any updates to other things like libraries or the wm & pm.",[12]=""},children={[0]={level=3,text="Example",content={[0]="",[1]="Within `/picotron/drive/system`, you have the folder `/apps/` which contains `filenav.p64`, this is a custom filenav for Picotron - rather than the built in filenav.",[2]="",[3]="When opening Picotron, everything will be loaded as if that doesn't exist and the `filenav.p64` will then overwrite `/system/apps/filenav.p64` in Picotron.",[4]="",[5]="This happens *before* the boot sequence (running `boot.lua`) so that your system can be fully edited."},children={}}}}}}}},[5]={name="readme.md",path="/system/details/readme.md",data={[0]={level=1,text="system > details",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on all raw files of `/system/`",[2]="",[3]="[`/system/util`](util/)"},children={}}}}}},[6]={name="readme.md",path="/system/details/util/readme.md",data={[0]={level=1,text="util",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Documentation on all the default utilities seen in `/system/util`.",[1]="",[2]="Fully documented as of `0.2.1e`",[3]=""},children={}},[1]={level=2,text="Commands",content={[0]="",[1]="[config](config/)",[2]="",[3]="[cp](cp/)",[4]="",[5]="[default_app](default_app/)",[6]="",[7]="[dir](dir/)",[8]="",[9]="[edit](edit/)",[10]="",[11]="[export](export/)",[12]="",[13]="[folder](folder/)",[14]="",[15]="[help](help/)",[16]="",[17]="[info](info/)",[18]="",[19]="[kill](kill/)",[20]="",[21]="[load](load/)",[22]="",[23]="[ls](ls/)",[24]="",[25]="[mkdir](mkdir/)",[26]="",[27]="[mount](mount/)",[28]="",[29]="[mv](mv/)",[30]="",[31]="[open](open/)",[32]="",[33]="[ps](ps/)",[34]="",[35]="[pwc](pwc/)",[36]="",[37]="[pwd](pwd/)",[38]="",[39]="[reboot](reboot/)",[40]="",[41]="[rm](rm/)",[42]="",[43]="[run](run/)",[44]="",[45]="[save](save/)",[46]="",[47]="[shutdown](shutdown/)"},children={}}}}}},[7]={name="main.md",path="/system/details/util/shutdown/main.md",data={[0]={level=1,text="shutdown",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Shuts down Picotron",[2]="",[3]="Source: [source.lua](source.lua)"},children={}}}}}},[8]={name="main.md",path="/system/details/util/save/main.md",data={[0]={level=1,text="save [path]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Runs the current loaded cartridge (`/ram/cart/`), optionally to a new location `[path]`",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[path]",content={[0]="",[1]="Optional location to save to, automatically appends .p64 if there is no extension",[2]=""},children={}}}},[2]={level=2,text="Future",content={[0]="",[1]="Taken from comments in zep's code",[2]=""},children={[0]={level=3,text="Saving as a folder",content={[0]="",[1]="`-- add extension when none is given (to do: how to save to a regular folder with no extension in name? maybe just don't do that?)`",[2]="",[3]="Possibly making it possible to save a cartridge to a folder, rather than a .p64 file, so that the host OS can open the p64.",[4]="",[5]="> This can be done by creating a folder named `cartridge.p64` in the host os in the meantime."},children={}}}}}}}},[9]={name="main.md",path="/system/details/util/run/main.md",data={[0]={level=1,text="run",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Runs the current loaded cartridge (`/ram/cart/`)",[2]="",[3]="Source: [source.lua](source.lua)"},children={}}}}}},[10]={name="main.md",path="/system/details/util/rm/main.md",data={[0]={level=1,text="rm filename",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`rm` deletes a file or directory (including all of the directory's contents).",[2]="",[3]="Attempting to delete `/desktop/host` just causes the Host OS to unmount, rather than deleting the folder and contents.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="filename",content={[0]="",[1]="The file or folder to delete",[2]=""},children={}},[2]={level=2,text="Possible Future",content={[0]="",[1]="Taken from comments in zep's code",[2]="Could be incorrect as zep copy pasted from `cp` command, but didn't rectify the name",[3]="",[4]="```",[5]="--[[",[6]="	cp src dest",[7]="",[8]="	resulting file should be idential to src (can't just fetch and then store)",[9]="",[10]="	to do:",[11]="		-r recursive // rm() is currently recursive by default though",[12]="		how to do interactive copying? (prompt for overwrite)",[13]="]]",[14]="```",[15]=""},children={}},[3]={level=2,text="[options]",content={[0]=""},children={[0]={level=3,text="`-r`",content={[0]="",[1]="Recursive remove",[2]="",[3]="Unsure of how to handle overwriting files."},children={}}}}}}}},[11]={name="main.md",path="/system/details/util/reboot/main.md",data={[0]={level=1,text="reboot",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Reboots Picotron",[2]="",[3]="Source: [source.lua](source.lua)"},children={}}}}}},[12]={name="main.md",path="/system/details/util/pwd/main.md",data={[0]={level=1,text="pwc",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Returns the current working path",[2]="",[3]="Source: [source.lua](source.lua)"},children={}}}}}},[13]={name="main.md",path="/system/details/util/pwc/main.md",data={[0]={level=1,text="pwc",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Returns the current loaded cartridge",[2]="",[3]="Source: [source.lua](source.lua)"},children={}}}}}},[14]={name="main.md",path="/system/details/util/ps/main.md",data={[0]={level=1,text="ps",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Lists all active processes and details",[2]="",[3]="Identical to the about.p64 view of processes but a snapshot, rather than actively updating",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={[0]={level=3,text="Details shown",content={[0]=""},children={[0]={level=4,text="pid",content={[0]="",[1]="PID of the process",[2]=""},children={}},[1]={level=4,text="name",content={[0]="",[1]="Name of the process",[2]=""},children={}},[2]={level=4,text="cpu",content={[0]="",[1]="CPU usage of the process (in decimal, rather than percentage)",[2]=""},children={}},[3]={level=4,text="pri",content={[0]="",[1]="Priority of the process",[2]=""},children={}},[4]={level=4,text="mem",content={[0]="",[1]="Memory usage of the process in Kilobytes",[2]=""},children={}}}}}}}}}},[15]={name="main.md",path="/system/details/util/open/main.md",data={[0]={level=1,text="open path",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Identical to `edit`",[2]="",[3]="Open the file specified",[4]="",[5]="Fails if there is no default program to open it",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="path",content={[0]="",[1]="Path to the file you want to open"},children={}}}}}}}},[16]={name="main.md",path="/system/details/util/mv/main.md",data={[0]={level=1,text="mv [options] src dest",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Moves `src` to `dest`",[2]="",[3]="Use `mv --help` for the built in instructions",[4]="",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[options]",content={[0]="",[1]="Optional arguments for the command",[2]=""},children={}},[1]={level=3,text="`-f`",content={[0]="",[1]="overwrite `dest` instead of placing it inside of `dest`",[2]=""},children={}},[2]={level=3,text="`-n`",content={[0]="no clobber, skips copying files if a file with the same name already exists in `dest`",[1]=""},children={}},[3]={level=3,text="src",content={[0]="",[1]="A folder or file to be moved",[2]=""},children={}},[4]={level=3,text="dest",content={[0]="",[1]="Location of the file to be moved to"},children={}}}}}}}},[17]={name="main.md",path="/system/details/util/mount/main.md",data={[0]={level=1,text="mount target origin",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Mounts folder at `origin` to `target`",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="target",content={[0]="",[1]="Mounting point of `origin`",[2]=""},children={}},[1]={level=3,text="origin",content={[0]="",[1]="Folder to mount at `target`"},children={}}}}}}}},[18]={name="main.md",path="/system/details/util/mkdir/main.md",data={[0]={level=1,text="mkdir path",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Creates a folder in `path`",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="path",content={[0]="",[1]="Relative location you want to create a path in",[2]="",[3]="Relative to the current working directory",[4]=""},children={}}}}}}}},[19]={name="main.md",path="/system/details/util/ls/main.md",data={[0]={level=1,text="ls [path]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Identical to `dir`",[2]="List all files in the directory",[3]="",[4]="Defaults to your current working path",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[path]",content={[0]="",[1]="Optional argument for the path you want to list files of, instead of your current working path"},children={}}}}}}}},[20]={name="main.md",path="/system/details/util/load/main.md",data={[0]={level=1,text="load [options] path",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Loads `path` as a cartridge",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[options]",content={[0]=""},children={[0]={level=4,text="`-b`",content={[0]="",[1]="Open files from the workspace in the background, rather than stealing the focus of the current window",[2]=""},children={}}}},[1]={level=3,text="path",content={[0]="",[1]="The path, folder or file, to a cartridge",[2]="",[3]="Append with `bbs://` protocol or `#` to load a cartridge from the bbs"},children={}}}}}}}},[21]={name="main.md",path="/system/details/util/kill/main.md",data={[0]={level=1,text="kill pid",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Kills (shuts down) the process with the pid `pid`",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="pid",content={[0]="",[1]="The process id of the process you want to kill"},children={}}}}}}}},[22]={name="main.md",path="/system/details/util/help/main.md",data={[0]={level=1,text="folder [path]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Prints helpful cheatsheet for Picotron",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Output",content={[0]="",[1]="    - Picotron Cheatsheet",[2]="        ",[3]="        ls (or dir)       \fd list files in the current folder\",[4]="        cd <directory>    \fd change directory (folder)\",[5]="        mkdir <directory> \fd create a directory\",[6]="        load <filename>   \fd load a cartridge (.p64) into /ram/cart\",[7]="        save <filename>   \fd save /ram/cart back to a .p64 file\",[8]="        reset             \fd reset draw state\",[9]="        ",[10]="        CTRL-R            \fd run the loaded cartridge\",[11]="        ESC               \fd stop program or toggle between editor and output\",[12]="        CTRL-L            \fd clear the terminal\",[13]="        ",[14]="        To try out a demo:",[15]="        $ cd /system/demos\",[16]="        $ load highway\",[17]="",[18]="        .. and then CTRL-R to run it\"},children={}}}}}},[23]={name="main.md",path="/system/details/util/info/main.md",data={[0]={level=1,text="info",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Displays information about the current loaded cartridge",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={[0]={level=3,text="Information displayed",content={[0]="",[1]="Path to the cartridge on disk",[2]="",[3]="Compressed ROM size & compression percentage",[4]="",[5]="Whether there are unsaved changes",[6]="",[7]="Shows if there are external changes"},children={}}}}}}}},[24]={name="main.md",path="/system/details/util/folder/main.md",data={[0]={level=1,text="folder [path]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Opens the current working folder or `[path]` in the host OS.",[2]="",[3]="You cannot open the `/ram/` folder or any `/ram/` subfolders.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[path]",content={[0]="",[1]="Lets you define the folder to open"},children={}}}}}}}},[25]={name="main.md",path="/system/details/util/export/main.md",data={[0]={level=1,text="export [outfile]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Exports the loaded cartridge (`/ram/cart`)",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="outfile",content={[0]="",[1]="File location to export",[2]="",[3]="Supported filetypes to export to:",[4]=""},children={[0]={level=4,text="`.p64.png`",content={[0]="",[1]="BBS Format for cartridges",[2]=""},children={}},[1]={level=4,text="`.html`",content={[0]="",[1]="One-file web export",[2]=""},children={}},[2]={level=4,text="`.bin`",content={[0]="",[1]="Binary exports for windows, linux and mac",[2]=""},children={}}}}}},[2]={level=2,text="Future",content={[0]="",[1]="Ability to export from any path, rather than `/ram/cart`"},children={}}}}}},[26]={name="main.md",path="/system/details/util/edit/main.md",data={[0]={level=1,text="edit path",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Edit the file specified",[2]="",[3]="Fails if there is no default program to edit it",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="path",content={[0]="",[1]="Path to the file you want to edit"},children={}}}}}}}},[27]={name="main.md",path="/system/details/util/dir/main.md",data={[0]={level=1,text="dir [path]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Identical to `ls`",[2]="List all files in the directory",[3]="",[4]="Defaults to your current working path",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[path]",content={[0]="",[1]="Optional argument for the path you want to list files of, instead of your current working path"},children={}}}}}}}},[28]={name="main.md",path="/system/details/util/default_app/main.md",data={[0]={level=1,text="default_app",content={[0]=""},children={[0]={level=2,text="Setting extensions `default_app ext [path_to_program]`",content={[0]="",[1]="Sets the default programs for extensions, edits `\"/appdata/system/default_apps.pod\"`",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={[0]={level=3,text="Arguments",content={[0]=""},children={[0]={level=4,text="ext",content={[0]="",[1]="The extension you would like to set the default app for, e.g: `lua`",[2]=""},children={}},[1]={level=4,text="[path_to_program]",content={[0]="",[1]="The path to the program that should handle your file.",[2]="",[3]="Leave blank to remove the default app for the extension",[4]=""},children={}}}}}},[1]={level=2,text="List current extensions `default_app -l`",content={[0]="",[1]="Lists all current default extensions you have set"},children={}}}}}},[29]={name="main.md",path="/system/details/util/cp/main.md",data={[0]={level=1,text="cp [options] src dest",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`cp` lets you copy a file (`src`) to a folder (`dest`)",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[options]",content={[0]="",[1]="Optional arguments for the command",[2]=""},children={}},[1]={level=3,text="`-f`",content={[0]="",[1]="overwrite `dest` instead of placing it inside of `dest`",[2]=""},children={}},[2]={level=3,text="`-n`",content={[0]="no clobber, skips copying files if a file with the same name already exists in `dest`",[1]=""},children={}}}},[2]={level=2,text="src",content={[0]="",[1]="The path to the source file/folder",[2]=""},children={}},[3]={level=2,text="dest",content={[0]="",[1]="Path to a folder/file to replace",[2]="",[3]="Overwrites the folder with option `-f`",[4]=""},children={}},[4]={level=2,text="Future",content={[0]="Taken from comments in zep's code",[1]=""},children={}},[5]={level=2,text="[options]",content={[0]=""},children={[0]={level=3,text="`-r`",content={[0]="",[1]="Recursive copy",[2]="",[3]="Unsure of how to handle overwriting files."},children={}}}}}}}},[30]={name="main.md",path="/system/details/util/config/main.md",data={[0]={level=1,text="config [key] [value]",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`config` allows you to edit picotrons system settings (`/appdata/system/settings.pod`)",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]="",[1]="See [/environment/settings/readme.md] for arguments, these both are equal, simply being a [key]=[value] for `/appdata/system/settings.pod`"},children={}}}}}},[31]={name="readme.md",path="/picotron_api/readme.md",data={[0]={level=1,text="Picotron API",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on all of the Picotron API",[2]="",[3]="[Functions](functions/readme.md)",[4]="[GUI](gui/readme.md)",[5]="[Userdata](userdata/readme.md)"},children={}}}}}},[32]={name="readme.md",path="/picotron_api/userdata/readme.md",data={[0]={level=1,text="Picotron API > userdata",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="A userdata is a specialized array type that contains numeric values, and is optimized for bulk operations. Because of this, they are an essential tool for optimizing code in Picotron.",[1]="",[2]="Userdatas are especially useful for representing large amounts of numerical data in a manner that's easy to manipulate and copy. They are also a pragmatic way to do operations based in linear algebra, and have a dedicated set of vector/matrix-specific methods, such as [`magnitude()`](methods/magnitude/main.md), [`cross()`](methods/cross/main.md) and [`matmul()`](methods/magnitude/main.md).",[3]="",[4]="Userdatas are a reference type. You can have multiple variables pointing to the same userdata. Many of userdata's methods and operators create and return new userdatas by default, rather than mutating the existing userdata, but unlike a string, they are still mutable by certain operations. You can create a new copy of a userdata by calling its [`copy()`](methods/copy/main.md) method with no arguments.",[5]=""},children={}},[1]={level=2,text="Creation",content={[0]="Userdatas are not resizable once created. However, most of the time the actual expense of allocating a userdata is several times cheaper than the overhead of calling the Lua function that would do so. There are several ways to make a new userdata.",[1]="",[2]="- From scratch, using the [`userdata()`](/picotron_api/functions/userdata/main.md) or [`vec()`](/picotron_api/functions/vec/main.md) functions.",[3]="- When using an operator on an existing userdata.",[4]="- By calling an [operation](#bulk-operations) function when the `target` argument is falsey.",[5]=""},children={}},[2]={level=2,text="Numerical types",content={[0]="Every userdata is an array containing one of the following numerical types:",[1]="",[2]="- u8 - An unsigned 8-bit integer.",[3]="- i16 - A signed 16-bit integer.",[4]="- i32 - A signed 32-bit integer.",[5]="- i64 - A signed 64-bit integer.",[6]="- f64 - A 64-bit floating point number, useful for representing fractional values to high precision. This is also the type that will be created by the [`vec()`](/picotron_api/functions/vec/main.md) function.",[7]="",[8]="If any operation on an integer typed userdata, including setting an element explicitly, would cause a number to overflow or underflow, the value will wrap around.",[9]=""},children={}},[3]={level=2,text="Indexing",content={[0]="You can fetch the total number of elements in a userdata by using the [`#`](metamethods/__len/main.md) operator, much like you would for a table array. For the number of rows or columns, you can use the [`height()`](methods/height/main.md), [`width()`](methods/width/main.md), or [`attribs()`](methods/attribs/main.md) methods.",[1]="",[2]="2D userdatas are laid out contiguously in memory. The first row in its entirety is followed by the second, then the third, and so on, in lexicographical order. In other words, 2D userdatas have flat indices.",[3]="",[4]="There are two ways to index a userdata. You can do it the same way you would for a table, by using the [`[i]`](metamethods/__index/main.md) syntax. You can also call the [`get()`](methods/get/main.md) method, which will allow you to use row and column indices instead of a flat index.",[5]="",[6]="Unlike a table-based array, userdatas are indexed starting from 0. This is especially important to keep in mind when writing a for loop, because Lua uses inclusive/inclusive range syntax.",[7]="",[8]="```lua",[9]="local tab = {0, 1, 2, 3, 4}",[10]="",[11]="-- Tables are 1-indexed, meaning the final index to iterate over",[12]="-- should be the same as the total count of elements in the array.",[13]="-- This is why Lua is inclusive of #tab in the iteration.",[14]="for i = 1, #tab do",[15]="	?tab[i]",[16]="end",[17]="",[18]="local ud = vec(0, 1, 2, 3, 4)",[19]="",[20]="-- Userdatas are 0-indexed. The final index that should be iterated",[21]="-- is not the same as the total count of elements, meaning you will",[22]="-- have to subtract one from the count. If you forget to do this,",[23]="-- the iterator will index the userdata out of range, fetching a",[24]="-- nil value.",[25]="-- It's also worth noting you will need this mindset for ud:width()",[26]="-- and ud:height() as well, since they also give you counts, not",[27]="-- final indices.",[28]="for i = 0, #ud - 1 do",[29]="	?ud[i]",[30]="end",[31]="```",[32]="",[33]="With this in mind, the following snippet is meant to demonstrate where each flat index ends up in a 2D userdata's coordinates.",[34]="```lua",[35]="-- ud is created with a layout like so:",[36]="-- 00 01 02",[37]="-- 03 04 05",[38]="-- 06 07 08",[39]="local ud = userdata(\"u8\", 3, 3, \"000102030405060708\")",[40]="",[41]="-- ud:get(x, y) uses column/row coordinates rather than a flat index.",[42]="-- First row",[43]="assert(ud[0] == ud:get(0, 0))",[44]="assert(ud[1] == ud:get(1, 0))",[45]="assert(ud[2] == ud:get(2, 0))",[46]="",[47]="-- Second row",[48]="assert(ud[3] == ud:get(0, 1))",[49]="assert(ud[4] == ud:get(1, 1))",[50]="assert(ud[5] == ud:get(2, 1))",[51]="",[52]="-- Third row",[53]="assert(ud[6] == ud:get(0, 2))",[54]="assert(ud[7] == ud:get(1, 2))",[55]="assert(ud[8] == ud:get(2, 2))",[56]="```",[57]=""},children={}},[4]={level=2,text="Dimensionality",content={[0]="Userdatas can have one or two dimensions. The [`userdata()`](/picotron_api/functions/userdata/main.md) function can be called with or without a `height` argument to produce a 2D or 1D userdata, respectively, and [`vec()`](/picotron_api/functions/vec/main.md) will always produce a 1D userdata.",[1]="",[2]="1D userdatas do not have a height. That doesn't mean that their height value is 1 or 0, but that height is not an attribute that they keep track of. Having or not having a height is a property that is stored on the userdata. This will cause certain functions, such as [`get()`](methods/get/main.md) and [`set()`](methods/set/main.md), to behave differently, under the assumption that the effective height of a 1D userdata is always 1.",[3]=""},children={}},[5]={level=2,text="Bulk operations",content={[0]="Userdatas have several bulk number manipulation methods that all work in roughly the same way. These operations are the main reason why userdatas are an attractive tool for optimization, because they skip the overhead of using a for loop in Lua, where each operation costs an order of magnitude more than it would running in native code, where bulk operations do most of their work.",[1]="",[2]="One-op:",[3]="- [`abs`](methods/abs/main.md)",[4]="- [`sgn`](methods/sgn/main.md)",[5]="- [`sgn0`](methods/sgn0/main.md)",[6]="- [`crc`](methods/crc/main.md)",[7]="",[8]="Two-op:",[9]="- [`copy`](methods/copy/main.md)",[10]="- [`add`](methods/add/main.md)",[11]="- [`sub`](methods/sub/main.md)",[12]="- [`mul`](methods/mul/main.md)",[13]="- [`div`](methods/div/main.md)",[14]="- [`idiv`](methods/idiv/main.md)",[15]="- [`mod`](methods/mod/main.md)",[16]="- [`pow`](methods/pow/main.md)",[17]="- [`band`](methods/band/main.md)",[18]="- [`bor`](methods/bor/main.md)",[19]="- [`bxor`](methods/bxor/main.md)",[20]="- [`shl`](methods/shl/main.md)",[21]="- [`shr`](methods/shr/main.md)",[22]="- [`min`](methods/min/main.md)",[23]="- [`max`](methods/max/main.md)",[24]="",[25]="The signature for these methods is `ud = lhs:op([rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count])`, but to build robust knowledge, this section will start with the most basic usage and gradually add additional features from each of the arguments.",[26]="",[27]="For the one-op methods, the `rhs` argument is completely ignored, unless `lhs` is not a userdata. Without any arguments this will just apply the operation to every element in the userdata. `ud = lhs:abs()` will create a userdata `ud` which is identical to `lhs`, except every value will be absolute instead of signed.",[28]="",[29]="For the two-op methods, `rhs` is required, and will be applied just like the respective instruction the operation is named after. `ud = lhs:div(rhs)` will produce a userdata `ud` which is identical to `lhs`, except each element will be divided by the element in `rhs` which shares the same index. `ud = vec(1, 2):div(vec(2, 3))` will produce a userdata with the elements in index 0 and 1 being 1/2 and 2/3, respectively.",[30]="",[31]="Either `lhs` or `rhs` can be a scalar value, which will be broadcast to every element in the userdata on the opposite side. You can use a scalar value for the left hand side by calling the operation as a function, either on the userdata, like `ud = rhs.div(1, rhs)`, or through the `USERDATA` table, `ud = USERDATA.div(1, rhs)`. The `USERDATA` table is not mentioned in the official documentation, so while it's a perfectly practical way to do this, it is unknown if it's reliable from version to version.",[32]="",[33]="Userdatas have their operators aliased to these two-op methods, so `vec(1, 2):div(vec(2, 3))` is exactly equivalent to `vec(1, 2) / vec(2, 3)`. This will allow you to use scalar values for `lhs` easily, since `rhs` will get the call with the relevant operands. For example, you can get a userdata of reciprocals through the expression `ud = 1 / vec(2, 3)`.",[34]="",[35]="`dest` controls which userdata the resulting values should be written to. If `dest` is falsey, a copy of `lhs` will be created, and the values will be written to that. If `dest` is a userdata, then the values will be written into that userdata. If `dest` is some other truthy value, then the values will be written directly to `lhs`. In every case, the userdata that was written to will be returned.",[36]="",[37]="```lua",[38]="local dest = vec(0, 0, 0)",[39]="local lhs = vec(1, 2)",[40]="local rhs = vec(2, 3)",[41]="",[42]="-- Result will be a new userdata containing lhs/rhs.",[43]="local result = lhs:div(rhs)",[44]="-- Replaces the values in lhs with lhs/rhs.",[45]="-- The result variable will point to the same userdata as lhs.",[46]="local result = lhs:div(rhs, true)",[47]="-- Replaces the values in dest with lhs/rhs.",[48]="-- The result variable will point to the same userdata as dest.",[49]="local result = lhs:div(rhs, dest)",[50]="```",[51]="",[52]="Below is a reference table for the behavior of `dest`.",[53]="|`dest`             |`lhs`       |`rhs`   |written to     |",[54]="|-------------------|------------|--------|---------------|",[55]="|userdata           |any         |any     |`dest`         |",[56]="|truthy non-userdata|userdata    |any     |`lhs`          |",[57]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[58]="|falsey             |userdata    |any     |a copy of `lhs`|",[59]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[60]="",[61]="The next six arguments dictate how the userdatas will be iterated over.",[62]="",[63]="`read_start` and `write_start` control where iteration will start for `rhs` and `lhs`, respectively. These both default to 0, which is why without these arguments, both inputs and the output operate on the same indices for each operation. Setting `read_start` to some other positive value will cause the indices being read from `rhs` to be offset by as much, and similarly for `write_start`, the indices being read from `lhs` and written to in the destination userdata will be offset.",[64]="",[65]="The fact that the index that is being read from `lhs` is also the one being written to in the destination userdata is worth underlining. Even with additional arguments, this correlation never changes.",[66]="",[67]="The operation `ud = vec(1, 2, 3):add(vec(1, 2), false, 0, 1)` will result in `ud` being populated with `1, 3, 5`. The first value is skipped, the second value is `2 + 1`, and the third value is `3 + 2`.",[68]="",[69]="All iteration during the call will automatically clamp to a safe range, never letting accesses go out of bounds. What this means in this case is that if the iteration would cause the `rhs` index to go out of range of `rhs`, or the `lhs` index to go out of range of either `lhs` or the destination userdata, iteration will stop. Without the `group_count` argument, this will stop the function, and return the result immediately.",[70]="",[71]="With just these arguments, it is possible to perform a prefix sum, or any running total operation, by writing to the same userdata that is being read in such a way that the written values will be revisited and used for a future operation.",[72]="```lua",[73]="local ud = userdata(\"i64\", 10)",[74]="-- Copies 1 into every element of ud.",[75]="ud:copy(1, true)",[76]="-- Sums element i with element i + 1, and writes to element i + 1.",[77]="-- i + 1 will be immediately revisited in the next iteration as i, meaning",[78]="-- that the sum total propagates forwards with each iteration.",[79]="ud:add(ud, true, 0, 1)",[80]="ud:add(ud, true, 0, 1) -- Does it again.",[81]="",[82]="for i = 0, #ud - 1 do",[83]="	?ud[i] -- Prints triangle numbers up to 55.",[84]="end",[85]="```",[86]="",[87]="The `group_size` argument controls the number of consecutive elements that will be operated on. For instance, if you want to put an arbitrary section of one userdata into an equivalently sized section of another userdata, you can use `group_size` to indicate how many elements should be moved. `lhs:copy(rhs, true, 5, 2, 3)` will copy 3 consecutive elements starting from index 5 of `rhs` into `lhs` starting at index 2.",[88]="",[89]="`read_increment`, `write_increment` and `group_count` control an additional layer of iteration. All three of these arguments default to 1. When `group_count` is greater than 1, the entire previous set of operations will happen that many times. Each time, `read_start` and `write_start` will be incremented by `read_increment` and `write_increment`. This is why `group_size` and `group_count` refer to 'groups'. These control the size and number of groups of concecutive elements that will be operated on.",[90]="",[91]="If you wanted to divide every other element from `lhs` with each element from `rhs`, you could do so by using a `group_size` of 1, `write_increment` of 2, and `group_count` equal to the number of elements in `rhs`. The operation would look like: `ud = lhs:div(rhs, false, 0, 0, 1, 1, 2, #rhs)`",[92]="",[93]="It's also possible to set `read_increment` or `write_increment` to 0, which will cause it to repeatedly index the same section of the array for each group. This is useful for broadcasting scalars and groups of values. For example, you may have a 2D userdata with 3D coordinates in each row.",[94]="",[95]="If you wanted to scale them by 10, and flip them on the z axis, you could do so by calling `scaled = coords:mul(vec(10, 10, -10), false, 0, 0, 3, 0, 3, coords:height())`. By setting `read_increment` to 0, each time a coordinate is done being scaled, it will start over at the begining of the `rhs` vector for every group.",[96]="",[97]="As a final example, if you had a 2D userdata that was 9x9, and you wanted to copy a 3x3 userdata with the top left sitting on the (2, 3) coordinate, you can take advantage of every argument to do so.",[98]="```lua",[99]="local bigger = userdata(\"u8\",9,9,\"1c071c0c1c0c110c11071c0c1c0c110c11101c0c1c0c110c1110110c1c0c110c111011101c0c110c11101110010c110c111011100110110c111011100110010c1110111001100100111011100110010001\")",[100]="",[101]="local smaller = userdata(\"u8\",3,3,\"141a141a1a1a141a14\")",[102]="",[103]="-- Note that because userdatas use flat indices, the element one row",[104]="-- down from any given element is located at i + ud:width().",[105]="bigger:copy(",[106]="	smaller, -- Read from smaller",[107]="	true, -- Write to bigger.",[108]="	0, -- Start reading from smaller at index 0.",[109]="	2 + bigger:width() * 3, -- Start writing to the coordinate (2, 3) on bigger.",[110]="	smaller:width(), -- Write 3 consecutive elements at a time.",[111]="	smaller:width(), -- After each group, read from the next row in smaller.",[112]="	bigger:width(), -- After each group, write to the next row in bigger.",[113]="	smaller:height() -- Write 3 rows.",[114]=")",[115]="",[116]="spr(bigger) -- Draws the bigger userdata to the screen now that it's mutated.",[117]="```",[118]="",[119]="This is effectively a more verbose way to implement the [`blit`](methods/blit/main.md) operation, but it demonstrates what makes these arguments flexible, and why each is useful for bulk data manipulation.",[120]="",[121]="The same rules about overrunning the end of the array that applies to each individual group also applies to `read_i` and `write_i`. If either exceed the end of the array, iteration will stop, and the value will be immediately returned. Note that even if an individual group overruns, this will not stop the next group from operating if `read_i` and `write_i` are still valid indices.",[122]=""},children={}},[6]={level=2,text="References",content={[0]="[userdata()](/picotron_api/functions/userdata/main.md)",[1]="",[2]="[vec()](/picotron_api/functions/vec/main.md)",[3]="",[4]="[methods](methods/readme.md)",[5]=""},children={}}}}}},[33]={name="readme.md",path="/picotron_api/userdata/methods/readme.md",data={[0]={level=1,text="Picotron API > userdata > methods",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on userdata methods for Picotron",[2]=""},children={[0]={level=3,text="Accessors",content={[0]="- [get()](get/main.md)",[1]="- [set()](set/main.md)",[2]="- [row()](row/main.md)",[3]="- [column()](column/main.md)",[4]=""},children={}},[1]={level=3,text="Properties",content={[0]="- [width()](width/main.md)",[1]="- [height()](height/main.md)",[2]="- [attribs()](attribs/main.md)",[3]=""},children={}},[2]={level=3,text="Arithmetic",content={[0]="- [add()](add/main.md)",[1]="- [sub()](sub/main.md)",[2]="- [mul()](mul/main.md)",[3]="- [div()](div/main.md)",[4]="- [idiv()](idiv/main.md)",[5]="- [mod()](mod/main.md)",[6]="- [pow()](pow/main.md)",[7]=""},children={}},[3]={level=3,text="Bitwise",content={[0]="- [band()](band/main.md)",[1]="- [bor()](bor/main.md)",[2]="- [bxor()](bxor/main.md)",[3]="- [shl()](shl/main.md)",[4]="- [shr()](shr/main.md)",[5]=""},children={}},[4]={level=3,text="Piecewise",content={[0]="- [min()](min/main.md)",[1]="- [max()](max/main.md)",[2]="- [abs()](abs/main.md)",[3]="- [sgn()](sgn/main.md)",[4]="- [sgn0()](sgn0/main.md)",[5]=""},children={}},[5]={level=3,text="Linear algebra",content={[0]="- [magnitude()](magnitude/main.md)",[1]="- [distance()](distance/main.md)",[2]="- [dot()](dot/main.md)",[3]="- [cross()](cross/main.md)",[4]="- [transpose()](transpose/main.md)",[5]="- [matmul()](matmul/main.md)",[6]="- [matmul2d()](matmul2d/main.md)",[7]="- [matmul3d()](matmul3d/main.md)",[8]=""},children={}},[6]={level=3,text="Data manipulation",content={[0]="- [copy()](copy/main.md)",[1]="- [take()](take/main.md)",[2]="- [clear()](clear/main.md)",[3]="- [convert()](convert/main.md)",[4]="- [mutate()](mutate/main.md)",[5]="- [sort()](sort/main.md)",[6]="- [lerp()](lerp/main.md)",[7]="- [blit()](blit/main.md)",[8]=""},children={}},[7]={level=3,text="Memory",content={[0]="- [peek()](peek/main.md)",[1]="- [poke()](poke/main.md)",[2]=""},children={}},[8]={level=3,text="Hashing",content={[0]="- [crc()](crc/main.md)"},children={}}}}}}}},[34]={name="main.md",path="/picotron_api/userdata/methods/width/main.md",data={[0]={level=1,text="userdata:width(): width",content={},children={[0]={level=2,text="Overview",content={[0]="Gets the width of the userdata.",[1]=""},children={}},[1]={level=2,text="Returns",content={},children={[0]={level=3,text="`width`: integer",content={[0]="The number of columns in the userdata.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="-- Be careful when reading the height of a userdata. It can be nil.",[2]="local h = ud:height()",[3]="",[4]="if h then",[5]="	for y = 0, h - 1 do",[6]="		for x = 0, ud:width() - 1 do",[7]="			?ud:get(x, y)",[8]="		end",[9]="	end",[10]="else",[11]="	for x = 0, ud:width() - 1 do",[12]="		?ud:get(x)",[13]="	end",[14]="end",[15]="```"},children={}}}}}},[35]={name="main.md",path="/picotron_api/userdata/methods/sub/main.md",data={[0]={level=1,text="sub(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Subtracts elements on the right hand side from elements on the left hand side.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the subtraction operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the subtraction operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[36]={name="main.md",path="/picotron_api/userdata/methods/transpose/main.md",data={[0]={level=1,text="userdata:transpose(): ud",content={},children={[0]={level=2,text="Overview",content={[0]="Swaps the `x` and `y` indices of all the values in the userdata, as well as the width and height of the userdata. This is equivalent to mirroring the userdata along the diagonal that starts from the low indices.",[1]=""},children={}},[1]={level=2,text="Returns",content={},children={[0]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The transposed userdata. Always 2D, regardless of if the original userdata was 2D or not.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="local ud_in = userdata(\"u8\", 2, 3)",[2]="ud_in:set(0, 0,",[3]="	1, 2,",[4]="	3, 4,",[5]="	5, 6",[6]=")",[7]="",[8]="-- Transposing the userdata will reorganize it like this:",[9]="-- 1, 3, 5",[10]="-- 2, 4, 6",[11]="local ud_out = ud_in:transpose()",[12]="",[13]="assert(ud_in:get(0, 0) == ud_out:get(0, 0))",[14]="assert(ud_in:get(1, 0) == ud_out:get(0, 1))",[15]="assert(ud_in:get(0, 1) == ud_out:get(1, 0))",[16]="assert(ud_in:get(1, 1) == ud_out:get(1, 1))",[17]="assert(ud_in:get(0, 2) == ud_out:get(2, 0))",[18]="assert(ud_in:get(1, 2) == ud_out:get(2, 1))",[19]="```"},children={}}}}}},[37]={name="main.md",path="/picotron_api/userdata/methods/shr/main.md",data={[0]={level=1,text="shr(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Bitshifts elements in the left hand side to the right by elements in the right hand side.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the bitshift right operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the bitshift right operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[38]={name="main.md",path="/picotron_api/userdata/methods/shl/main.md",data={[0]={level=1,text="shl(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Bitshifts elements in the left hand side to the left by elements in the right hand side.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the bitshift left operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the bitshift left operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[39]={name="main.md",path="/picotron_api/userdata/methods/sgn0/main.md",data={[0]={level=1,text="sgn0([lhs], [rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the sign of elements in a userdata, producing -1 for values less than 0, 1 for values greater than 0, and leaving values of 0 untouched.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`[lhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The userdata used as the input for the sign operations.",[1]=""},children={}},[1]={level=3,text="`[rhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="Alternative source userdata. Only used if `lhs` is not a userdata.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[40]={name="main.md",path="/picotron_api/userdata/methods/sgn/main.md",data={[0]={level=1,text="sgn([lhs], [rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the sign of elements in a userdata, producing -1 for values less than 0, and 1 for values 0 or greater.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`[lhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The userdata used as the input for the sign operations.",[1]=""},children={}},[1]={level=3,text="`[rhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="Alternative source userdata. Only used if `lhs` is not a userdata.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[41]={name="main.md",path="/picotron_api/userdata/methods/set/main.md",data={[0]={level=1,text="userdata:set(i, ...)",content={},children={[0]={level=2,text="Overview",content={[0]="For 1D userdatas, sets one or more values in the userdata starting at index `i`. Will do nothing if the starting index is out of range.",[1]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`i`: number",content={[0]="The index to start setting values from. Will be floored.",[1]=""},children={}},[1]={level=3,text="`...`: number",content={[0]="Each of the arguments to set.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="local ud = userdata(\"f64\", 6)",[2]="ud:set(3, -1, -2, -3)",[3]="",[4]="?ud[0] -- 0",[5]="?ud[1] -- 0",[6]="?ud[2] -- 0",[7]="?ud[3] -- -1",[8]="?ud[4] -- -2",[9]="?ud[5] -- -3",[10]="```",[11]=""},children={}}}},[1]={level=1,text="userdata:set([column], [row], ...)",content={},children={[0]={level=2,text="Overview",content={[0]="For 2D userdatas, sets one or more values in the userdata starting at a specific column and row, enumerating in flat index order. Will do nothing if the starting index is out of range.",[1]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`[column]`: number",content={[0]="The horizontal index to start writing values to. Will be floored. Defaults to 0.",[1]=""},children={}},[1]={level=3,text="`[row]`: number",content={[0]="The vertical index to start writing values to. Will be floored. Defaults to 0.",[1]=""},children={}},[2]={level=3,text="`...`: number",content={[0]="Each of the arguments to set.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="local ud = userdata(\"f64\", 2, 3)",[2]="ud:set(0, 1, -12, -32, 10)",[3]="",[4]="?ud:get(0, 0) -- 0",[5]="?ud:get(1, 0) -- 0",[6]="?ud:get(0, 1) -- -12",[7]="?ud:get(1, 1) -- -32",[8]="?ud:get(0, 2) -- 10",[9]="?ud:get(1, 2) -- 0",[10]="```"},children={}}}}}},[42]={name="main.md",path="/picotron_api/userdata/methods/row/main.md",data={[0]={level=1,text="userdata:row(row_i): row_ud",content={},children={[0]={level=2,text="Overview",content={[0]="Creates a new 2D userdata containing a single row from the given userdata.",[1]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`row_i`: integer",content={[0]="The index of the row to fetch.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`row_ud`: userdata",content={[0]="A 2D userdata with a height of 1 and the width and type of the original userdata.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="-- 01 02",[2]="-- 03 04",[3]="-- 05 06",[4]="local ud = userdata(\"u8\", 2, 3, \"010203040506\")",[5]="local ud_w, ud_h, ud_t = ud:attribs()",[6]="",[7]="local row = ud:row(1)",[8]="local row_w, row_h, row_t = row:attribs()",[9]="",[10]="assert(row_h == 1)",[11]="assert(row_w == ud_w)",[12]="assert(row_t == ud_t)",[13]="",[14]="assert(row[0] == 3)",[15]="assert(row[1] == 4)",[16]="```"},children={}}}}}},[43]={name="main.md",path="/picotron_api/userdata/methods/mul/main.md",data={[0]={level=1,text="mul(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Multiplies elements on the left and right hand sides.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the multiplication operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the multiplication operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[44]={name="main.md",path="/picotron_api/userdata/methods/pow/main.md",data={[0]={level=1,text="pow(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Raises elements on the left hand side to the power of elements on the right hand side.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the exponentiation operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the exponentiation operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[45]={name="main.md",path="/picotron_api/userdata/methods/mod/main.md",data={[0]={level=1,text="mod(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Calculates the modulo of the elements on the left hand side by elements on the right hand side.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the modulo operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the modulo operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[46]={name="main.md",path="/picotron_api/userdata/methods/min/main.md",data={[0]={level=1,text="min(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the smallest values between elements on the left and right hand sides.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the min operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the min operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[47]={name="main.md",path="/picotron_api/userdata/methods/max/main.md",data={[0]={level=1,text="max(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the largest values between elements on the left and right hand sides.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the max operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the max operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[48]={name="main.md",path="/picotron_api/userdata/methods/idiv/main.md",data={[0]={level=1,text="idiv(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Divides elements on the left hand side by elements on the right hand side, and floors the result to an integer.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the integer division operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the integer division operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[49]={name="main.md",path="/picotron_api/userdata/methods/height/main.md",data={[0]={level=1,text="userdata:height(): height",content={},children={[0]={level=2,text="Overview",content={[0]="Gets the height of the userdata.",[1]=""},children={}},[1]={level=2,text="Returns",content={},children={[0]={level=3,text="`height`: integer|nil",content={[0]="The number of rows in the userdata if the userdata is 2D, or nil if the userdata is 1D.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="-- Be careful when reading the height of a userdata. It can be nil.",[2]="local h = ud:height()",[3]="",[4]="if h then",[5]="	for y = 0, h - 1 do",[6]="		for x = 0, ud:width() - 1 do",[7]="			?ud:get(x, y)",[8]="		end",[9]="	end",[10]="else",[11]="	for x = 0, ud:width() - 1 do",[12]="		?ud:get(x)",[13]="	end",[14]="end",[15]="```"},children={}}}}}},[50]={name="main.md",path="/picotron_api/userdata/methods/get/main.md",data={[0]={level=1,text="userdata:get(): ...",content={},children={[0]={level=2,text="Overview",content={[0]="Returns every value in the userdata as arguments in flat index order.",[1]=""},children={}},[1]={level=2,text="Returns",content={},children={[0]={level=3,text="`...`: number",content={[0]="Every number in the userdata.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="local tab = {ud:get()} --Copies the values in the userdata into the table tab",[2]="assert(ud[0] == tab[1])",[3]="assert(ud[1] == tab[2])",[4]="-- And so on.",[5]="```",[6]=""},children={}}}},[1]={level=1,text="userdata:get(i, [count]): ...",content={},children={[0]={level=2,text="Overview",content={[0]="For 1D userdatas, returns `count` sequential numbers from the userdata starting at the index `i`. If the starting index is outside the indexable range, will return 0.0.",[1]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`i`: number",content={[0]="The index to start fetching values from. Will be floored.",[1]=""},children={}},[1]={level=3,text="`[count]`: number",content={[0]="The number of values to fetch and return. Will be floored. If the number of values exceeds what is possible to retrieve from the userdata, only the ones that are retreivable are returned. Values less than 0 are undefined behavior, and are known to cause crashes. Defaults to 1.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`...`: number",content={[0]="Each of the requested numbers, or 0.0 if the starting index is out of range.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="local ud = vec(3, 6, 12, 24)",[2]="ud:get(1, 3) -- 6, 12, 24",[3]="```",[4]=""},children={}}}},[2]={level=1,text="userdata:get(column, [row], [count]): ...",content={},children={[0]={level=2,text="Overview",content={[0]="For 2D userdatas, returns `count` sequential numbers from the userdata starting at a specific column and row, enumerating in flat index order. If the starting index is outside the indexable range, will return 0.0.",[1]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`column`: number",content={[0]="The horizontal index to start fetching values from. Will be floored.",[1]=""},children={}},[1]={level=3,text="`[row]`: number",content={[0]="The vertical index to start fetching values from. Will be floored. Defaults to 0.",[1]=""},children={}},[2]={level=3,text="`[count]`: number",content={[0]="The number of values to fetch and return. Will be floored. If the number of values exceeds what is possible to retrieve from the userdata, only the ones that are retreivable are returned. Values less than 0 are undefined behavior, and are known to cause crashes. Defaults to 1.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`...`: number",content={[0]="Each of the requested numbers, or 0.0 if the starting index is out of range.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="local ud = userdata(\"f64\", 2, 3, \"0,10,20,30,40,50\")",[2]="ud:get(0, 1, 3) -- 20, 30, 40",[3]="```"},children={}}}}}},[51]={name="main.md",path="/picotron_api/userdata/methods/div/main.md",data={[0]={level=1,text="div(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Divides elements on the left hand side by elements on the right hand side.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the division operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the division operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[52]={name="main.md",path="/picotron_api/userdata/methods/column/main.md",data={[0]={level=1,text="userdata:column(column_i): column_ud",content={},children={[0]={level=2,text="Overview",content={[0]="Creates a new 2D userdata containing a single column from the given userdata.",[1]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`column_i`: integer",content={[0]="The index of the column to fetch.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`column_ud`: userdata",content={[0]="A 2D userdata with a width of 1 and the height and type of the original userdata.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="-- 01 02 03",[2]="-- 04 05 06",[3]="local ud = userdata(\"u8\", 3, 2, \"010203040506\")",[4]="local ud_w, ud_h, ud_t = ud:attribs()",[5]="",[6]="local column = ud:column(1)",[7]="local column_w, column_h, column_t = column:attribs()",[8]="",[9]="assert(column_h == ud_h)",[10]="assert(column_w == 1)",[11]="assert(column_t == ud_t)",[12]="",[13]="assert(column[0] == 2)",[14]="assert(column[1] == 5)",[15]="```"},children={}}}}}},[53]={name="main.md",path="/picotron_api/userdata/methods/bxor/main.md",data={[0]={level=1,text="bxor(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the bitwise XOR between elements on the left and right hand sides. Must be done on an integer typed userdata.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the bitwise XOR operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the bitwise XOR operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[54]={name="main.md",path="/picotron_api/userdata/methods/band/main.md",data={[0]={level=1,text="band(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the bitwise AND between elements on the left and right hand sides. Must be done on an integer typed userdata.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the bitwise AND operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the bitwise AND operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[55]={name="main.md",path="/picotron_api/userdata/methods/bor/main.md",data={[0]={level=1,text="bor(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the bitwise OR between elements on the left and right hand sides. Must be done on an integer typed userdata.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the bitwise OR operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the bitwise OR operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[56]={name="main.md",path="/picotron_api/userdata/methods/attribs/main.md",data={[0]={level=1,text="userdata:attribs(): width, height, type",content={},children={[0]={level=2,text="Overview",content={[0]="Gets the width, height, and type of the userdata.",[1]=""},children={}},[1]={level=2,text="Returns",content={},children={[0]={level=3,text="`width`: integer",content={[0]="The number of columns in the userdata.",[1]=""},children={}},[1]={level=3,text="`height`: integer",content={[0]="The number of rows in the userdata. Unlike the [`height`](/picotron_api/userdata/methods/height/main.md) method, 1D userdatas will return 1 for this value.",[1]=""},children={}},[2]={level=3,text="`type`: \"u8\"|\"i16\"|\"i32\"|\"i64\"|\"f64\"",content={[0]="The type that the userdata contains as its string name.",[1]=""},children={}}}},[2]={level=2,text="Example",content={[0]="```lua",[1]="local function clone_empty(ud)",[2]="	local width, height, ud_type = ud:attribs()",[3]="	return userdata(ud_type, width, height)",[4]="end",[5]="```"},children={}}}}}},[57]={name="main.md",path="/picotron_api/userdata/methods/add/main.md",data={[0]={level=1,text="add(lhs, rhs, [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Adds elements on the left and right hand sides.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`lhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The left hand side of the addition operation.",[1]=""},children={}},[1]={level=3,text="`rhs`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The right hand side of the addition operation.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[58]={name="main.md",path="/picotron_api/userdata/methods/abs/main.md",data={[0]={level=1,text="abs([lhs], [rhs], [dest], [read_start], [write_start], [group_size], [read_increment], [write_increment], [group_count]): written",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="Gets the absolute values (magnitude) of elements in a userdata.",[1]="",[2]="This function uses the userdata operator signature. Read the [bulk operations](/picotron_api/userdata/readme.md/#bulk-operations) section of the userdata documentation for a detailed explanation of how the arguments work.",[3]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`[lhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="The userdata used as the input for the absolute operations.",[1]=""},children={}},[1]={level=3,text="`[rhs]`: [userdata](/picotron_api/userdata/readme.md)|number",content={[0]="Alternative source userdata. Only used if `lhs` is not a userdata.",[1]=""},children={}},[2]={level=3,text="`[dest]`: [userdata](/picotron_api/userdata/readme.md)|true",content={[0]="The destination userdata to write to. Behavior depends on the type of `dest`, `lhs`, and `rhs`. See the table below.",[1]="",[2]="|`dest`             |`lhs`       |`rhs`   |written to     |",[3]="|-------------------|------------|--------|---------------|",[4]="|userdata           |any         |any     |`dest`         |",[5]="|truthy non-userdata|userdata    |any     |`lhs`          |",[6]="|truthy non-userdata|non-userdata|userdata|`rhs`          |",[7]="|falsey             |userdata    |any     |a copy of `lhs`|",[8]="|falsey             |non-userdata|userdata|a copy of `rhs`|",[9]=""},children={}},[3]={level=3,text="`[read_start]`: number",content={[0]="The starting index of the inner loop for `rhs`. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[4]={level=3,text="`[write_start]`: number",content={[0]="The starting index of the inner loop for `lhs` and the destination userdata. Will be floored. Will be clamped to at least 0. Defaults to 0.",[1]=""},children={}},[5]={level=3,text="`[group_size]`: number",content={[0]="The number of elements to iterate in the inner loop. Will be floored. A value of 0 or less results in a no-op. Defaults to infinity.",[1]=""},children={}},[6]={level=3,text="`[read_increment]`: number",content={[0]="How many elements to move the group starting index for `rhs` forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[7]={level=3,text="`[write_increment]`: number",content={[0]="How many elements to move the group starting index for `lhs` and the destination userdata forward by. A value of less than 0 will result in no iteration. Will be floored. Defaults to 1.",[1]=""},children={}},[8]={level=3,text="`[group_count]`: number",content={[0]="How many groups will be iterated over.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`written`: [userdata](/picotron_api/userdata/readme.md)",content={[0]="The destination userdata, as determined by the `[dest]` argument."},children={}}}}}}}},[59]={name="readme.md",path="/picotron_api/gui/readme.md",data={[0]={level=1,text="Picotron API > GUI",content={[0]="",[1]="Main contributions by `@Podepi`, `@KeyboardDanni`",[2]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Picotron includes a lightweight GUI framework that can be used in apps as well as games. Use of it is optional, and it's possible to make your own GUI system as well, but the built-in GUI can save you considerable development time on small to medium projects.",[2]="",[3]="Picotron's GUI library uses a tree of `GuiElement` tables, with a \"head\" (root) element at the top, and each element containing any number of child elements. If you've ever used other tree-based frameworks like Qt or Godot, this one operates on a similar principle.",[4]="",[5]="Every element has its own set of [Event Callbacks](event_callbacks/readme.md). In most cases, there will be at least a [draw()](event_callbacks/draw/main.md) callback, though there may also be an [update()](event_callbacks/update/main.md) callback, similar to how the `_update()` and `_draw()` callbacks work in Picotron programs. Mouse clicks on buttons are usually implemented using [tap()](event_callbacks/tap/main.md).",[6]=""},children={}},[1]={level=2,text="Creation",content={[0]="",[1]="To begin using the GUI, call `create_gui()` during initialization:",[2]="",[3]="```lua",[4]="local gui",[5]="",[6]="function _init()",[7]="	gui = create_gui()",[8]="end",[9]="```",[10]="",[11]="In order for the GUI to be functional, you will also need to call `gui:update_all()` and `gui:draw_all()` in the appropriate places:",[12]="",[13]="```lua",[14]="function _update()",[15]="	gui:update_all()",[16]="end",[17]="",[18]="function _draw()",[19]="    cls(13)",[20]="",[21]="	gui:draw_all()",[22]="end",[23]="```",[24]="",[25]="To add elements, call one of the [Attachment](attachments/readme.md) functions. For this example, we'll expand our `_init()` function to display our cart in a window and attach a button.",[26]="",[27]="```lua",[28]="function _init()",[29]="	window {",[30]="		title = \"My GUI Cart\",",[31]="		width = 150,",[32]="		height = 100",[33]="	}",[34]="",[35]="	gui = create_gui()",[36]="	",[37]="	gui:attach_button {",[38]="		x = 5,",[39]="		y = 5,",[40]="		label = \"Hello, Picotron!\",",[41]="		tap = function(self, msg)",[42]="			notify(\"Button pressed!\")",[43]="		end",[44]="	}",[45]="end",[46]="```",[47]="",[48]="The result should look like this:",[49]="",[50]="![A simple Picotron GUI cart](simple_window.png)",[51]="",[52]="Clicking the button will trigger a \"Button pressed!\" notification at the bottom of the screen.",[53]=""},children={}},[2]={level=2,text="Nested Elements",content={[0]="",[1]="We've seen that we can create and attach GUI elements by calling `gui:attach_button` and friends. But we can also nest elements to create more complex components. This is the key to reusability. Let's make a basic button box component that contains two buttons, \"Ok\" and \"Cancel\":",[2]="",[3]="```lua",[4]="local button_box = gui:attach {",[5]="    x = 5,",[6]="    y = 74,",[7]="    width = 140,",[8]="    height = 21,",[9]="    draw = function(self, msg)",[10]="        rrectfill(0, 0, self.width, self.height, 2, 18)",[11]="    end",[12]="}",[13]="",[14]="local button_ok = button_box:attach_button {",[15]="    x = 4,",[16]="    y = 4,",[17]="    width = 30,",[18]="    label = \"Ok\"",[19]="}",[20]="",[21]="button_box:attach_button {",[22]="    x = button_ok.width + 8,",[23]="    y = 4,",[24]="    label = \"Cancel\"",[25]="}",[26]="```",[27]="",[28]="The result:",[29]="",[30]="![A Picotron GUI cart with a button box to demonstrate nested elements](window_button_box.png)",[31]="",[32]="A few things are happening here. First, we are creating a \"container\" element for our button box and storing it in the `button_box` variable. This container has a `draw()` callback to illustrate its bounding box. Next, we use `button_box:attach_button` to attach the buttons to the `button_box` instead of `gui`.",[33]="",[34]="You might notice that `button_ok` has `x = 4, y = 4`, yet is located further down instead of at the top of the window. This is because coordinates are local to the parent element. This means we can reposition our `button_box` wherever we want and the buttons will move along with it.",[35]="",[36]="Keep in mind that by default, any child elements will be clipped to be within the parent's bounding box. So remember to set an appropriate `width` and `height` on the parent.",[37]=""},children={}},[3]={level=2,text="Tree Management",content={[0]="",[1]="Previously we've been adding elements to our interface by doing this:",[2]="",[3]="```lua",[4]="gui:attach {",[5]="    x = 5,",[6]="    y = 5,",[7]="    width = 20,",[8]="    height = 20",[9]="}",[10]="```",[11]="",[12]="However, this is actually performing two operations: creating the element, and then attaching it to the tree. The tree includes everything that is currently considered \"part of\" the user interface. However, it is possible to hold onto an element outside the tree. Such elements do not run their `update()` or `draw()` callbacks until they are attached to the tree.",[13]="",[14]="It is possible to create an unattached element using `gui:new()`. You can then later attach it using `gui:attach()`. The GUI system will recognize that it is already a `GuiElement` and avoid creating a new element:",[15]="",[16]="```lua",[17]="local element = gui:new {",[18]="    x = 5,",[19]="    y = 50,",[20]="    width = 100,",[21]="    height = 20,",[22]="    draw = function(self, msg)",[23]="        print(\"I'm in the tree!\", 0, 0, 1)",[24]="    end",[25]="}",[26]="",[27]="gui:attach(element)",[28]="```",[29]="",[30]="![The GUI cart with the attached element](window_attach.png)",[31]="",[32]="It is possible to remove an element from the tree by detaching it:",[33]="",[34]="```lua",[35]="element:detach()",[36]="```",[37]="",[38]="![The GUI cart with the previously attached element detached](window_button_box.png)",[39]="",[40]="The element may now be garbage-collected, assuming it doesn't have any other references pointing to it. Or, you may reattach the previously detached element at a later time.",[41]="",[42]="Every attached GUI element has variables that allow tree traversal: `head`, `parent`, and `child`.",[43]="",[44]="`head` is simply a reference to the root element, which is created via `create_gui()`. In our program, this is the `gui` variable. This is mainly so you don't have to make `gui` accessible to the entire program.",[45]="",[46]="`parent` allows accessing the element's parent. For example, we could add this callback to our \"Ok\" button:",[47]="",[48]="```lua",[49]="tap = function(self, msg)",[50]="    notify(self.parent.width)",[51]="end",[52]="```",[53]="",[54]="Clicking the button will now display `140`, the width of our button box.",[55]="",[56]="`child` is an array table containing every element nested under the current element. For example, you can remove the contents of `element` (but keep `element` itself) with the following:",[57]="",[58]="```lua",[59]="for i = #element.child, 1, -1 do",[60]="    element.child[i]:detach()",[61]="end",[62]="```",[63]="",[64]="Be careful when debugging GUI elements, as the `parent`/`head` references can cause nested iteration to recurse infinitely and crash Picotron.",[65]=""},children={}},[4]={level=2,text="Performance",content={[0]="",[1]="Every frame, the GUI system will recompute the bounds of all the elements in the tree and run their `update()` and `draw()` callbacks. This means that the more elements you have in your tree, the more CPU time is needed. If your UI is split between several pages, consider attaching and detaching them as needed instead of keeping everything attached at once. If you have a large scrolling item list with hundreds of items or more, create only the items that will be in-view, and add/remove items as necessary as the list scrolls.",[2]="",[3]="If you are making a desktop cart that doesn't need to animate while idle, consider only running your drawing code once every 5 frames or so, or when there is an animation update. To keep your UI responsive, you may want to mark it \"dirty\" when interacting with the window so that changes become visible on the same frame instead of several frames later.",[4]="",[5]="Try to limit the use of `update()` callback processing in elements. Where possible, stick to interaction-based event callbacks like `tap()`. And of course, remember to cache the results of expensive calculations such as word-wrapping.",[6]=""},children={}},[5]={level=2,text="References",content={[0]="[Event Callbacks](event_callbacks/readme.md)",[1]="",[2]="[Attachments](attachments/readme.md)",[3]="",[4]="[Attributes](attributes/readme.md)"},children={}}}}}},[60]={name="readme.md",path="/picotron_api/gui/event_callbacks/readme.md",data={[0]={level=1,text="Picotron API > GUI > Event Callbacks",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on the event callbacks in Picotron's GUIs.",[2]="",[3]="Events are called with the arguments `self,msg`",[4]=""},children={}},[1]={level=2,text="Global `msg` properties",content={[0]="",[1]="All event callbacks will contain these properties in `msg`, alongside their element-specific properties.",[2]=""},children={[0]={level=3,text="dx",content={[0]="",[1]="Distance in pixels the mouse moved on the x axis this frame",[2]=""},children={}},[1]={level=3,text="dy",content={[0]="",[1]="Distance in pixels the mouse moved on the y axis this frame",[2]=""},children={}},[2]={level=3,text="mb",content={[0]="",[1]="Mouse buttons currently held down, as a bitfield. See [`mouse()`](/picotron_api/functions/mouse/main.md) for more info.",[2]=""},children={}},[3]={level=3,text="mx",content={[0]="",[1]="Position of mouse on x axis relative to this element",[2]=""},children={}},[4]={level=3,text="my",content={[0]="",[1]="Position of mouse on y axis relative to this element",[2]=""},children={}},[5]={level=3,text="has_pointer",content={[0]="",[1]="True if the mouse is currently hovering this element. Useful for mouseover effects.",[2]=""},children={}}}},[2]={level=2,text="Event Callbacks",content={[0]="",[1]="[update](update/main.md)",[2]="",[3]="[draw](draw/main.md)",[4]="",[5]="[click](click/main.md)",[6]="",[7]="[doubleclick](doubleclick/main.md)",[8]="",[9]="[tap](tap/main.md)",[10]="",[11]="[doubletap](doubletap/main.md)",[12]="",[13]="[release](release/main.md)",[14]="",[15]="[mousewheel](mousewheel/main.md)",[16]="",[17]="[drag](drag/main.md)",[18]="",[19]="[hover](hover/main.md)",[20]=""},children={}}}}}},[61]={name="main.md",path="/picotron_api/gui/event_callbacks/update/main.md",data={[0]={level=1,text="update",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered every gui:update_all()."},children={}}}}}},[62]={name="main.md",path="/picotron_api/gui/event_callbacks/tap/main.md",data={[0]={level=1,text="tap",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered if a mouse button is released within 0.3 seconds of being pressed and the mouse hasnt moved.",[2]="",[3]="Use `msg.last_mb` if you want to check that a specific mouse button was released.",[4]="",[5]="The time duration is hard coded",[6]=""},children={}},[1]={level=2,text="msg values:",content={[0]=""},children={[0]={level=3,text="last_mb",content={[0]="    `msg.mb` from previous frame"},children={}}}}}}}},[63]={name="main.md",path="/picotron_api/gui/event_callbacks/mousewheel/main.md",data={[0]={level=1,text="mousewheel",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered when mouse wheel scrolls over this element.",[2]=""},children={}},[1]={level=2,text="msg values",content={[0]=""},children={[0]={level=3,text="wheel_x",content={[0]="",[1]="Amount the wheel was scrolled horizontally this frame.",[2]=""},children={}},[1]={level=3,text="wheel_y",content={[0]="",[1]="Amount the wheel was scrolled vertically this frame"},children={}}}}}}}},[64]={name="main.md",path="/picotron_api/gui/event_callbacks/release/main.md",data={[0]={level=1,text="release",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered on the first frame that a mouse button is released. Use `msg.last_mb` if you want to check that a specific mouse button was released.",[2]=""},children={}},[1]={level=2,text="msg values",content={[0]=""},children={[0]={level=3,text="last_mb",content={[0]="",[1]="msg.mb from previous frame",[2]=""},children={}},[1]={level=3,text="mx0",content={[0]="",[1]="X position where mouse was first clicked",[2]=""},children={}},[2]={level=3,text="my0",content={[0]="",[1]="Y position where mouse was first clicked"},children={}}}}}}}},[65]={name="main.md",path="/picotron_api/gui/event_callbacks/hover/main.md",data={[0]={level=1,text="hover",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered every frame if the mouse is hovering over this element *if* the mouse is not clicked.",[2]="",[3]="Note: You may not need this callback if you just want a custom element to change color on mouseover. For that, see [msg.has_pointer](../../event_callbacks/readme.md).",[4]=""},children={}}}}}},[66]={name="main.md",path="/picotron_api/gui/event_callbacks/drag/main.md",data={[0]={level=1,text="drag",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered every frame that mouse button is held down, if the initial click was on this element.",[2]=""},children={}},[1]={level=2,text="msg values",content={[0]=""},children={[0]={level=3,text="has_pointer",content={[0]="",[1]="True if mouse pointer is directly over this element, false otherwise.",[2]=""},children={}},[1]={level=3,text="mx0",content={[0]="",[1]="X position where drag began - i.e. where mouse was first clicked",[2]=""},children={}},[2]={level=3,text="my0",content={[0]="",[1]="Y position where drag began - i.e. where mouse was first clicked",[2]="",[3]=""},children={}}}}}}}},[67]={name="main.md",path="/picotron_api/gui/event_callbacks/doubletap/main.md",data={[0]={level=1,text="doubleclick",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered if a mouse button is tapped twice within 0.4 seconds.",[2]="",[3]="The time duration is hard coded"},children={}}}}}},[68]={name="main.md",path="/picotron_api/gui/event_callbacks/draw/main.md",data={[0]={level=1,text="draw",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered every gui:draw_all()."},children={}}}}}},[69]={name="main.md",path="/picotron_api/gui/event_callbacks/doubleclick/main.md",data={[0]={level=1,text="doubleclick",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Triggered if a mouse button is clicked twice within 0.4 seconds.",[2]="",[3]="The time duration is hard coded"},children={}}}}}},[70]={name="readme.md",path="/picotron_api/gui/attributes/readme.md",data={[0]={level=1,text="Picotron API > GUI > Attributes",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on the general attributes for Picotron's GUIs",[2]=""},children={}},[1]={level=2,text="Attributes",content={[0]="",[1]="",[2]="[x](x/main.md)",[3]="",[4]="[y](y/main.md)",[5]="",[6]="[z](z/main.md)",[7]="",[8]="[width](width/main.md)",[9]="",[10]="[height](height/main.md)",[11]="",[12]="[clip_to_parent](clip_to_parent/main.md)",[13]="",[14]="[cursor](cursor/main.md)",[15]="",[16]="[squash_to_parent](squash_to_parent/main.md)",[17]="",[18]="[confine_to_clip](confine_to_clip/main.md)",[19]="",[20]="[squash_to_clip](squash_to_clip/main.md)",[21]="",[22]="[justify](justify/main.md)",[23]="",[24]="[vjustify](vjustify/main.md)",[25]="",[26]="[min_width](min_width/main.md)",[27]="",[28]="[min_height](min_height/main.md)",[29]="",[30]="[width_add](width_add/main.md)",[31]="",[32]="[height_add](height_add/main.md)",[33]="",[34]="[width_rel](width_rel/main.md)",[35]="",[36]="[height_rel](height_rel/main.md)"},children={}}}}}},[71]={name="main.md",path="/picotron_api/gui/attributes/y/main.md",data={[0]={level=1,text="y",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Element position along the y axis",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: 0",[2]="",[3]="Valid values: Any number"},children={}}}}}},[72]={name="main.md",path="/picotron_api/gui/event_callbacks/click/main.md",data={[0]={level=1,text="click",content={[0]="",[1]="Triggered on the first frame that a mouse button is pressed."},children={}}}},[73]={name="main.md",path="/picotron_api/gui/attributes/z/main.md",data={[0]={level=1,text="z",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Element position along the z axis.",[2]="",[3]="Elements with a higher z value will appear on top of elements with a lower z value.",[4]="",[5]="Elements with the same z value will be drawn in order based on which one was added first - newer elements are drawn on top of older elements.",[6]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: 0",[2]="",[3]="Valid values: Any number"},children={}}}}}},[74]={name="main.md",path="/picotron_api/gui/attributes/width_rel/main.md",data={[0]={level=1,text="width_rel",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Overwrites [`Element.width`](/picotron_api/gui/attributes/width/main.md) - if you want finer control over the final width, use [`Element.width_add`](/picotron_api/gui/attributes/width_add/main.md) or [`Element.min_width`](/picotron_api/gui/attributes/min_width/main.md).",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: nil",[2]="",[3]="Valid values: nil, number between 0 and 1",[4]="",[5]="If not nil, automatically adjusts element width based on [`parent.width`](/picotron_api/gui/attributes/width/main.md) as a decimal (the percentage / 100)",[6]="",[7]="e.g:",[8]="* 1 = 100% of the parent width",[9]="* 0.5 means 50%"},children={}}}}}},[75]={name="main.md",path="/picotron_api/gui/attributes/x/main.md",data={[0]={level=1,text="x",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Element position along the x axis",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: 0",[2]="",[3]="Valid values: Any number"},children={}}}}}},[76]={name="main.md",path="/picotron_api/gui/attributes/width_add/main.md",data={[0]={level=1,text="width_add",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="If [`Element.width_rel`](/picotron_api/gui/attributes/width_rel/main.md) is not nil, this value is added to the final width. ",[2]="",[3]="Otherwise, does nothing. ",[4]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: 0",[2]="",[3]="Valid values: any number"},children={}}}}}},[77]={name="main.md",path="/picotron_api/gui/attributes/squash_to_parent/main.md",data={[0]={level=1,text="squash_to_parent",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Unknown"},children={}}}}}},[78]={name="main.md",path="/picotron_api/gui/attributes/width/main.md",data={[0]={level=1,text="width",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Width of the element",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Must be set to a number if [`width_rel`](/picotron_api/gui/attributes/width_rel/main.md) is not used.",[2]="",[3]="Default value: nil",[4]="",[5]="Valid values: any number"},children={}}}}}},[79]={name="main.md",path="/picotron_api/gui/attributes/vjustify/main.md",data={[0]={level=1,text="vjustify",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Automatically adjusts element y position based on element and parent vertical ",[2]="size. ",[3]="",[4]="[`Element.y`](/picotron_api/gui/attributes/y/main.md) is then added to the calculated value, functioning as an offset.",[5]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: \"top\"",[2]="",[3]="Valid values: \"top\", \"center\", \"bottom\""},children={}}}}}},[80]={name="main.md",path="/picotron_api/gui/attributes/min_width/main.md",data={[0]={level=1,text="min_width",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="If calculated width is less than this value, then this value is used as the [width](/picotron_api/gui/attributes/width/main.md) attribute instead. ",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: nil",[2]="",[3]="Valid values: any number"},children={}}}}}},[81]={name="main.md",path="/picotron_api/gui/attributes/squash_to_clip/main.md",data={[0]={level=1,text="squash_to_clip",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Unknown"},children={}}}}}},[82]={name="main.md",path="/picotron_api/gui/attributes/justify/main.md",data={[0]={level=1,text="justify",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Automatically adjusts element x position based on element and parent horizontal size.",[2]="",[3]="[`Element.x`](/picotron_api/gui/attributes/x/main.md) is then added to the calculated value, functioning as an offset.",[4]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: \"left\"",[2]="",[3]="Valid values: \"left\", \"center\", \"right\""},children={}}}}}},[83]={name="main.md",path="/picotron_api/gui/attributes/height_rel/main.md",data={[0]={level=1,text="height_rel",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Overwrites [`Element.height`](/picotron_api/gui/attributes/height/main.md) - if you want finer control over the final height, use [`Element.height_add`](/picotron_api/gui/attributes/height_add/main.md) or [`Element.min_height`](/picotron_api/gui/attributes/min_height/main.md).",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: nil",[2]="",[3]="Valid values: nil, number between 0 and 1",[4]="",[5]="If not nil, automatically adjusts element height based on [`parent.height`](/picotron_api/gui/attributes/height/main.md) as a decimal (the percentage / 100)",[6]="",[7]="e.g:",[8]="* 1 = 100% of the parent height",[9]="* 0.5 means 50%"},children={}}}}}},[84]={name="main.md",path="/picotron_api/gui/attributes/min_height/main.md",data={[0]={level=1,text="min_height",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="If calculated height is less than this value, then this value is used as the [height](/picotron_api/gui/attributes/height/main.md) attribute instead.",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: nil",[2]="",[3]="Valid values: any number"},children={}}}}}},[85]={name="main.md",path="/picotron_api/gui/attributes/height_add/main.md",data={[0]={level=1,text="height_add",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="If [`Element.height_rel`](/picotron_api/gui/attributes/height_add/main.md) is not nil, this value is added to the final height. ",[2]="",[3]="Otherwise, does nothing.",[4]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: nil",[2]="",[3]="Valid values: any number"},children={}}}}}},[86]={name="main.md",path="/picotron_api/gui/attributes/height/main.md",data={[0]={level=1,text="height",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Height of the element",[2]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Must be set to a number if [`height_rel`](/picotron_api/gui/attributes/height_rel/main.md) is not used.",[2]="",[3]="Default value: nil",[4]="",[5]="Valid values: any number"},children={}}}}}},[87]={name="main.md",path="/picotron_api/gui/attributes/cursor/main.md",data={[0]={level=1,text="cursor",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Sets the mouse cursor when this element is hovered over.",[2]=""},children={[0]={level=3,text="Values:",content={[0]="",[1]="Default value: nil",[2]="",[3]="See [`window()`][/picotron_api/functions/window/main.md]",[4]="",[5]="0: no cursor",[6]="1: default cursor",[7]="userdata u8: a custom cursor sprite.",[8]="",[9]="System cursors are named, and can be requested using a string: pointer, grab, dial, crosshair"},children={}}}}}}}},[88]={name="main.md",path="/picotron_api/gui/attributes/confine_to_clip/main.md",data={[0]={level=1,text="confine_to_clip",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Unknown"},children={}}}}}},[89]={name="main.md",path="/picotron_api/gui/attributes/confine_to_parent/main.md",data={[0]={level=1,text="confine_to_parent",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Reposition so that element remains inside parent -  when oversized, set x / y to 0",[2]="",[3]="This can be used with [`squash_to_parent`](/picotron_api/gui/attributes/squash_to__parent/main.md)",[4]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: false",[2]="",[3]="Valid values: true, false"},children={}}}}}},[90]={name="readme.md",path="/picotron_api/gui/attachments/readme.md",data={[0]={level=1,text="Picotron API > GUI > Attachments",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on the attachments in Picotron's GUIs.",[2]="",[3]="[Generic UI element](attach/main.md)",[4]="",[5]="[Button](attach_button/main.md)",[6]="",[7]="[Field](attach_field/main.md)",[8]="",[9]="[Pulldown](attach_pulldown/main.md)",[10]="",[11]="[Scrollbars](attach_scrollbars/main.md)",[12]="",[13]="[Text Editor](attach_text_editor/main.md)"},children={}}}}}},[91]={name="main.md",path="/picotron_api/gui/attributes/clip_to_parent/main.md",data={[0]={level=1,text="clip_to_parent",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Clips an element to the parent",[2]="",[3]="Events are also not clipped.",[4]="",[5]="Useful for UI elements that need to 'overhang' a parent window, for example.",[6]=""},children={}},[1]={level=2,text="Values",content={[0]="",[1]="Default value: true",[2]="",[3]="Valid values: true, false",[4]=""},children={[0]={level=3,text="If true",content={[0]="",[1]="the element will be clipped to the size of the parent.",[2]="",[3]="This also prevents events from triggering on the parts of the element outside the parent bounds.",[4]=""},children={}},[1]={level=3,text="If false",content={[0]="",[1]="the element will not be clipped to the size of the parent and can be positioned outside the parent."},children={}}}}}}}},[92]={name="main.md",path="/picotron_api/gui/attachments/attach_pulldown/main.md",data={[0]={level=1,text="el:attach_pulldown()",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Attaches a pulldown to the element",[2]="",[3]="Source: [source.lua](source.lua)",[4]="",[5]="Details unknown."},children={}}}}}},[93]={name="main.md",path="/picotron_api/gui/attachments/attach_text_editor/main.md",data={[0]={level=1,text="attach_text_editor",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Attaches a text editor",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Required properties",content={[0]=""},children={[0]={level=3,text="x",content={[0]="",[1]="x-position of the element",[2]=""},children={}},[1]={level=3,text="y",content={[0]="",[1]="y-position of the element",[2]=""},children={}},[2]={level=3,text="width",content={[0]="",[1]="width of the element",[2]=""},children={}},[3]={level=3,text="height",content={[0]="",[1]="height of the element"},children={}}}}}}}},[94]={name="main.md",path="/picotron_api/gui/attachments/attach_scrollbars/main.md",data={[0]={level=1,text="el:attach_scrollbars()",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Attaches a scrollbar to the element",[2]="",[3]="assumes that self is a container element, where:",[4]="* child[1] is the element to be scrolled",[5]="* child[2] is the scrollbar",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[1]={level=2,text="Example",content={[0]="",[1]="```lua",[2]="g = create_gui()",[3]="my_container = g:attach(my_container_attribs)",[4]="my_container:attach(my_contents)",[5]="my_container:attach_scrollbars()",[6]="```",[7]="",[8]="To allow mousewheel scrolling, you still need to process messages from contents as such:",[9]="",[10]="```lua",[11]="function contents:mousewheel(msg)",[12]="    self.y += msg.wheel_y * 32 -- scroll speed is arbitrary",[13]="end",[14]="```",[15]=""},children={}},[2]={level=2,text="Future",content={[0]="",[1]="mousewheel event should propagate up to parent though (if not defined)",[2]="",[3]="horizontal bar (or generalise to 2d)"},children={}}}}}},[95]={name="main.md",path="/picotron_api/gui/attachments/attach/main.md",data={[0]={level=1,text="attach(el)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Attaches a generic UI element with `el` (a table)",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Expected attributes",content={[0]=""},children={[0]={level=3,text="x",content={[0]="",[1]="x-position of the element",[2]=""},children={}},[1]={level=3,text="y",content={[0]="",[1]="y-position of the element",[2]=""},children={}},[2]={level=3,text="width",content={[0]="",[1]="width of the element",[2]=""},children={}},[3]={level=3,text="height",content={[0]="",[1]="height of the element"},children={}}}}}}}},[96]={name="main.md",path="/picotron_api/gui/attachments/attach_field/main.md",data={[0]={level=1,text="attach_field(el)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Attaches a text field to the element.",[2]="",[3]="Used for editing small amounts of text.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Expected attributes",content={[0]=""},children={[0]={level=3,text="x",content={[0]="",[1]="x-position of the element",[2]=""},children={}},[1]={level=3,text="y",content={[0]="",[1]="y-position of the element",[2]=""},children={}},[2]={level=3,text="width",content={[0]="",[1]="width of the element",[2]=""},children={}},[3]={level=3,text="height",content={[0]="",[1]="height of the element",[2]=""},children={}}}},[2]={level=2,text="Expected event callbacks",content={[0]=""},children={[0]={level=3,text="get() event callback",content={[0]="",[1]="A function to handle getting the field's intial text",[2]=""},children={}},[1]={level=3,text="set() event callback",content={[0]="",[1]="A function to handle setting the field's text to the user input"},children={}}}}}}}},[97]={name="main.md",path="/picotron_api/gui/attachments/attach_button/main.md",data={[0]={level=1,text="attach_button(el)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Attaches a button with default styling",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Expected attributes",content={[0]=""},children={[0]={level=3,text="x",content={[0]="",[1]="x-position of the element",[2]=""},children={}},[1]={level=3,text="y",content={[0]="",[1]="y-position of the element",[2]=""},children={}}}},[2]={level=2,text="Available attributes",content={[0]=""},children={[0]={level=3,text="width",content={[0]="",[1]="Width of the element. Omit to auto-calculate (see limitations)",[2]=""},children={}},[1]={level=3,text="height",content={[0]="",[1]="Height of the element. Omit to auto-calculate (see limitations)",[2]=""},children={}},[2]={level=3,text="label",content={[0]="",[1]="Text to be displayed on the button",[2]=""},children={}},[3]={level=3,text="fgcol",content={[0]="",[1]="Foreground color of the button. Low byte is normal color, high byte is hover color. For example, `18 + (7 << 8)` will use color 18 (dark purple) normally, and switch to color 7 (white) when hovered. If the high byte is omitted, hover becomes color 0 (black).",[2]=""},children={}},[4]={level=3,text="bgcol",content={[0]="",[1]="Background color of the button. Low byte is normal color, high byte is hover color.",[2]=""},children={}},[5]={level=3,text="border",content={[0]="",[1]="Border color of the button. Low byte is normal color, high byte is hover color.",[2]=""},children={}}}},[3]={level=2,text="Limitations",content={[0]="",[1]="The current automatic sizing logic is very basic and does not account for P8SCII, newlines, or fonts other than the default. In these cases you may want to provide your own width/height values.",[2]=""},children={}},[4]={level=2,text="Future",content={[0]="",[1]="calculate width with current font",[2]="",[3]="can define a \"class\" or \"style\" at system-wide level or gui level that has these default values",[4]="",[5]=""},children={}}}}}},[98]={name="readme.md",path="/picotron_api/functions/readme.md",data={[0]={level=1,text="Picotron API > Functions",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on all of the functions in the Picotron API",[2]="",[3]="[`set_spr`](set_spr/main.md)",[4]="",[5]="[`spr`](spr/main.md)",[6]="",[7]="[`sspr`](sspr/main.md)",[8]="",[9]="[`store`](store/main.md)",[10]="",[11]="[`store_metadata`](store_metadata/main.md)",[12]="",[13]="[`unmap`](unmap/main.md)",[14]="",[15]="[`memmap`](memmap/main.md)",[16]="",[17]="[`mkdir`](mkdir/main.md)",[18]="",[19]="[`mv`](mv/main.md)",[20]="",[21]="[`rm`](rm/main.md)",[22]="",[23]="[`cp`](cp/main.md)",[24]="",[25]="[`pid`](pid/main.md)",[26]="",[27]="[`send_message`](send_message/main.md)",[28]="",[29]="[`create_process`](create_process/main.md)",[30]="",[31]="[`camera`](camera/main.md)",[32]="",[33]="[`map`](map/main.md)",[34]="",[35]="[`printh`](printh/main.md)",[36]="",[37]="[`include`](include/main.md)"},children={}}}}}},[99]={name="main.md",path="/picotron_api/functions/window/main.md",data={[0]={level=1,text="window([width,height],attribs)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Create a window and/or set the window's attributes.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[width,height]",content={[0]="",[1]="Proportions of the window",[2]=""},children={}},[1]={level=3,text="attribs",content={[0]="",[1]="Table of desired attributes of the window",[2]="",[3]="Cannot overwrite `parent_pid`",[4]=""},children={[0]={level=4,text="`width`: number",content={[0]="",[1]="width in pixels (not including the frame)",[2]=""},children={}},[1]={level=4,text="`height`: height",content={[0]="",[1]="height in pixels",[2]=""},children={}},[2]={level=4,text="`title`: string",content={[0]="",[1]="set a title displayed on the window's titlebar",[2]=""},children={}},[3]={level=4,text="`pauseable`: boolean",content={[0]="",[1]="false to turn off the app menu that normally comes up with ENTER/START button",[2]=""},children={}},[4]={level=4,text="`tabbed`: boolean",content={[0]="",[1]="true to open in a tabbed workspace (like the code editor)",[2]=""},children={}},[5]={level=4,text="`has_frame`: boolean",content={[0]="",[1]="Default: true",[2]="",[3]="Whether to have a frame around the window",[4]=""},children={}},[6]={level=4,text="`moveable`: boolean",content={[0]="",[1]="Default: true",[2]="",[3]="Whether to allow the window to be dragged",[4]=""},children={}},[7]={level=4,text="`resizeable`: boolean",content={[0]="",[1]="Default: true",[2]="",[3]="Whether to allow the window to be resized",[4]=""},children={}},[8]={level=4,text="`wallpaper`: boolean",content={[0]="",[1]="Default: true",[2]="",[3]="acts as a wallpaper:",[4]="* z defaults to -1000 in that case",[5]="* opens a filenav (for the desktop interface)",[6]=""},children={}},[9]={level=4,text="`autoclose`: boolean",content={[0]="",[1]="close window when is no longer in focus or when press escape",[2]=""},children={}},[10]={level=4,text="`x`: number",content={[0]="",[1]="Position of the window",[2]=""},children={}},[11]={level=4,text="`y`: number",content={[0]="",[1]="Position of the window",[2]=""},children={}},[12]={level=4,text="`z`: number",content={[0]="",[1]="Default: 0",[2]="",[3]="windows with higher z are drawn on top.",[4]=""},children={}},[13]={level=4,text="`cursor`: string|number",content={[0]="",[1]="0 for no cursor",[2]="",[3]="1 for Default",[4]="",[5]="userdata for a custom cursor",[6]="",[7]="Use strings for some built in cursors, e.g: `pointer`",[8]=""},children={}},[14]={level=4,text="`squashable`: boolean",content={[0]="",[1]="window resizes itself to stay within the desktop region",[2]=""},children={}},[15]={level=4,text="`background_updates`: boolean",content={[0]="",[1]="allow _update() callbacks when parent window is not visible",[2]=""},children={}},[16]={level=4,text="`background_draws`: boolean",content={[0]="",[1]="allow _draw() callbacks when parent window is not visible",[2]=""},children={}}}},[2]={level=3,text="`show_context_menu`: boolean",content={[0]="",[1]="displays the menu at the user's cursor",[2]=""},children={}},[3]={level=3,text="`ghost`: boolean",content={[0]="",[1]="Window is drawn, uninteractable, inputs passthrough to the below window"},children={}}}}}}}},[100]={name="main.md",path="/picotron_api/functions/vec/main.md",data={[0]={level=1,text="vec(...): ud",content={},children={[0]={level=2,text="Overview",content={[0]="The vec function is one of two ways to create a new userdata from scratch, with the other being the [userdata](picotron_api/functions/userdata/main.md) function.",[1]="Produces a new f64 typed 1D [userdata](/picotron_api/userdata/readme.md) populated with each of the arguments.",[2]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`...`: number|nil",content={[0]="Each value to populate the userdata with. The number of arguments dictates the width of the produced userdata. Defaults to 0.",[1]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)|nil",content={[0]="The userdata produced, or nil if no arguments were provided.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="local position = vec(12, 19)",[2]="",[3]="?position:get(0) -- 12",[4]="?position:get(1) -- 19",[5]="```",[6]=""},children={}}}}}},[101]={name="main.md",path="/picotron_api/functions/userdata/main.md",data={[0]={level=1,text="userdata(type, width, height, [data]): ud",content={},children={[0]={level=2,text="Overview",content={[0]="The userdata function is one of two ways to create a new userdata from scratch, with the other being the [vec](picotron_api/functions/vec/main.md) function.",[1]="Produces a new 2D [userdata](/picotron_api/userdata/readme.md) with a specified type and size. 2D userdatas with a height of 1 are not the same as 1D userdatas, and will cause certain functions, such as [`get`](/picotron_api/userdata/methods/get/main.md) and [`set`](/picotron_api/userdata/methods/set/main.md), to behave differently.",[2]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`type`: \"u8\"|\"i16\"|\"i32\"|\"i64\"|\"f64\"",content={[0]="",[1]="The type of number that the userdata will contain.",[2]="- \"u8\" is an unsigned 8-bit integer",[3]="- \"i16\" is a signed 16-bit integer",[4]="- \"i32\" is a signed 32-bit integer",[5]="- \"i64\" is a signed 64-bit integer",[6]="- \"f64\" is a 64-bit floating point number",[7]=""},children={}},[1]={level=3,text="`width`: number",content={[0]="",[1]="The number of columns in the produced userdata. Will be floored. If less than 1, causes the returned value to be nil.",[2]=""},children={}},[2]={level=3,text="`height`: number",content={[0]="The number of rows in the produced userdata. Will be floored. If less than 1, causes the returned value to be nil.",[1]=""},children={}},[3]={level=3,text="`[data]`: string",content={[0]="The values to initialize the userdata with. Defaults to setting every entry to 0.",[1]="",[2]="If the userdata is an integer type, `data` must be formatted as a contiguous 0-padded hexidecimal string. For instance, if `type` is `i16`, the string `\"000F2001\"` would produce the numbers (in decimal) 15 and 8,193 for indices 0 and 1.",[3]="",[4]="If the userdata is a floating point type, `data` must be formatted as a comma-separated list of decimal values. For instance, `\"0.1,0.5,12\"`.",[5]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)|nil",content={[0]="The userdata produced, or nil if `width` or `height` is less than 1.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="local ud = userdata(\"u8\", 2, 2, \"080D1522\")",[2]="",[3]="?ud:get(0, 0) -- 8",[4]="?ud:get(1, 0) -- 13",[5]="?ud:get(0, 1) -- 21",[6]="?ud:get(1, 1) -- 34",[7]="```",[8]=""},children={}}}},[1]={level=1,text="userdata(type, width, [data]): ud",content={},children={[0]={level=2,text="Overview",content={[0]="The userdata function is one of two ways to create a new userdata from scratch, with the other being the [vec](picotron_api/functions/vec/main.md) function.",[1]="Produces a new 1D [userdata](/picotron_api/userdata/readme.md) with a specified type and size. 1D userdatas are not the same as 2D userdatas with a height of 1, and will cause certain functions, such as [`get`](/picotron_api/userdata/methods/get/main.md) and [`set`](/picotron_api/userdata/methods/set/main.md), to behave differently.",[2]=""},children={}},[1]={level=2,text="Arguments",content={},children={[0]={level=3,text="`type`: \"u8\"|\"i16\"|\"i32\"|\"i64\"|\"f64\"",content={[0]="",[1]="The type of number that the userdata will contain.",[2]="- \"u8\" is an unsigned 8-bit integer",[3]="- \"i16\" is a signed 16-bit integer",[4]="- \"i32\" is a signed 32-bit integer",[5]="- \"i64\" is a signed 64-bit integer",[6]="- \"f64\" is a 64-bit floating point number",[7]=""},children={}},[1]={level=3,text="`width`: number",content={[0]="",[1]="The number of columns in the produced userdata. Will be floored. If less than 1, causes the returned value to be nil.",[2]=""},children={}},[2]={level=3,text="`[data]`: string",content={[0]="The values to initialize the userdata with. Defaults to setting every entry to 0.",[1]="",[2]="If the userdata is an integer type, `data` must be formatted as a contiguous 0-padded hexidecimal string. For instance, if `type` is `i16`, the string `\"000F2001\"` would produce the numbers (in decimal) 15 and 8,193 for indices 0 and 1.",[3]="",[4]="If the userdata is a floating point type, `data` must be formatted as a comma-separated list of decimal values. For instance, `\"0.1,0.5,12\"`.",[5]=""},children={}}}},[2]={level=2,text="Returns",content={},children={[0]={level=3,text="`ud`: [userdata](/picotron_api/userdata/readme.md)|nil",content={[0]="The userdata produced, or nil if `width` is less than 1.",[1]=""},children={}}}},[3]={level=2,text="Example",content={[0]="```lua",[1]="local ud = userdata(\"u8\", 4, \"080D1522\")",[2]="",[3]="?ud:get(0) -- 8",[4]="?ud:get(1) -- 13",[5]="?ud:get(2) -- 21",[6]="?ud:get(3) -- 34",[7]="```",[8]=""},children={}}}}}},[102]={name="main.md",path="/picotron_api/functions/unmap/main.md",data={[0]={level=1,text="unmap(ud,addr,[len])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="this is the only way to release mapped userdata for collection",[2]="",[3]="e.g. memmapping a userdata over an old one is not sufficient to free it for collection",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="ud",content={[0]="",[1]="The userdata that is unmapped from memory",[2]=""},children={}},[1]={level=3,text="addr",content={[0]="",[1]="The address to unmap the userdata from",[2]=""},children={}},[2]={level=3,text="[len]",content={[0]="",[1]="Length of the userdata to unmap, defaults to the full userdata length",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="This function does not return anything"},children={}}}}}},[103]={name="main.md",path="/picotron_api/functions/store_metadata/main.md",data={[0]={level=1,text="store_metadata(filename,meta)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`store_metadata` stores metadata, `meta`, at a file or directory, `filename`, merging with the original metadata.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="filename",content={[0]="",[1]="The path to the file or directory to store metadata in",[2]=""},children={}},[1]={level=3,text="meta",content={[0]="",[1]="The metadata to store in the file or directory",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="This function does not return anything",[2]=""},children={}},[3]={level=2,text="Possible Future",content={[0]="",[1]="Ability to remove metadata items from the pre-existing metadata"},children={}}}}}},[104]={name="main.md",path="/picotron_api/functions/store/main.md",data={[0]={level=1,text="store(location, obj, [metadata])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`store` allows you to store files, typically used for save files by storing tables in the `pod` file format.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="location",content={[0]="",[1]="The location you want to store a file at, e.g: `/appdata/mypod.pod`",[2]=""},children={}},[1]={level=3,text="obj",content={[0]="",[1]="The file data, e.g: a table for a `.pod` file.",[2]=""},children={}},[2]={level=3,text="[metadata]",content={[0]="",[1]="Optional metadata of the file, e.g: `{mymetadatavalue=\"grapes\"}`",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="This function does not return anything"},children={}}}}}},[105]={name="main.md",path="/picotron_api/functions/stat/main.md",data={[0]={level=1,text="function stat(n,[...])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Greatly helped by [@akd-io and @Maxine](https://github.com/akd-io/picotron/blob/ccb6d34d8594cd4c2d45930cf8723c241f5aa6e9/drive/projects/stat/stats.md?plain=1#L80)",[2]="Returns information about the system and can sometimes do actions such as garbage collection.",[3]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="n: `number`",content={[0]="",[1]="The id for the information you want to fetch",[2]=""},children={}},[1]={level=3,text="[...]: `arbritrary`",content={[0]="",[1]="Arbritrary arguments, sometimes used in stat, e.g: with `stat(302,keycode)`",[2]=""},children={}},[2]={level=3,text="Valid usage",content={[0]="",[1]="Where the first number is `n` and any other arguments, if present, are `[...]`",[2]="",[3]="`Unknown` signifies that it returns values, but what they mean is unknown.",[4]="",[5]="@Astralsparv's [Picotron Logger Distribution](https://github.com/Astralsparv/Picotron-Logger-Distribution) will be updated to help document this, fed the arbritrary values seen in unknown stats and detecting any change in the stat per frame in hopes of finding a cause and reproducing it.",[6]=""},children={[0]={level=4,text="Stats",content={[0]="where c is a channel, addr is an address, n is a node:",[1]="",[2]="* 0 - memory usage (bytes), also triggers a garbage collection",[3]="* 1 - cpu usage (decimal)",[4]="* 2 - reserved",[5]="* 3 - raw memory usage (bytes), no garbage collection",[6]="* 5 - runtime, system version",[7]="     `runtime,system_version=stat(5)`",[8]="* 7 - operating fps (60, 30, 20, 15)",[9]="* 86 - epoch time",[10]="* 87 - timezone delta (seconds)",[11]="* 101 - web: player cart id (when playing a bbs cart; nil otherwise)",[12]="* 150 - web: window.location.href",[13]="* 151 - web: stat(150) up to the end of the window.location.pathname",[14]="* 152 - web: window.location.host",[15]="* 153 - web: window.location.hash",[16]="* 301 - total CPU usage",[17]="* 302, keycode - returns human readable name for the keycode, surface [SDL's GetKeyName](https://wiki.libsdl.org/SDL2/SDL_GetKeyName)",[18]="* 305 - Whether any key is pressed",[19]="* 307 - 1.0 if current working path is `/system` (including if the cartridge is located in `/system/`)",[20]="* 308 - Unknown",[21]="* 309 - Unknown",[22]="* 310 - Unknown",[23]="* 311 - Unknown",[24]="* 312 - 4096 (amount of bytes in a page)",[25]="* 313 - Unknown, *likely* amount of memory allocated total",[26]="* 314 - Pi as `3..1415926535898`",[27]="* 315 - Presence of `-x` CLI argument when running Picotron headless",[28]="* 316 - Path specified when running headless",[29]="* 317 - `3.0` when a binary or html export, `1.0` when running on the BBS web player, `0.0` otherwise",[30]="* 318 - `1.0` when a html export (including BBS web player), `0.0` otherwise",[31]="* 320 - `1.0` when recording a gif, `0.0` otherwise",[32]="* 321 - amount of frames that the active gif capture has, `0.0` otherwise",[33]="* 322 - `1.0` when you're actively capturing a gif, `0.0` otherwise",[34]="* 330 - `1.0` when Picotron's battery saver is active, `0.0` otherwise",[35]="* 400+c,0 - `1.0` when a note is held, `0.0` otherwise",[36]="* 400+c,1 - channel instrument",[37]="* 400+c,2 - channel volume",[38]="* 400+c,3 - channel pan",[39]="* 400+c,4 - channel pitch",[40]="* 400+c,5 - channel bend",[41]="* 400+c,6 - channel effect",[42]="* 400+c,7 - channel effect_p",[43]="* 400+c,8 - channel tick length",[44]="* 400+c,9 - channel row",[45]="* 400+c,10 - channel row tick",[46]="* 400+c,11 - channel sfx tick",[47]="* 400+c,12 - channel sfx index, `-1` if no sfx playing",[48]="* 400+c,13 - channel last played sfx index",[49]="* 400+c,19,addr - stereo output of buffer (returns number of samples)",[50]="* 400+c,20+n,addr - mono output of buffer for a node (0..7)",[51]="* 464 - bitfield indicating which channels are playing (sfx)",[52]="* 465, addr - copy last mixer stereo output buffer output is written as int16's to addr. (returns number of samples written)",[53]="* 466 - which pattern is playing (-1 when no music is playing)",[54]="* 467 - index of the left-most non-looping music channel",[55]="* 498 - bitfield of currently active audio channels system-wide",[56]="* 984 - Unknown",[57]="* 985 - Unknown",[58]="* 987 - miliseconds picotron has been running",[59]="* 988 - `1.0` if both left and right control keys are held, `0.0` otherwise",[60]=""},children={}}}}}},[2]={level=2,text="Returns",content={[0]="",[1]="The queried information from the stat, unique to `n`, see the valid stats above for information on specific stats.",[2]=""},children={}},[3]={level=2,text="Unknown stats",content={[0]="",[1]="More information on unknown stats.",[2]="",[3]="[stat.lua](https://github.com/akd-io/picotron/blob/main/drive/projects/stat/stat.lua) (a test from akd-io)",[4]=""},children={[0]={level=3,text="308",content={[0]="",[1]="Observed value `1973.0` and `2334.0` in stat.lua output.",[2]="",[3]="No code references.",[4]=""},children={}},[1]={level=3,text="309",content={[0]="",[1]="Observed value `60531740.0` and `63912031.0` in stat.lua output.",[2]="",[3]="No code references.",[4]=""},children={}},[2]={level=3,text="310",content={[0]="",[1]="Observed value `551.0`, `565.0` and `3689.0` in stat.lua output.",[2]="",[3]="Same decompiled code as for stat(311) below, but passing 2 to pdisk_count_slots_by_kind() instead of 0.",[4]="",[5]="No code references.",[6]=""},children={}},[3]={level=3,text="311",content={[0]="",[1]="Functionality unknown.",[2]="",[3]="Observed value `15833.0`, `15819.0` and `12342.0` in stat.lua output.",[4]="",[5]="Decompiled code by Maxine:",[6]="",[7]="```C",[8]="if (stat_type != UNDOCUMENTED_311) goto LAB_00460c7f;",[9]="tmp_int0 = pdisk_count_slots_by_kind(0);",[10]="result_num = (lua_Number)tmp_int0;",[11]="```",[12]=""},children={[0]={level=4,text="Picotron Manual reference",content={[0]="Each process in Picotron has a limit of 32MB RAM, which includes both allocations for Lua objects, and data stored directly in RAM using memory functions like poke() and memcpy(). In the latter case, 4k pages are allocated when a page is written, and can not be deallocated during the process lifetime.",[1]="",[2]="Only 16MB of ram is addressable: 0x000000..0xffffff. Memory addresses below 0x80000 and above 0xf00000 are mostly reserved for system use, but anything in the 0x80000..0xefffff range can be safely used for arbitrary purposes.",[3]=""},children={}}}},[4]={level=3,text="313",content={[0]="",[1]="Amount of memory allocated",[2]="",[3]="Decompiled by Maxine",[4]="```C",[5]="    case UNDOCUMENTED_313:",[6]="        lua_pushnumber(L, cproc->mem_highwater);",[7]="        return 1;",[8]="```",[9]=""},children={}},[5]={level=3,text="984",content={[0]="",[1]="To do with yielding and coroutines",[2]="",[3]="Code reference: ",[4]="```lua",[5]="if costatus(c) == \"suspended\" and stat(984) == 0 then",[6]="```"},children={}},[6]={level=3,text="985",content={[0]="",[1]="Observed value `1.0` in stat.lua output.",[2]=""},children={}},[7]={level=3,text="988",content={[0]="",[1]="To do with minimal terminal setup",[2]="",[3]="Code reference:",[4]="```lua",[5]="-- give a guaranteed short window to skip",[6]="if (stat(988) > 0) bypass = true _signal(35)",[7]="```",[8]=""},children={}}}}}}}},[106]={name="main.md",path="/picotron_api/functions/sspr/main.md",data={[0]={level=1,text="sspr(sprite,sx,sy,sw,sh,x,y,[dw],[dh][flip_x],[flip_y])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`sspr` draws a sprite, similar to [`spr()`](/functions/spr/main.md), but allows you to also resize the sprite.",[2]="",[3]="This is scaling sprites, e.g: zoom",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="sprite: `index` or `userdata u8`",content={[0]="",[1]="What is drawn to the screen",[2]=""},children={}},[1]={level=3,text="sx,sy: `number`",content={[0]="",[1]="The coordinates of what is treated as the top left of `sprite`, allowing you to add offsets",[2]=""},children={}},[2]={level=3,text="sw,sh: `number`",content={[0]="",[1]="The width & height of `sprite` - allows you to crop the sprite.",[2]=""},children={}},[3]={level=3,text="dx,dy: `number`",content={[0]="",[1]="Where the sprite is to be drawn on screen",[2]=""},children={}},[4]={level=3,text="[dw],[dh]: `number`",content={[0]="",[1]="Optional, defaults to the proportions of the sprite",[2]="",[3]="The new width & height of `sprite`.",[4]="",[5]="`sprite` will be drawn rescaled to match the proportions of `[dw],[dh]`.",[6]=""},children={}},[5]={level=3,text="[flip_x],[flip_y]",content={[0]="",[1]="Flips the sprite on their respective axis",[2]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="```lua",[2]="local mapUD=userdata(\"u8\",480,270)",[3]="",[4]="set_draw_target(mapUD) --all graphical operations now go to the map userdata",[5]="map() --draw map",[6]="set_draw_target() --return graphical operations to the window/screen",[7]="",[8]="--mapwidth,mapheight is the proportions of the map",[9]="--x,y is where to draw the map",[10]="",[11]="sspr(mapUD,0,0,mapwidth,mapheight,x,y,mapwidth*2,mapheight*2)",[12]="```",[13]=""},children={}},[3]={level=2,text="Returns",content={[0]="",[1]="Unknown",[2]=""},children={}}}}}},[107]={name="main.md",path="/picotron_api/functions/spr/main.md",data={[0]={level=1,text="spr(sprite,[x],[y],[flip_x],[flip_y])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`spr` draws a sprite from either a userdata or the spritebank",[2]="",[3]="This is scaling sprites, e.g: zoom",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="sprite",content={[0]="",[1]="Sprite index from the spritesheet, or a `userdata u8` piece of data - this is what is drawn.",[2]=""},children={}},[1]={level=3,text="x,y",content={[0]="",[1]="The coordinates of where to draw the sprite",[2]=""},children={}},[2]={level=3,text="[flip_x],[flip_y]",content={[0]="",[1]="Flips the sprite on their respective axis",[2]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="Draw a sprite from sprite index 0 to position (0,0)",[2]="```lua",[3]="spr(0,0,0)",[4]="```",[5]="",[6]="Draw a sprite from a `userdata u8` to position (0,0)",[7]="```lua",[8]="sp=--[[pod_type=\"gfx\"]]unpod(\"b64:bHo0ALEAAAC4AQAA_gFweHUAQyBAQATw9jPwHDOwBQCvcDM3M-AUMzEzMAkACEuz8BSzBQCPcDNw8wxwM7AHAAGN8ABz_wxz8AQGADAAM-t3AAkFAO9wMzt-IPsMfjszMDM7fgkABo8_dz77BD53PgsAEz9_u34KABBf-gS7-gQIAAjvPxp_Nz67Pjd_PTMwMz0MAA6fcDN9frt_fTOwCAAEYPAAc7s_uwwBDwcAAFQM8wzwFAQAUPMM8P8D\")",[9]="",[10]="spr(sp,0,0)",[11]="```",[12]=""},children={}},[3]={level=2,text="Returns",content={[0]="",[1]="Unknown",[2]=""},children={}}}}}},[108]={name="main.md",path="/picotron_api/functions/set_spr/main.md",data={[0]={level=1,text="set_spr(index, s, [flags_val])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`set_spr` adds or removes a sprite at a set index.",[2]="",[3]="Sprite flags are stored at 0xc000 (16k)",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="index",content={[0]="",[1]="The index of the sprite you're modifying in the spritesheet.",[2]=""},children={}},[1]={level=3,text="s",content={[0]="",[1]="The sprite data to set in sprite `index`, form of a `userdata u8`.",[2]=""},children={}},[2]={level=3,text="[flags_val]",content={[0]="",[1]="The flag information to be set for sprite `index`, defaults to 0",[2]="",[3]="Poked into `0xc000`, offset by `index &= 0x3fff`",[4]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="This function does not return anything"},children={}}}}}},[109]={name="main.md",path="/picotron_api/functions/send_message/main.md",data={[0]={level=1,text="send_message(proc_id, msg, [response])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`send_message` allows you to communicate with other processes.",[2]="",[3]="This is useful for communication between processes",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="proc_id",content={[0]="",[1]="The process ID of which to send the message to",[2]=""},children={}},[1]={level=3,text="msg",content={[0]="",[1]="The message, a table, to send to the process `proc_id`.",[2]="",[3]="A message must have the key `event`, being a string that is sent to the process as its event.",[4]="",[5]="This can be any arbritrary string - handled by the process that receives it.",[6]=""},children={}},[2]={level=3,text="[response]",content={[0]="",[1]="Optional argument",[2]="",[3]="By setting `[response]` to `true`, it causes the function to stall the entire program until it receives a response from the other process.",[4]="",[5]="Note that blocking in this way can be quite slow - it is intended to be used in situations where it is acceptable to skip a frame or two while waiting for a reply.",[6]="",[7]="When `[response]` is a function, the event handler of the receiving process can reply with another message that is handled by that function.",[8]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="> From the Picotron Manual",[2]="",[3]="When reply is true, send_message blocks until the process responds with a reply. For example, paste the following in to terminal to set up a headless process that responds to \"get_id\" messages:",[4]="",[5]="```lua",[6]="store(\"/ram/get_id.lua\", [[",[7]="    id = 1",[8]="    function _update() end",[9]="    on_event(\"get_id\", function() ",[10]="        id += 1",[11]="        return {id = id} ",[12]="    end)",[13]="]])",[14]="pid2 = create_process(\"/ram/get_id.lua\")",[15]="```",[16]="",[17]="A unique id can be fetched from this process with:",[18]="",[19]="```lua",[20]="?send_message(pid2, {event = \"get_id\"}, true).id",[21]="```",[22]="",[23]="The true argument for `[response]` causes the message to be blocking - waiting for the response from `pid2`, being the data including the `id` it requests.",[24]=""},children={}},[3]={level=2,text="Sandboxed Nature",content={[0]="",[1]="Sandboxed processes can send messages to:",[2]="",[3]="* itself",[4]="* /system/",[5]="* wm",[6]="",[7]="alongside sending certain events:",[8]="",[9]="* \"set_palette\"",[10]="* \"broadcast\" *if* it has a contained event of `set_palette`",[11]=""},children={}},[4]={level=2,text="Returns",content={[0]="",[1]="This function returns nothing, unless you have a response, where it instead returns the response of the event."},children={}}}}}},[110]={name="main.md",path="/picotron_api/functions/rm/main.md",data={[0]={level=1,text="rm(f0)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`rm` deletes `f0`, a file or directory (including all of the directory's contents).",[2]="",[3]="Attempting to delete `/desktop/host` just causes the Host OS to unmount, rather than deleting the folder and contents.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="f0",content={[0]="",[1]="The path to the file or directory to delete",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="Returns something, unknown what it returns"},children={}}}}}},[111]={name="main.md",path="/picotron_api/functions/printh/main.md",data={[0]={level=1,text="printh(str)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="printh() allows for you to print text to the Host OS Terminal.",[2]="",[3]="This allows for you to do more informative debugging of your program, alongside allowing stuff like logs in your program.",[4]="",[5]="[Setting up a Host OS terminal for Picotron](/guides/host_os_terminal/main.md)",[6]="",[7]="Source: [source.lua](source.lua)",[8]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="str",content={[0]="",[1]="String to print",[2]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="Prints the CPU usage every time the frame updates",[2]="```lua",[3]="function _update()",[4]="    printh(stat(1)*100 ..\"% cpu usage\")",[5]="end",[6]="```",[7]=""},children={}},[3]={level=2,text="Returns",content={[0]="",[1]="Unknown"},children={}}}}}},[112]={name="main.md",path="/picotron_api/functions/print/main.md",data={[0]={level=1,text="print(str,x,y,color)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="This prints text to the active display of Picotron.",[2]="",[3]="When there is no graphical display, e.g: Picotron is running headless (no display), or there is no window setup - this feeds to the [`printh`](/picotron_api/functions/printh/main.md) function.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="str",content={[0]="",[1]="String to print",[2]=""},children={}},[1]={level=3,text="x,y",content={[0]="",[1]="The top left position of the text that is printed",[2]=""},children={}},[2]={level=3,text="color",content={[0]="",[1]="The index of the color in the color palette to draw the text in.",[2]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="Prints the CPU usage in the top left of the screen in the color white (`7`)",[2]="",[3]="```lua",[4]="function _update()",[5]="    print(stat(1)*100 ..\"% cpu usage\",0,0,7)",[6]="end",[7]="```",[8]=""},children={}},[3]={level=2,text="Returns",content={[0]="",[1]="Returns the ending x & y coordinate of the text that is printed.",[2]="```lua",[3]="fx,fy=print(\"hi\")",[4]="```",[5]=""},children={}}}}}},[113]={name="main.md",path="/picotron_api/functions/pid/main.md",data={[0]={level=1,text="pid()",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`pid` returns the process id of the process calling it.",[2]="",[3]="This is useful for communication between processes",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Usage Example",content={[0]="",[1]="Using the filenav with the intention to save a file.",[2]="",[3]="```lua",[4]="create_process(\"/system/apps/filenav.p64\", {",[5]="    open_with = pid(), --shows the id of the process that opened it",[6]="    intention = \"save_file_as\",",[7]="    path=\"/desktop/\",",[8]="    use_ext=\"spr\",",[9]="    window_attribs = {",[10]="        workspace=\"current\",",[11]="        autoclose=true",[12]="    }",[13]="})",[14]="```",[15]=""},children={}},[2]={level=2,text="Returns",content={[0]="",[1]="The process ID"},children={}}}}}},[114]={name="main.md",path="/picotron_api/functions/mv/main.md",data={[0]={level=1,text="mv(src_p, dest_p)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`mv` moves the file or folder from `src_p` to `dest_p`.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={}},[2]={level=2,text="src_p",content={[0]="",[1]="The path to the source file/folder",[2]=""},children={}},[3]={level=2,text="dest_p",content={[0]="",[1]="Path to a folder to put the source file/folder into",[2]=""},children={}},[4]={level=2,text="Returns",content={[0]="",[1]="If src is nil > \"could not resolve source path\"",[2]="If dest is nil > \"could not resolve destination path\"",[3]="If using a protocol (e.g: `bbs://`) > \"can not write to {protocol you attempted}://\"",[4]="",[5]="More returns are for other failures, unknown.",[6]=""},children={}},[5]={level=2,text="Future",content={[0]="",[1]="Ability to write to protocols"},children={}}}}}},[115]={name="main.md",path="/picotron_api/functions/mouse/main.md",data={[0]={level=1,text="mouse([new_mx,new_my])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`mouse` is used to get and set the positioning of the cursor relative to the window.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="new_mx",content={[0]="",[1]="The new x position of the mouse",[2]=""},children={}},[1]={level=3,text="new_my",content={[0]="",[1]="The new y position of the mouse",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]=""},children={[0]={level=3,text="mouse_x",content={[0]="",[1]="x-coordinate of the mouse",[2]=""},children={}},[1]={level=3,text="mouse_y",content={[0]="",[1]="y-coordinate of the mouse",[2]=""},children={}},[2]={level=3,text="mouse_b",content={[0]="",[1]="a bitfield:",[2]="",[3]="* 0x1 left mouse button",[4]="* 0x2 right mouse button",[5]="* 0x4 middle mouse button",[6]=" "},children={}},[3]={level=3,text="wheel_x",content={[0]="",[1]="The amount scrolled on the scrollwheel in the x-axis",[2]=""},children={}},[4]={level=3,text="wheel_y",content={[0]="",[1]="The amount scrolled on the scrollwheel in the y-axis",[2]=""},children={}}}},[3]={level=2,text="Examples",content={[0]="",[1]="Get the properties of the mouse & print when you left click or right click.",[2]="```lua",[3]="function _update()",[4]=" mouse_x, mouse_y, mouse_b, wheel_x, wheel_y = mouse()",[5]=" if (mouse_b&0x1==0x1) then",[6]="  print(\"left click!\")",[7]=" end",[8]=" if (mouse_b&0x2==0x2) then",[9]="  print(\"right click!\")",[10]=" end",[11]="end",[12]="```",[13]=""},children={}},[4]={level=2,text="Limitations",content={[0]="",[1]="The mouse() function does not allow you to set full properties of the mouse.",[2]="",[3]="This can be fixed using the following snippet to have access to the full mouse properties.",[4]="",[5]="```lua",[6]="--@astralsparv",[7]="function setMouse(x,y,b)",[8]="    send_message(3,{event=\"mouse\",mx=x,my=y,mb=b or 0})",[9]="end",[10]="```",[11]=""},children={}}}}}},[116]={name="main.md",path="/picotron_api/functions/mkdir/main.md",data={[0]={level=1,text="mkdir(p)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`mkdir` creates a new directory (empty folder) at the path `p`",[2]="",[3]="This does not support protocols (e.g: bbs://)",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="p",content={[0]="",[1]="The path for the new directory",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="This function returns an error in the form of a string if the function fails.",[2]="Otherwise, returns nil",[3]=""},children={}},[3]={level=2,text="Future",content={[0]="",[1]="Ability to write to protocols"},children={}}}}}},[117]={name="main.md",path="/picotron_api/functions/menuitem/main.md",data={[0]={level=1,text="menuitem",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`menuitem` lets you edit the drop down menu on the window / context menu of the window.",[2]="",[3]="This has multiple different argument setups.",[4]="Source: [source.lua](source.lua)",[5]=""},children={}}}},[1]={level=1,text="menuitem()",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Leaving the function with no arguments clears the menu of its items",[2]=""},children={}},[1]={level=2,text="Returns",content={[0]="",[1]="Returns nothing",[2]=""},children={}}}},[2]={level=1,text="menuitem(m)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Picotron method for menu items, more capability than the legacy support p8 method",[2]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="m",content={[0]="",[1]="Setting this to `---` creates a divider menu item",[2]="",[3]="Otherwise modifies the menu through `m` acting as a table.",[4]="",[5]="`m` having the following values can have different effects:",[6]=""},children={[0]={level=4,text="id",content={[0]="",[1]="Sets the ID of the item, replaces any item with this id with this.",[2]=""},children={}},[1]={level=4,text="label",content={[0]="",[1]="The text to display as the option",[2]="",[3]="A lack of label causes the item to be deleted",[4]=""},children={}}}}}},[2]={level=2,text="Returns",content={[0]="",[1]="Returns nothing"},children={}}}}}},[118]={name="main.md",path="/picotron_api/functions/memmap/main.md",data={[0]={level=1,text="memmap(ud,addr,[offset],[len])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`memmap` allows you to write a 4k (`0x1000`) userdata, `ud` to an address, `addr` in memory",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="ud",content={[0]="",[1]="The userdata that is mapped into memory",[2]=""},children={}},[1]={level=3,text="addr",content={[0]="",[1]="The address to map the userdata into",[2]="",[3]="Mapping to address `0x100000` automatically unmaps the loaded map data & replacing the loaded map in memory with `ud`.",[4]=""},children={}},[2]={level=3,text="[offset]",content={[0]="",[1]="Unknown",[2]="",[3]="> Presuming that it's the offset in either memory in the userdata",[4]=""},children={}},[3]={level=3,text="[len]",content={[0]="",[1]="Unknown",[2]="",[3]="> Presuming that it's the length of the userdata"},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="Returns the inputted `ud`",[2]="",[3]="Allows things such as:",[4]="",[5]="```",[6]="pfxdat = fetch(\"tune.sfx\"):memmap(0x30000)",[7]="```"},children={}}}}}},[119]={name="main.md",path="/picotron_api/functions/map/main.md",data={[0]={level=1,text="map(ud, [b], [...])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`map` draws a map, either through picotron system or legacy pico-8 method",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Picotron System",content={[0]=""},children={[0]={level=3,text="ud",content={[0]="",[1]="The map data in the datatype `userdata`",[2]="",[3]="If `ud` is not in the datatype `userdata`, it follows the legacy Pico-8 format.",[4]=""},children={}},[1]={level=3,text="[b]",content={[0]="",[1]="Unknown",[2]=""},children={}},[2]={level=3,text="[...]",content={[0]="",[1]="Extra arguments that are sent through to the system _draw_map function.",[2]=""},children={}},[3]={level=3,text="> Returns",content={[0]="",[1]="This function does not return anything",[2]=""},children={}}}},[2]={level=2,text="Legacy Pico-8 System",content={[0]="",[1]="The legacy Pico-8 system is added for legacy support and an alternative way to use maps.",[2]="",[3]="Legacy Pico-8 function",[4]="",[5]="`map(celx, cely, sx, sy, celw, celh, [layer])`",[6]=""},children={[0]={level=3,text="celx",content={[0]="",[1]="The column location of the map cell in the upper left corner of the region to draw, where 0 is the leftmost column.",[2]=""},children={}},[1]={level=3,text="cely",content={[0]="",[1]="The row location of the map cell in the upper left corner of the region to draw, where 0 is the topmost row.",[2]=""},children={}},[2]={level=3,text="sx",content={[0]="",[1]="The x coordinate of the screen to place the upper left corner.",[2]="",[3]=""},children={}},[3]={level=3,text="sy",content={[0]="",[1]="The y coordinate of the screen to place the upper left corner.",[2]=""},children={}},[4]={level=3,text="celw",content={[0]="",[1]="The number of map cells wide in the region to draw.",[2]=""},children={}},[5]={level=3,text="celh",content={[0]="",[1]="The number of map cells tall in the region to draw.",[2]=""},children={}},[6]={level=3,text="[layer]",content={[0]="",[1]="If specified, only draw sprites that have flags set for every bit in this value (a bitfield). The default is 0 (draw all sprites).",[2]=""},children={}}}},[3]={level=2,text="Returns",content={[0]="",[1]="This function does not return anything"},children={}}}}}},[120]={name="main.md",path="/picotron_api/functions/include/main.md",data={[0]={level=1,text="include(filename)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="The `include` function allows you to attach scripting files to your program (`lua`).",[2]="",[3]="If the source has a syntax error, it reports errors to the console, listing the syntax error and location",[4]="If the source file is not a text file, it notifies that it cannot include it.",[5]="",[6]="Source: [source.lua](source.lua)",[7]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="filename",content={[0]="",[1]="The relative or absolute path to the file.",[2]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="Example `module.lua` which returns a version number and creates two helper functions for drawing sprites.",[2]="",[3]="```lua",[4]="function sprFlippedX(s,x,y)",[5]="    spr(s,x,y,true)",[6]="end",[7]="",[8]="function sprFlippedY(s,x,y)",[9]="    spr(s,x,y,nil,true)",[10]="end",[11]="",[12]="return \"1.0\"",[13]="```",[14]="",[15]="Cartridge that includes this",[16]="",[17]="```lua",[18]="local version=include(\"module.lua\")",[19]="if (version != latestVersion){",[20]="    notify(\"module.lua is not the running the latest version.\")",[21]="}",[22]="",[23]="sprFlippedX(1,0,0)",[24]="```",[25]="",[26]="This warns you if the version is not the latest version (e.g: taken from a webpage), then proceeds to draw sprite 1 at 0,0 using the helper function.",[27]=""},children={}},[3]={level=2,text="Returns",content={[0]="",[1]="Returns `func()`, so that the imported file can return something - this also runs the file with `func()`",[2]="256 file limit > `nil`",[3]="Can't fetch the file > `nil`",[4]=""},children={}},[4]={level=2,text="Limitations",content={[0]="",[1]="There is an arbritrary limit where only 256 of the same files can be included."},children={}}}}}},[121]={name="main.md",path="/picotron_api/functions/get_spr/main.md",data={[0]={level=1,text="get_spr(index)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`get_spr` returns the sprite information of the sprite at `index`.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="index",content={[0]="",[1]="The sprite index of which you want the information",[2]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="This returns the `userdata u8` graphical data of the sprite at sprite `index`."},children={}}}}}},[122]={name="main.md",path="/picotron_api/functions/create_process/main.md",data={[0]={level=1,text="create_process(prog_name_p, [env_patch])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`create_process` runs a process, `prog_name_p`, with optional env data patched in through `[env_patch]`;",[2]="",[3]="This can be done to package multiple pieces of software into one, alongside allowing for multi-process software.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="prog_name_p",content={[0]="",[1]="The filepath to the file of which to create a process from.",[2]="",[3]="This is typically a picotron cartridge or a `.lua` file.",[4]=""},children={}},[1]={level=3,text="[env_path]",content={[0]="",[1]="Optional argument",[2]="",[3]="This allows you to patch environmental information to the process in the form of a table.",[4]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="This creates a process, running `app.p64` where `app.p64` prints the text that was fed into it.",[2]="",[3]="When this process runs `env()`, it contains the argument `text`.",[4]="",[5]="```lua",[6]="create_process(\"app.p64\",{text=\"Hi!\"})",[7]="```",[8]="",[9]="Within `app.p64`:",[10]="",[11]="```lua",[12]="print(env().text);",[13]="```",[14]=""},children={}},[3]={level=2,text="Sandboxed Nature",content={[0]="",[1]="Sandboxed apps can only create processes of:",[2]="",[3]="* /system/apps/filenav.p64",[4]="* /system/apps/notebook.p64",[5]="* /system/util/open.lua",[6]="* /system/util/ls.lua",[7]="* files stored within the sandboxed app",[8]="* apps from `bbs://`",[9]="",[10]="All apps run through this are also sandboxed",[11]=""},children={}},[4]={level=2,text="Returns",content={[0]="",[1]="This function returns the process id of the created process & an error string.",[2]="",[3]="If the process created is a process that they cannot create > nil, \"sandboxed process can not create_process()\"",[4]="",[5]="If the process creates more than 20 processes in a single minute > return nil, \"sandboxed process can not create_process() more than 20 / minute\""},children={}}}}}},[123]={name="main.md",path="/picotron_api/functions/cp/main.md",data={[0]={level=1,text="cp(src_p, dest_p)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`cp` copies the file or folder from `src_p` to the location `dest_p`.",[2]="",[3]="If `dest_p` is a file, it overwrites the file.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={}},[2]={level=2,text="src_p",content={[0]="",[1]="The path to the source file/folder",[2]=""},children={}},[3]={level=2,text="dest_p",content={[0]="",[1]="Path to a folder/file to replace",[2]=""},children={}},[4]={level=2,text="Returns",content={[0]="",[1]="If src is nil > \"could not resolve source path\"",[2]="If dest is nil > \"could not resolve destination path\"",[3]="If using a protocol (e.g: `bbs://`) > \"can not write to {protocol you attempted}://\"",[4]="",[5]="Other failures:",[6]="    fstat of the source fails > \"could not read source location\"",[7]="    copying a folder inside of itself > \"can not copy inside self\"",[8]="    copying `/` inside of itself > \"can not copy /\"",[9]=""},children={}},[5]={level=2,text="Future",content={[0]="",[1]="Ability to write to protocols"},children={}}}}}},[124]={name="main.md",path="/picotron_api/functions/cls/main.md",data={[0]={level=1,text="cls([color])",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="`cls` clears the draw target by filling it with a color",[2]="",[3]="Often used in `_draw()` at the start of the frame to flush the previous frame.",[4]="",[5]="Source: [source.lua](source.lua)",[6]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="[color]",content={[0]="",[1]="Defaults to 0 (black)",[2]="",[3]="The color to draw to the draw target",[4]=""},children={}}}},[2]={level=2,text="Returns",content={[0]="",[1]="Unknown"},children={}}}}}},[125]={name="main.md",path="/picotron_api/functions/camera/main.md",data={[0]={level=1,text="camera(x,y)",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="camera() allows for you to set the relative 0,0 of all graphical operations.",[2]="",[3]="Source: [source.lua](source.lua)",[4]=""},children={}},[1]={level=2,text="Arguments",content={[0]=""},children={[0]={level=3,text="x",content={[0]="",[1]="x coordinate to set",[2]=""},children={}},[1]={level=3,text="y",content={[0]="",[1]="y coordinate to set",[2]=""},children={}}}},[2]={level=2,text="Examples",content={[0]="",[1]="Sets a player object to be in the middle of the screen",[2]="```lua",[3]="",[4]="--player object",[5]="player={",[6]="    x=0,",[7]="    y=0",[8]="}",[9]="",[10]="--set the player to be in the middle of the screen",[11]="",[12]="screen={",[13]="    width=480,",[14]="    height=270",[15]="}",[16]="",[17]="function _update()",[18]="    camera={",[19]="        x=player.x-(screen.width/2),",[20]="        y=player.y-(screen.height/2),",[21]="    }",[22]="",[23]="    camera(x,y)",[24]="end",[25]="```",[26]="",[27]="This can be paired with `mid()` to clamp it to the viewable area, e.g: the map.",[28]=""},children={}},[3]={level=2,text="Returns",content={[0]="",[1]="Returns the previous camera's x,y positions."},children={}}}}}},[126]={name="readme.md",path="/information/readme.md",data={[0]={level=1,text="Picotron Information",content={[0]="",[1]="[Roadmap](roadmap.md)",[2]="",[3]="[What Is Picotron](whatis.md)"},children={}}}},[127]={name="roadmap.md",path="/information/roadmap.md",data={[0]={level=3,text="from the [main page](https://www.lexaloffle.com/picotron.php?page=roadmap)",content={[0]=""},children={}},[1]={level=1,text="Picotron Roadmap",content={[0]=""},children={[0]={level=2,text="Picotron 0.0: \"Playground\" (2022 Q4)",content={[0]="",[1]="// Open-access web build for testing (became unavailable at 0.1)",[2]="",[3]="Architecture	// File system, system events, memory mapping, wm",[4]="",[5]="GFX Pipeline	// Colour tables, draw state",[6]="",[7]="API	// Based on Lua 5.4, compatible w/ PICO-8 where possible",[8]="",[9]="CPU	// Find costs that roughly match slowest hosts",[10]="",[11]="Audio	// Synthesizer runtime & test carts",[12]="",[13]="** offline for now, but will come back later in some form",[14]=""},children={}},[1]={level=2,text="Picotron 0.1 (~~2023~~ 2024-03-14)",content={[0]="",[1]="",[2]="Binary Builds	// Windows, Mac, Linux",[3]="",[4]="Editors	// Code, Pixels, Maps, Synth Designer, Tracker",[5]="",[6]="Desktop	// Run window-based programs, file management gui",[7]="",[8]="Customisation	// Theme editor, wallpapers, screensavers",[9]="",[10]="File Formats	// Plain-text .p64, Binary .p64.rom, Shareable .p64.png",[11]="",[12]="HTTP GET	// From local apps and exports only; not BBS carts",[13]="",[14]="BBS Integration	// Submit carts to a sub-forum, load # directly from bbs",[15]="",[16]="Sandboxing	// Safe to run untrusted carts without exposing Picotron drive",[17]="",[18]="HTML Exporter	// .wasm runtime + bundled cartridge, licensed similar to P8",[19]=""},children={}},[2]={level=2,text="Picotron 0.2 (~~2024~~ 2025-03-14)",content={[0]="",[1]="",[2]="Binary Exporters	// Windows, Mac, Linux -- includes desktop export",[3]="",[4]="bbs://	// [in 0.1.1e] Cross-platform bbs access; handles caching / offline access",[5]="",[6]="Tooltray	// [in 0.1.1e] Install widgets into the tooltray that can run sandboxed",[7]=""},children={}},[3]={level=2,text="Picotron 0.2.0* (2025-Q2/Q3)",content={[0]="",[1]="Raspi 64-bit	// Requires raspi 3 or later",[2]="",[3]="UDP / TCP sockets	// For binaries / exports",[4]="",[5]="GFX API	// rrect, P8SCII outline / underline",[6]="",[7]="Headless Programs	// interactive terminal apps, background processes",[8]="",[9]="Spritesheet Importer	// load from png / p8",[10]=""},children={}},[4]={level=2,text="Picotron 0.2.1 (2025-10)",content={[0]="",[1]="",[2]="Anywhen	// Fetch files and directory listings from any point in time",[3]="",[4]="File System	// sandboxing, mounting, robustness improvements",[5]="",[6]="Unsaved Changes	// monitor at the cart / file level and confirm overwrites etc",[7]="",[8]="Events	// non-blocking fetch(), blocking send_message(), custom mainloops",[9]=""},children={}},[5]={level=2,text="Picotron 0.2.2 (2025-11)",content={[0]="",[1]="Splore",[2]=""},children={}},[6]={level=2,text="Picotron 0.2.3 (2025-12)",content={[0]="",[1]="",[2]="Logins	// User can log in with bbs account, apps can read username",[3]="",[4]="podnet://	// User-wise public storage that can be used by sandboxed apps",[5]="",[6]="flp.io	// Bucket naming service; allows publishing podnet websites",[7]="",[8]="Cart switching	// BBS carts can load & run other BBS carts",[9]=""},children={}},[7]={level=2,text="Picotron 0.2.4 (2026-01)",content={[0]="",[1]="",[2]="Video Modes	// Support for extra fullscreen video modes",[3]="",[4]="Native Windows	// Export carts that run directly in a native host window",[5]="",[6]="Export Headless	// Export commandline programs",[7]=""},children={}},[8]={level=2,text="Picotron 0.3 [beta] (2026-03-14)",content={[0]="",[1]="BBS highscores	// Submit scores + extra data while logged in",[2]="",[3]="Websockets	// For exports [and bbs carts] on all platforms",[4]=""},children={}},[9]={level=2,text="Picotron 0.?",content={[0]="",[1]="// ongoing projects / no ETA",[2]="",[3]="Log Navigation	// Browse logs by category: notifications, errors, system crash etc",[4]="",[5]="Gui Builder	// Gui card editor and data format integrated with create_gui",[6]="",[7]="Libraries	// Standard fonts, instruments, fill patterns, palettes",[8]="",[9]="Stickers	// A general tagging and bookmarking scheme (experimental)",[10]="",[11]="Tool Improvements	// Miscelaneous features for bundled tools & accessories",[12]="",[13]="PFX6416 Features	// pcm instrument type, sfx instruments, channel-fx envelope control",[14]=""},children={}},[10]={level=2,text="Picotron 1.0",content={[0]="",[1]="Runtime / API Freeze	",[2]="",[3]="Extra Bundled Software	",[4]="",[5]="Runtime source exporting (export foo.src)	",[6]="",[7]="// Exported runtime licensing is TBD, but the focus will be on allowing cart authors to",[8]="",[9]="// implement additional platform support or custom features for their own projects."},children={}}}}}},[128]={name="whatis.md",path="/information/whatis.md",data={[0]={level=3,text="from the [main page](https://www.lexaloffle.com/picotron.php)",content={[0]=""},children={}},[1]={level=1,text="What is Picotron?",content={[0]="",[1]="Picotron is a Fantasy Workstation: a self-contained creative environment built for imaginary hardware. Create and share cute Lua apps that can run on the Picotron desktop, be shared as cartridge files, or exported as stand-alone HTML and binary distributables.",[2]=""},children={}},[2]={level=1,text="Specifications",content={[0]=""},children={[0]={level=2,text="Display: 480x270",content={[0]="",[1]="Picotron comes with a 480x270 64-colour display, which can also run at 240x135 or 160x90 and with custom palettes in fullscreen mode. The built-in graphics api gives versatile low-level access to the display, with features like 8x8 fill patterns, palette swapping and blending, stencil bits and tline3d for rasterizing perspective correct textures.",[2]=""},children={}},[1]={level=2,text="Cosy Filesystem",content={[0]="",[1]="Picotron uses a virtual filesystem that only exposes parts of your host system as needed. All files inside Picotron are in a special format (POD: Picotron Object Data) that allows Lua tables to be directly stored and fetched from disk. Storing data like save games and level data is simple: bundle everything into a Lua table and store() it as a pod.",[2]=""},children={}},[2]={level=2,text="Audio: PFX6416",content={[0]="",[1]="All of the audio in Picotron is generated in realtime by a purpose-built 64-node, 16 channel synthesizer called PFX6416. Nodes can either generate a signal from a wavetable, or modify it using FM/RING modulation, delay, HP/LP resonant filters and wave-shaping. Instruments and music/tracker data in Picotron are extremely tiny on disk; a piece of music with custom instrument design can be stored in 5~20k.",[2]=""},children={}},[3]={level=2,text="8M inst/sec",content={[0]="",[1]="Picotron uses a separate (slightly modified) Lua 5.4 vm per \"process\", and virtual cpu is divided up between processes for a maximum of 8M vm instructions per second. This means that Picotron cartridges can run at a consistent speed across varying platforms; if it runs ok on a high-end desktop machine, it will look roughly the same running under web on an old netbook.",[2]=""},children={}},[4]={level=2,text="256K Cartridges",content={[0]="",[1]="Applications, projects and distributable bundles are all the same type of thing in Picotron: a cartridge. Each cartridge acts like a regular folder and contains all of the source files and resources needed to run the program. On the host system it is stored as a single git-friendly text file (.p64: any size that fits in ram), or a shareable png format (.p64.png: max 256k of ROM data).",[2]=""},children={}}}},[3]={level=1,text="More information",content={[0]=""},children={[0]={level=2,text="Fantasy Desktop",content={[0]="",[1]="![Fantasy Desktop](https://www.lexaloffle.com/gfx/fantasy_desktop.gif)",[2]="",[3]="Picotron comes with a cute desktop interface featuring tabbed workspaces and a fold-out tooltray that is accessible from any workspace. The tooltray acts as a second desktop for handy access to frequently used files and widgets. Files can also be dropped on top of each other to form tidy stacks that are shuffleable with the mousewheel.",[4]=""},children={}},[1]={level=2,text="Bundled Tools",content={[0]="",[1]="![Bundled Tools](https://www.lexaloffle.com/gfx/picotron_bamboo.gif)",[2]="",[3]="Use the built-in editors or create your own! The included editors for code, graphics, tile maps, music and sound effects are themselves all made in Picotron and use standard /system/lib libraries for handling things like unlimited undo stacks, gui, and file management.",[4]=""},children={}},[2]={level=2,text="Customise your Workstation",content={[0]="",[1]="![Picotron Desktop](https://www.lexaloffle.com/dl/wip/picotron_desktop2.png)",[2]="",[3]="Make your own live wallpapers, screensavers, icons, widgets, and set up workflows just the way you like! Or have a look around the BBS to see what other cartridge authors are up to.",[4]="",[5]="> Example Wallpaper by [castpixel](https://twitter.com/castpixel)",[6]=""},children={}},[3]={level=2,text="Next Generation Fantasy Hardware",content={[0]="",[1]="![Picotron Bunny](https://www.lexaloffle.com/gfx/picotron_bunny.gif)",[2]="",[3]="Picotron is built on tightly integrated, flexible graphics and audio pipelines that can happily run on low powered host machines and web. They each come with a simple-to-use API for handling common things like drawing a colour-swapped sprite or triggering a sound effect, but the underlying data and machine state is all exposed in virtual RAM, offering a myriad of possibilities for those willing to venture down the rabbithole.",[4]=""},children={}}}},[4]={level=1,text="Status: Alpha",content={[0]="Picotron 0.2 is still new, but has a relatively complete API, binary and HTML exporters and BBS cartridge browsing. See the roadmap for future plans:",[1]="",[2]="[Roadmap](roadmap.md)"},children={}}}},[129]={name="readme.md",path="/guides/readme.md",data={[0]={level=1,text="guides",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Guides for development in Picotron",[2]="",[3]="[Writing a simple grid-based game](/guides/grid_based_game/main.md)",[4]="",[5]="[Using a Host OS terminal with Picotron](/guides/host_os_terminal/main.md)"},children={}}}}}},[130]={name="readme.md",path="/guides/short_snippets/readme.md",data={[0]={level=1,text="guides > short snippets",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Short code snippets rather than full guides",[2]=""},children={}}}}}},[131]={name="main.md",path="/guides/host_os_terminal/main.md",data={[0]={level=1,text="Using a Host OS terminal in Picotron",content={[0]="",[1]="This is a short guide designed to show you how to setup an environment to use [`printh`](/picotron_api/functions/printh/main.md) for debugging or logging.",[2]=""},children={[0]={level=2,text="Windows:",content={},children={[0]={level=3,text="Step 1. Getting the path of your Picotron executable",content={[0]="",[1]="This is typically found at `C:\Program Files (x86)\Picotron\picotron.exe` if you installed it, otherwise in the extracted folder if you are using the portable version of Picotron.",[2]="",[3]="If it is not in this location, you can:",[4]="* open the start menu",[5]="* type Picotron",[6]="* press open file location",[7]="* click Picotron's executable",[8]="* press `CTRL+SHIFT+C` to copy the path",[9]=""},children={}}}},[1]={level=2,text="Step 2. Creating the batch file",content={[0]="",[1]="Now that you have the path, all you have to do is open any text editor and paste in the path, e.g:",[2]="`\"C:\Program Files (x86)\Picotron\picotron.exe\"`",[3]="",[4]="You must ensure that there are double quotes `\"` surrounding the path as seen above.",[5]="",[6]="Save this file with the `.bat` extension, e.g: `picotron.bat`.",[7]=""},children={}},[2]={level=2,text="Step 3. Running the batch file",content={[0]="",[1]="Now once you run this batch file (the same as you would an exe), it will open up a terminal alongside Picotron.",[2]="",[3]="When anything is printed to the terminal with `printh`, it will now appear in your host OS terminal."},children={}}}}}},[132]={name="main.md",path="/guides/grid_based_game/main.md",data={[0]={level=1,text="Simple grid based game",content={[0]="",[1]="This is a short guide designed to teach you to create a simple game on a grid.",[2]=""},children={[0]={level=2,text="Step 1. Creating the sprites",content={[0]="",[1]="To begin, you should draw the following sprites:",[2]="",[3]="* a player",[4]="* a ground tile",[5]="* a solid tile",[6]="",[7]="Do this through the GFX Editor in `gfx/0.gfx`, and have all sprites the same size (e.g: 16x16).",[8]=""},children={}},[1]={level=2,text="Step 2. Creating the map",content={[0]="",[1]="You will need the map that your player will be on, this can be done with the map editor at `map/0.map`.",[2]="",[3]="Using the ground tiles and solid tiles, draw out the terrain.",[4]=""},children={}},[2]={level=2,text="Step 3. Drawing the screen",content={[0]="",[1]="In your `main.lua` is the main code for your cartridge. This is called when your cartridge is run, allowing you to import other `lua` files and create the basis of your game.",[2]="",[3]="To create the main loop, you can create the `_init`, `_update` and `_draw` functions - these are called on startup, every frame, and when a draw is called (less frequent than `_update` if there's lag) respectively.",[4]="",[5]="You will want to have a player variable, a table, and something to draw the player to the screen. Treat the player's positioning as fixed to the grid.",[6]="",[7]="The `_init` function creates the player",[8]="```lua",[9]="function _init()",[10]="    player={",[11]="        x=2,",[12]="        y=2,",[13]="        sprite=0",[14]="    }",[15]="end",[16]="```",[17]="",[18]="You can now access the player with stuff like `player.x`, `player.y` and `player.sprite`.",[19]="",[20]="Your update loop can be ignored for now.",[21]="",[22]="Your draw loop can draw the screen.",[23]="",[24]="The screen will consist of the map and the sprite.",[25]="",[26]="You can draw the map with [`map`](/functions/map/main.md) and draw the sprite with [`spr`](/functions/spr/main.md).",[27]="",[28]="You will need to call `cls()` at the beginning of the draw function - this will clear the screen and avoid drawing ontop of the previous frame continuously.",[29]="",[30]="```lua",[31]="function _draw()",[32]="    cls()",[33]="    map()",[34]="    spr(player.sprite,player.x*16,player.y*16)",[35]="end",[36]="```",[37]="",[38]="By multiplying it by 16, it applies it to a grid where each tile is 16x16. Replace `16` with your custom size if you have a different proportion - this does not affect anything else.",[39]="",[40]="By running this, you will now see the player at (2,2) but you cannot interact with the player.",[41]=""},children={}},[3]={level=2,text="Step 4. Moving the player",content={[0]=""},children={[0]={level=3,text="Basic movement",content={[0]="",[1]="Using the `_update` loop, you can add movement to the player.",[2]="",[3]="This can be done with the `btnp` function, which detects button presses every 4 frames.",[4]="",[5]="Create your update loop as such",[6]="```lua",[7]="function _update()",[8]="    if (btnp(0)) then",[9]="        player.x-=1",[10]="    end",[11]="end",[12]="```",[13]="",[14]="This will move the player left when you press left on the DPAD or analog joystick (left arrow key)",[15]="",[16]="Adding the following adds the other directions.",[17]="",[18]="```lua",[19]="function _update()",[20]="    if (btnp(0)) then",[21]="        player.x-=1",[22]="    end",[23]="    if (btnp(1)) then",[24]="        player.x+=1",[25]="    end",[26]="    if (btnp(2)) then",[27]="        player.y-=1",[28]="    end",[29]="    if (btnp(3)) then",[30]="        player.y+=1",[31]="    end",[32]="end",[33]="```",[34]="",[35]="This allows you to have full movement control of the player.",[36]="",[37]="If you run it now, it allows you to move along the grid for your game - though, it doesn't include collisions and stop you from leaving the map.",[38]="",[39]="Within Picotron Lua, you can also make use of inline code to clean the functions as seen:",[40]="```lua",[41]="function _update()",[42]="    if (btnp(0)) player.x-=1",[43]="    if (btnp(1)) player.x+=1",[44]="    if (btnp(2)) player.y-=1",[45]="    if (btnp(3)) player.y+=1",[46]="end",[47]="```",[48]=""},children={}},[1]={level=3,text="Collisions",content={[0]="",[1]="You can add collisions using `mget` by checking if the tile the player wants to move to is a solid tile or not.",[2]="",[3]="```lua",[4]="if (mget(nx,ny)==1)",[5]="```",[6]="",[7]="You can set this up in the update loop by creating a temporary x,y position that checks the collision before setting the player's true position.",[8]="",[9]="This craetes an x,y identical to the player's position at the start of the function.",[10]="",[11]="```lua",[12]="function _update()",[13]="    local nx,ny=player.x,player.y",[14]="    ...",[15]="```",[16]="",[17]="Now, instead of applying the movements to player.x,player.y, you apply it to nx,ny",[18]="```lua",[19]="function _update()",[20]="    local nx,ny=player.x,player.y",[21]="    if (btn(0)) nx-=1",[22]="    if (btn(1)) nx+=1",[23]="    if (btn(2)) ny-=1",[24]="    if (btn(3)) ny+=1",[25]="    ...",[26]="```",[27]="",[28]="This can be continued with:",[29]="",[30]="```lua",[31]="function _update()",[32]="    local nx,ny=player.x,player.y",[33]="    if (btn(0)) nx-=1",[34]="    if (btn(1)) nx+=1",[35]="    if (btn(2)) ny-=1",[36]="    if (btn(3)) ny+=1",[37]="",[38]="    if (mget(nx,ny)==1) then",[39]="        player.x,player.y=nx,ny",[40]="    end",[41]="end",[42]="```",[43]="",[44]="This treats tile `1` as a tile the player can walk ontop of & through.",[45]="",[46]="If the tile that the player tries to enter is not tile `1`, it ignores the collision.",[47]=""},children={}},[2]={level=3,text="Adding a tile system",content={[0]="",[1]="You can upgrade the tile system (checking collisions) with tables.",[2]="",[3]="Creating a lookup table with a table allows you to refer to this with the tile the player moves into.",[4]="",[5]="Create a tile registry is as such:",[6]="",[7]="```lua",[8]="walkableTiles={",[9]="    [1]=true",[10]="}",[11]="```",[12]="",[13]="Using `[index]`, it allows you to write an index into it, with a `true` value indicating that it is walkable.",[14]="",[15]="You do not need to add `[2]=false` or any other solid tile to this as such as it will default to being seen as false.",[16]="",[17]="Checking the collision is now seen as such:",[18]="",[19]="```lua",[20]="local tile=mget(nx,ny)",[21]="",[22]="if (walkableTiles[tile]) then",[23]="    player.x,player.y=nx,ny",[24]="end",[25]="```",[26]="",[27]="If `walkableTiles[tile]` is not set, this fails - indicating that it is solid.",[28]="If it is set, it indicates that it is walkable, and allows the player to walk through the tile.",[29]="",[30]="This tile system can be continued for any arbritrary purpose, e.g: if you want another type of tile.",[31]="",[32]="```lua",[33]="waterTiles={",[34]="    [3]=true",[35]="}",[36]="```",[37]="",[38]="You can check this in the same way that you checked collisions before, using the `waterTiles` lookup table alongside the `walkableTiles` lookup table",[39]=""},children={}}}},[4]={level=2,text="Step 5. Continue on",content={[0]="",[1]="You now have a simple player controller and a simple game loop, you can build on top of this yourself (or with any following guides) to create a larger game!"},children={}}}}}},[133]={name="readme.md",path="/environment/readme.md",data={[0]={level=1,text="environment",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Documentation on the Picotron environment/ecosystem",[2]="",[3]="[`/environment/settings/readme.md`](settings for Picotron)"},children={}}}}}},[134]={name="readme.md",path="/environment/settings/readme.md",data={[0]={level=1,text="environment > settings",content={[0]=""},children={[0]={level=2,text="Overview",content={[0]="",[1]="Settings in Picotron, set through [`config`](/system/util/config/main.md) util, `settings.p64` or directly at `/appdata/system/settings.pod`",[2]=""},children={}},[1]={level=2,text="Settings",content={[0]="",[1]="[Picotron's Battery Saver](battery_saver/main.md)",[2]="",[3]="[720p upscaler](blit_720p/main.md)",[4]="",[5]="[Fullscreen](fullscreen/main.md)",[6]="",[7]="[Mute Audio](mute_audio/main.md)",[8]="",[9]="[Pixel Perfect](pixel_perfect/main.md)",[10]="",[11]="[Right Shift Magnify](rshift_magnify/main.md)",[12]="",[13]="[Snap To Grid](snap_to_grid/main.md)",[14]="",[15]="[Sparkles](sparkles/main.md)",[16]="",[17]="[Stretch](stretch/main.md)",[18]="",[19]="[Theme](theme/main.md)",[20]="",[21]="[Wallpaper](wallpaper/main.md)",[22]="",[23]="[Floppy Windows](floppy_windows/main.md) - does absolutely nothing, just exists in settings!"},children={}}}}}},[135]={name="main.md",path="/environment/settings/wallpaper/main.md",data={[0]={level=1,text="wallpaper `string (filepath)`",content={[0]="",[1]="Path to a picotron cartridge"},children={}}}},[136]={name="main.md",path="/environment/settings/theme/main.md",data={[0]={level=1,text="theme `string (filepath)`",content={[0]="",[1]="Path to a .theme file"},children={}}}},[137]={name="main.md",path="/environment/settings/swap_stereo/main.md",data={[0]={level=1,text="swap_stereo `boolean`",content={[0]="",[1]="Swap the sides of your stereo audio"},children={}}}},[138]={name="main.md",path="/environment/settings/stretch/main.md",data={[0]={level=1,text="stretch `boolean`",content={[0]="",[1]="Stretch the Picotron screen to fill the entirity of your native screen"},children={}}}},[139]={name="main.md",path="/environment/settings/sparkles/main.md",data={[0]={level=1,text="sparkles `boolean`",content={[0]="",[1]="Sparkles follow the cursor"},children={}}}},[140]={name="main.md",path="/environment/settings/snap_to_grid/main.md",data={[0]={level=1,text="snap_to-grid `boolean`",content={[0]="",[1]="Files on the desktop snapping to a grid"},children={}}}},[141]={name="main.md",path="/environment/settings/rshift_magnify/main.md",data={[0]={level=1,text="rshift_magnify `boolean`",content={[0]="",[1]="Whether pressing `RIGHT SHIFT` should magnify the area around your cursor"},children={}}}},[142]={name="main.md",path="/environment/settings/pixel_perfect/main.md",data={[0]={level=1,text="pixel_perfect `boolean`",content={[0]="",[1]="Whether Picotron should be scaled up to be pixel perfect"},children={}}}},[143]={name="main.md",path="/environment/settings/network_access/main.md",data={[0]={level=1,text="network_access `boolean`",content={[0]="",[1]="Allow Picotron to access your network"},children={}}}},[144]={name="main.md",path="/environment/settings/mute_audio/main.md",data={[0]={level=1,text="mute_audio `boolean`",content={[0]="",[1]="Mute the audio of Picotron"},children={}}}},[145]={name="main.md",path="/environment/settings/fullscreen/main.md",data={[0]={level=1,text="fullscreen `boolean`",content={[0]="",[1]="Fullscreen Picotron in the host OS"},children={}}}},[146]={name="main.md",path="/environment/settings/floppy_windows/main.md",data={[0]={level=1,text="floppy_windows `nil`",content={[0]="",[1]="Does absolutely nothing!",[2]="",[3]="Left in by zep on accident?",[4]="",[5]="No reference to floppy_windows in /system/"},children={}}}},[147]={name="main.md",path="/environment/settings/blit_720p/main.md",data={[0]={level=1,text="blit_720p `boolean`",content={[0]="",[1]="Use Picotron's 720p upscaler, information by @bloodninja",[2]="",[3]="720p monitors (or resolutions which are multiples of that, such as 1440p) do not allow Picotron to show the display edge-to-edge - there will be black bars around the image.",[4]="",[5]="When players enable this somewhat vaguely-named option in Settings.p64, Picotron zooms in so that the display is filled, meaning some outer areas are cut off. Those of you of a certain vintage may remember this as overscan.",[6]=""},children={[0]={level=2,text="800p/Steamdeck example",content={[0]="",[1]="800p-fill-safe area",[2]="",[3]="For 800p and Deck players using the \"fill screen\" mode, the visible area is a rectangle of 432x270 starting at (24,0), visible with this code:",[4]="```lua",[5]="rect(24,0,467,269,31)",[6]="print(\"Steam Deck (800p in 'Fill' display mode)\",28,2,31)",[7]="```",[8]="",[9]="By default, the Deck does very well in 720p mode without enabling the \"720p scaler\" option, instead keeping small black bars at the top and bottom of the display while keeping the image sharp. For those players who use the Deck overlay to force the image to fill the screen, some horizontal area may be cut off.",[10]=""},children={}},[1]={level=2,text="720p-safe area",content={[0]="",[1]="For users using the \"720p scaler\", the visible area is a rectangle of 360x202 starting at (60,34), visible with this code:",[2]="",[3]="```lua",[4]="rect(60,34,419,235,8)",[5]="print(\"720p scaler\",62,36,8)",[6]="```",[7]="",[8]="[Example Cart](https://www.lexaloffle.com/bbs/?tid=153523) by @bloodninja for an example!",[9]="",[10]="![Display of the cart in runtime](https://www.lexaloffle.com/bbs/thumbs/pico64_dagupigewe-0.png)"},children={}}}}}},[148]={name="main.md",path="/environment/settings/battery_saver/main.md",data={[0]={level=1,text="battery_saver `boolean`",content={[0]="",[1]="Enable Picotron's battery saver"},children={}}}}}